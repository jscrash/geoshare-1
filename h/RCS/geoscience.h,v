head     1.12;
branch   ;
access   ;
symbols  ;
locks    julian:1.12; strict;
comment  @ * @;


1.12
date     91.05.23.16.21.29;  author julian;  state Exp;
branches ;
next     1.11;

1.11
date     91.05.21.00.19.28;  author julian;  state Exp;
branches ;
next     1.10;

1.10
date     91.05.21.00.18.31;  author julian;  state Exp;
branches ;
next     1.9;

1.9
date     91.05.11.22.24.32;  author julian;  state Exp;
branches ;
next     1.8;

1.8
date     91.05.11.22.24.17;  author julian;  state Exp;
branches ;
next     1.7;

1.7
date     91.05.07.19.04.47;  author vince;  state Exp;
branches ;
next     1.6;

1.6
date     91.05.05.17.06.47;  author julian;  state Exp;
branches ;
next     1.5;

1.5
date     91.04.30.17.02.15;  author julian;  state Exp;
branches ;
next     1.4;

1.4
date     91.04.22.21.43.13;  author julian;  state Exp;
branches ;
next     1.3;

1.3
date     91.04.22.21.39.11;  author julian;  state Exp;
branches ;
next     1.2;

1.2
date     91.04.19.20.10.36;  author julian;  state Exp;
branches ;
next     1.1;

1.1
date     91.04.19.12.48.59;  author julian;  state Exp;
branches ;
next     1.0;

1.0
date     91.04.19.11.50.49;  author julian;  state Exp;
branches ;
next     ;


desc
@Initial checkin of geoscience.h.
@


1.12
log
@add cmdline_tag to ContextReq struct
@
text
@#ifndef _GEOSCIENCE_H_DEFINED
#define _GEOSCIENCE_H_DEFINED

/*-----------------------------------------------------------------------------
| 
|   Module:    geoscience.h
|
|-------------------------------------------------------------------------------
| 
|         This code is the product of GeoQuest Systems, Inc. and Finder 
|         Graphics Systems, Inc and is protected under U.S. Copyright laws.
|         This code may be reproduced in part or whole by any
|         technique or facsimile adoption as long as this notice is included.
| 
|-------------------------------------------------------------------------------
|
|   Purpose:   This file contains symbol definitions and structure
|              specifications to be used in data interchange facilities
|              Current working title of system : GeoShare (generic) 
|              Other names: EDICT (GeoQuest Systems)
|                           GeoLink (Finder Graphics)
|                           FinderLink (Finder Graphics)
|                           interface.h (No one claims ownership)
| 
|   Notes:     
|
|   History:   1-Feb-1990       S. F. McAdoo,  GQS
|                  Original code.  
|              2-Jun-1990       J. G. Gillespie, Finder Graphics
|                  Enhance 2-D seismic structures
|                  Add null values for seismic survey, fault trace and well structs
|             25-Oct-1990       John Schultz,  GQS
|                  Add new map related structures
|             25-Oct-1990       Matt Hawthorne / Ed Fuss,  GQS
|                  Added preprocessor logic for release 8.0 ( && )
|             29-Oct-1990       Ed Fuss,  GQS
|                  Added more fields to the MAP structures.
|             21-Nov-1990       Ed Fuss,  GQS
|                  Modified the fields to the MAP structures.
|                  Created a new MAP structure, GSMap_t.
|             14-Jan-1991       Ed Fuss,  GQS
|                  Changed name from interface.h to interfacex.h so that
|                  this file will not conflict with 7x source.
|             25-Feb-1991       S. McAdoo, GQS
|                  Made into generic EDICT include file for public use
|              1-Mar-1991       S. McAdoo, GQS J Gillespie, FGS
|                  Reconfigure executive structures
|                  Remove WELL_STRUCT_1, WELL_STRUCT_2
|                  Major shaking of well structures - more to come...
|                  Standardize naming convention
|                      Mixed case type names appended by _t
|                      Upper Case constants preceded by GL_
|                  Changed file name to geoscience.h - awaiting better name
|             13-Mar-1991       S. McAdoo, GQS
|                  Upper Case constants preceded by GS_ in anticipation
|                      that the tentative executive(Pres, VP, etc.) 
|                      level acceptance of the name, GeoShare, sticks.
|                  Made adjustments to the executive level structures.    
|             15-Mar-1991       J Gillespie, FGS Schlumberger
|                               O Osawa, IDS Schlumberger
|                               S Guthery, ASC Schlumberger
|                               H Ganem, ESF Schlumberger
|                               K Waagbo, GECO Schlumberger
|                  Blue Book I
|             21-Mar-1991      S. McAdoo, GQS
|                  An experiment with separating seismic surfaces from the seismic
|                  data to fit jgg's surface set concept.
|             29-Mar-1991      J Gillespie, FGS
|                  Assert the GS naming convention throughout the file
|                  Add usage notes
|              2-Apr-1991      S McAdoo, GQS
|                  change enum with extension union constructs
|              8-Apr-1991      S McAdoo, GQS
|                  work on seismic header constructs
|             16-Apr-1991      J Gillespie, FGS
|                  'Better' normalization of cdp,sp,trace#
|                  Add velocity functions at GSSeismicLineHdr_t level
|             19-Apr-1991      J Gillespie, FGS
|                  Rearrange GSSurfaceSetIntersection logic
|                  (Per memo from H Ganem 8 April 1991)
|             23-Apr-1991      J Gillespie, FGS
|                              O Osawa, IDS Schlumberger
|                  Add cross section description to GSField_t
|             24-Apr-1991      J Gillespie, FGS
|                              S McAdoo, GQS
|                              R Veazey, GQS
|                  Address relationship between map location, seismic shot point,
|                  receiver, cdp (cmp)
|                  Strip out derivable amplitude statistics
|                  First attempt at merging geologic, geophysical sections
|             7-May-1991       J Gillespie, FGS
|                              O Osawa, IDS Schlumberger
|                  Add more units to resolve some ambiguities
|                  Made value in GSZoneValue_t a measurement instead of a string
|                  Added reshot logic to line-level shot points (still need to
|                      consider adding reshot character to GSShotPoint_t)
|     0.9     14-May-1991      J Gillespie, FGS
|                  Add GSLegalLoc_t, GSLandNet_t structures to describe land net
|                  Change GSLegal_t definition (well_hdr.tophole and
|                  well_hdr.bottomhole are now of type GSLegalLoc_t)
|     0.91    15-May-1991      J Gillespie, FGS Schlumberger
|                              O Osawa, IDS Schlumberger
|                              S McAdoo, GQS
|                              O Lindtjorn, GECO Schlumberger
|                  Rectify GSV omissions, missspellings in last delta
|                  Change mixed case structure element names to be lower case
|                  Add operation vector to GSDataSupported_t
|                  Added GSXYZOffset_t, GSLocation_t to model 'uncertainty' of location
|     1.00    20-May-1991      J Gillespie, FGS Schlumberger
|                  First 'official' release
|                  Moved documentation to geoscience.doc
|
+-----------------------------------------------------------------------------*/

/************************************************************************************/
/*                                                                                  */
/*                    Generally Used Typedefs                                       */
/*                                                                                  */
/************************************************************************************/

typedef long GSLongInt_t;           /* Long integer (usually 4 bytes) */
typedef float GSReal_t;             /* Single precision floating point */
typedef double GSDP_t;              /* Double precision floating point */
typedef unsigned long int GSUlong_t;    /* Unsigned long integer */
typedef long GSBoolean_t;
typedef char *GSVoidptr_t;
typedef long GSMask_t;              /* Bit mask, used to identify item validity in
                                       structures */

typedef struct                      /* structure for a rational number */
    {
    GSLongInt_t num;
    GSUlong_t den;
    } GSRational_t;

/************************************************************************************/
/*                                                                                  */
/*                    The Basic Building Block, the GSVector_t                      */
/*                                                                                  */
/************************************************************************************/

/* Basic to the interchange design is that of a vector structure which is
  specified by the following declarations: */

typedef enum 
    {
    GSV_UNKNOWN = 0,                /* vector type is unknown, check extension */
    /* basic data types */
    GSV_INT = 110,                  /* vector type GSLongInt_t */
    GSV_REAL = 111,                 /* vector type GSReal_t */
    GSV_DP = 112,                   /* vector type GSDP_t */
    GSV_FRAC8 = 113,                /* vector type 8 bit int fraction */
    GSV_FRAC16 = 114,               /* vector type 16 bit int fraction */
    GSV_UNSIGNED_LONG = 115,        /* vector type GSUlong_t */
    GSV_BOOLEAN = 116,              /* vector type GSBoolean_t */
    GSV_RATIONAL = 117,             /* vector type GSRational_t */
    GSV_CHAR = 118,                 /* vector type char */
    GSV_COMPLEX = 119,              /* vector type complex */
    GSV_STRING = 120,               /* vector type GSString_t */
    /* executive structure vectors */
    GSV_RECEIVER_RQMTS = 200,       /* vector type GSReceiverRqmts_t */
    GSV_DATA_SUPPORTED = 201,       /* vector type GSDataSupported_t */
    GSV_GSSTRUCTURE = 202,          /* vector type GSStructure_t */
    GSV_RECEIVER_CONTEXT = 203,     /* vector type GSReceiverContext_t */
    GSV_STATUS_RETURN = 204,        /* vector type GSStatusReturn_t */
    /* basic point structures */
    GSV_XYZ_POINT = 1000,           /* vector type GSXYZPoint_t */
    GSV_SEISMIC_DATA_POINT = 1001,  /* vector type GSSeismicDataPoint_t */
    GSV_MAP_LOCATION = 1002,        /* vector type GSMapLocation_t */
    GSV_DEPTH = 1003,               /* vector type GSDepth_t */
    GSV_PROCESSING_HISTORY = 1004,  /* vector type GSProcessingHistory_t; */
    GSV_NODE_ID = 1005,             /* vector type GSNodeID_t */
    /* stratigraphic data structures */
    GSV_STRAT_COLUMN = 2000,        /* vector type GSStratigraphicColumn_t */
    GSV_LITHOSTRAT_CODE_DESC = 2001,    /* vector type GSLithostratCodeDesc_t */
    /* zone structures */
    GSV_ZONE_VARIABLE_DEF = 3000,   /* vector type GSZoneVariableDefinition_t */
    GSV_ZONE_DEF = 3001,            /* vector type GSZoneDefinition_t */
    GSV_ZONE_VALUE = 3002,          /* vector type GSZoneValue_t */
    /* well structures */
    GSV_WELL_REMARKS = 4001,        /* vector type GSWellRemarks_t */
    GSV_WELL_TUBULARS = 4002,       /* vector type GSWellTubulars_t */
    GSV_WELL_PRODUCTION = 4003,     /* vector type GSWellProduction_t */
    GSV_WELL_MARKER = 4004,         /* vector type GSWellMarker_t */
    GSV_WELL_CORE = 4005,           /* vector type GSWellCore_t */
    GSV_WELL_HDR = 4006,            /* vector type GSWellHdr_t */
    GSV_WELL_TEST_HDR = 4007,       /* vector type GSWellTestHdr_t */
    GSV_SEISMIC_WELL_TIE = 4008,    /* vector type GSSeismicWellTie_t */
    /* well log structures */
    GSV_LOG_RUN = 5000,             /* vector type GSLogRun_t */
    GSV_LOG_PASS = 5001,            /* vector type GSLogPass_t */
    GSV_LOG_SERVICE = 5002,         /* vector type GSLogService_t */
    GSV_LOG_TRACE = 5003,           /* vector type GSLogTrace_t */
    /* seismic data structures */
    GSV_SEISMIC_TRACE = 6000,       /* vector type GSSeismicTrace_t */
    GSV_SEISMIC_CLASS = 6001,       /* vector type GSSeismicClass_t */
    GSV_SEISMIC_LINE = 6002,        /* vector type GSSeismicLine_t */
    GSV_SEISMIC_LOC_INFO = 6003,    /* vector type GSSeismicLocInfo_t */
    GSV_SEISMIC_SHOT_POINT_LOC = 6004,  /* vector type GSSeismicShotPointLoc_t */
    GSV_SHOT_POINT = 6005,          /* vector type GSShotPoint_t */
    GSV_SHOT_POINT_SEGMENT = 6006,  /* vector type GSShotPointSegment_t */
    GSV_SEISMIC_VELOCITY = 6007,    /* vector type GSSeismicVelocity_t */
    GSV_VELOCITY_PAIR = 6008,       /* vector type GSVelocityPair_t */
    /* map object structures */
    GSV_MAP_POLYLINE = 7000,        /* vector type GSMapPolyline_t */
    GSV_MAP_POINT = 7001,           /* vector type GSMapPoint_t */
    GSV_MAP_SYMBOL = 7002,          /* vector type GSMapSymbol_t */
    GSV_MAP_ANNOTATION = 7003,      /* vector type GSMapAttribute_t */
    GSV_MAP_ATTRIBUTE = 7004,       /* vector type GSMapAnnotation_t */
    GSV_MAP_OBJECTS = 7005,         /* vector type GSMapObjects_t */
    GSV_ATTRIBUTE_ITEM = 7006,      /* vector type GSAttributeItem_t */
    GSV_LAND_NET = 7007,            /* vector type GSLandNet_t */
    /* seismic interpretation surface structures */
    GSV_CONTACT = 8000,             /* vector type GSContact_t */
    GSV_SEGMENT = 8001,             /* vector type GSSegment_t */
    /* fault trace structures */
    GSV_FAULT_TRACE = 9000,         /* vector type GSFaultTrace_t */
    GSV_FAULT_SURFACE = 9001,       /* vector type GSFaultSurface_t */
    /* surface executive structures */
    GSV_SURFACE_ATTRIBUTE = 10000,  /* vector type GSSurfaceAttribute_t */
    GSV_SURFACE_GEOMETRY = 10001,   /* vector type GSSurfaceGeometry_t */
    GSV_SURFACE_REPRESENTATION = 10002, /* vector type GSSurfaceRepresentation_t */
    /* seismic interpretation surface structures */
    GSV_SEISMIC_LINE_INTERSECTION = 11000,  /* vector type GSSeismicLineIntersection_t */
    GSV_SURFACE_SURFACE_INTERSECTION = 11001,   /* vector type GSSurfaceSurfaceIntersection_t */
    GSV_SURFACE_TRACE = 11002,      /* vector type GSSurfaceTrace_t */
    /* section structures */
    GSV_GEOL_CROSS_SECTION = 12000, /* vector type GSGeolCrossSection_t */
    GSV_SECTION_INTERSECTION = 12001/* vector type GSSectionIntersection_t */
    } GSVectorType_t;

typedef struct 
    {
    GSVectorType_t element_format;
    GSLongInt_t extension;
    GSUlong_t element_size;
    GSUlong_t number_elements;
    GSVoidptr_t vector_pointer;
    } GSVector_t;

/*  ALL strings will be stored as vectors,  the typedef GSString_t is defined as a
    convenience and a vector type differentiater */

typedef GSVector_t GSString_t;

typedef GSString_t GSDate_t;        /* Standard date format is YYYYMMDDHHMNNSS.SS
                                       YYYY from 0000 to 9999 (year)
                                       MM from 01 to 12 (month of year)
                                       DD from 01 to 31 (day of month)
                                       HH from 00 to 23 (hour of day)
                                       MN from 00 to 59 (minute of hour)
                                       SS.SS from 0 to 59.99 (seconds in minute)
                                       Any component may be truncated
                                       (e.g.April 1987 is entered as 198704) */

/************************************************************************************/
/*                                                                                  */
/*                           NULL VALUES STRUCTURE                                  */
/*                                                                                  */
/************************************************************************************/

typedef struct 
    {
    GSDP_t v_dp;                    /* double precision floating point null value */
    GSReal_t v_real;                /* single precision floating point null value */
    GSRational_t v_rational;        /* rational number null value */
    GSLongInt_t v_longint;          /* long integer null value */
    GSUlong_t v_ulong;              /* Unsigned long integer null value */
    } GSNullValue_t;

/************************************************************************************/
/*                                                                                  */
/*                    Data Structure Typedefs                                       */
/*                                                                                  */
/************************************************************************************/

typedef GSLongInt_t GSNodeID_t;     /* node identifier */
typedef GSString_t GSPlotSymbol_t;  /* Graphics plot symbol name */
typedef GSString_t GSUWI_t;         /* Unique Well Identifier */

typedef GSString_t GSSurfaceSetName_t;  /* Name of a surface set */
typedef GSString_t GSSeismicSurveyName_t;   /* name of a seismic survey */
typedef GSString_t GSSeismicLineName_t; /* name of a seismic line in a survey */

/* 
 *       Geophysical data types 
 */

typedef GSRational_t GSShotPoint_t; /* Seismic shot point */
typedef GSRational_t GSCDP_t;       /* Common depth point */
typedef GSRational_t GSLineNumber_t;    /* Seismic line number */
typedef GSReal_t GSStatic_t;        /* Seismic static correction value */

/*
 *       symbols identifying types of interpreted surfaces
 */

typedef enum 
    {
    GS_SRF_TYPE_UNKNOWN = 0,        /* surface type unknown */
    GS_SRF_TYPE_HOR = 1,            /* surface type 'horizon' (lithologic or seismic) */
    GS_SRF_TYPE_FLT = 2             /* surface type 'fault' (or other discontinuity) */
    } GSSurfaceType_t;

typedef enum                        /* z value code */
    {
    GS_Z_VALUE_UNDEFINED = 0,       /* no z value is defined */
    GS_Z_VALUE_TIME = 1,            /* z value is time */
    GS_Z_VALUE_UNSNAPPED_TIME = 2,  /* z value is unsnapped time */
    GS_Z_VALUE_AMPLITUDE = 3,       /* z value is amplitude */
    GS_Z_VALUE_DEPTH = 4            /* z value is depth */
    } GSZValueCode_t;

typedef enum 
    {
    GS_SNAP_P_NEAR = 1,             /* nearest peak to center of window */
    GS_SNAP_P_MAX = 2,              /* largest peak in window           */
    GS_SNAP_T_NEAR = 3,             /* nearest trough to center of window */
    GS_SNAP_T_MAX = 4,              /* largest trough in window         */
    GS_SNAP_ZPN = 5,                /* zero crossing, positive to negative*/
    GS_SNAP_ZNP = 6,                /* zero crossing, negative to positive*/
    GS_SNAP_NULL = 7,               /* snap to input point */
    GS_SNAP_UNDEFINED = 8           /* undefined snap type */
    } GSSnapEvent_t;
/* 
 *      Seismic Line type 
 */

typedef enum 
    {
    GS_LINE_2D = 30,                /* line type 2d */
    GS_LINE_3DI = 31,               /* line type 3d inline */
    GS_LINE_XLN = 32,               /* line type 3d cross line */
    GS_LINE_RANDOM = 33             /* line type 3d random (reconstruction) cut */
    } GSLineType_t;

/*    
 *       Processing History structure           
 */
typedef struct 
    {
    GSDate_t proc_date;
    GSString_t vendor;
    GSString_t description;
    } GSProcessingHistory_t;

/*
 *       variable for flagging whether a polyline is open or closed (a polygon)
 */

typedef enum 
    {
    GS_OPEN_POLYLINE = 0,
    GS_CLOSED_POLYGON = 1
    } GSPolylineType_t;

/*
 *       compass points (more added by concatenating digits, e.g. NNE = 112)
 */

typedef enum 
    {
    GS_NORTH = 1,
    GS_NORTHEAST = 12,
    GS_EAST = 2,
    GS_SOUTHEAST = 42,
    GS_SOUTH = 4,
    GS_SOUTHWEST = 48,
    GS_WEST = 8,
    GS_NORTHWEST = 18
    } GSCompassPoint_t;             /* enum for compass points */

/************************************************************************************/
/*                                                                                  */
/*                   MEASUREMENT TYPEDEFS                                           */
/*                                                                                  */
/************************************************************************************/

/* 
 *    Units of measure
 */

typedef struct 
    {
    GSString_t type;                /* DISTANCE, TIME, MASS, TEMPERATURE, etc */
    GSString_t unit;                /* Unit (ft, s) or expression (g/cm3) */
    } GSUnit_t;                     /* NOTE: see geoscience.doc for list of units */

typedef struct 
    {
    GSDP_t value;                   /* value of measurement */
    GSUnit_t uom;                   /* unit of measure, including the
                                       measurement system and the actual unit */
    } GSMeasurement_t;

/* The following are special cases of GSMeasurement_t as noted */
typedef GSMeasurement_t GSTemperature_t;    /* uom.type = "TEMPERATURE" */
typedef GSMeasurement_t GSResistivity_t;    /* uom.type = "RESISTIVITY" */
typedef GSMeasurement_t GSTime_t;   /* uom.type = "TIME" */
typedef GSMeasurement_t GSVelocity_t;   /* uom.type = "VELOCITY" */
typedef GSMeasurement_t GSMass_t;   /* uom.type = "MASS" */
typedef GSMeasurement_t GSDistance_t;   /* uom.type = "DISTANCE"\and implication
                                           that measurement is made in horizontal sense */
typedef GSMeasurement_t GSElevation_t;  /* uom.type = "DISTANCE" and implication
                                           that measurement is made in vertical sense */

typedef struct 
    {                               /* structure describing reference elevation */
    GSElevation_t val;              /* Elevation to use for subsea corrections */
    GSString_t ref;                 /* Data type being used as elevation reference
                                       (KB, DF, GS, SL, etc) */
    } GSElevationRef_t;

/************************************************************************************/
/*                                                                                  */
/*                   MASKS DEFINING VALIDITY OF ITEMS                               */
/*                                                                                  */
/************************************************************************************/

/* Used in point structures */
#define GSM_VALID_CDP          (1<<0)   /* cdp number is valid */
#define GSM_VALID_SP           (1<<1)   /* shot point number is valid */
#define GSM_VALID_X            (1<<2)   /* x location is valid */
#define GSM_VALID_Y            (1<<3)   /* y location is valid */
#define GSM_VALID_Z            (1<<4)   /* z location is valid */
#define GSM_VALID_LONGITUDE    (1<<5)   /* longitude is valid */
#define GSM_VALID_LATITUDE     (1<<6)   /* latitude is valid */
#define GSM_VALID_CONNECT      (1<<7)   /* connectivity vector in xyz scatter data */
#define GSM_VALID_NODE         (1<<8)   /* node identifier is valid */

/* Used in GSDepth_t structure */
#define GSM_VALID_MD           (1<<9)   /* measured depth is valid */
#define GSM_VALID_SUBDATUM     (1<<10)  /* subdatum depth is valid */
#define GSM_VALID_TVD          (1<<11)  /* true vertical depth is valid */
#define GSM_VALID_TIME         (1<<12)  /* time is valid */
#define GSM_VALID_DX           (1<<13)  /* deviation in x direction is valid */
#define GSM_VALID_DY           (1<<14)  /* deviation in y direction is valid */

/* Used in GSSeismicLocInfo_t structure */
#define GSM_VALID_DATUM        (1<<15)  /* subdatum depth is valid */
#define GSM_VALID_WDEPTH       (1<<16)  /* weathering depth is valid */
#define GSM_VALID_WVEL         (1<<17)  /* weathering velocity is valid */
#define GSM_VALID_WSTATIC      (1<<18)  /* weathering static is valid */
#define GSM_VALID_DSTATIC      (1<<19)  /* datum static is valid */
#define GSM_VALID_ASTATIC      (1<<20)  /* automatic static is valid */

/************************************************************************************/
/*                                                                                  */
/*                   POINT STRUCTURES                                               */
/*                                                                                  */
/************************************************************************************/

/*  Other structures are basic to data interchange, that of a single point. 
    The following is the structure for a single point.  A mask will be provided in
    association with each use of this structure (or vector of this structure)
    indicating which components of the structure are valid.  For example, x and y
    may not be necessary to transfer interpretation.  Further the exact meaning of
    the elements of this structure will be context dependent (i. e., the z element
    may contain a time value for interpretation). */

typedef struct 
    {
    GSMask_t valid;                 /* Validity mask for XYZpoint:
                                      GSM_VALID_X, GSM_VALID_Y, GSM_VALID_Z */
    GSDP_t x;                       /* x coordinate value associated with point */
    GSDP_t y;                       /* y coordinate value associated with point */
    GSDP_t z;                       /* z coordinate value associated with point */
    } GSXYZPoint_t;

typedef struct 
    {
    GSNodeID_t node_id;             /* Node id */
    GSMask_t valid;                 /* Validity mask for map location:
                                      GSM_VALID_LONGITUDE, GSM_VALID_LATITUDE */
    GSDP_t longitude;               /* Longitude of map location, in decimal degrees */
    GSDP_t latitude;                /* Latitude of map location, in decimal degrees */
    GSXYZPoint_t coord;             /* cartesian coordinates associated
                                       with map location */
    } GSMapLocation_t;

typedef struct 
    {
    GSMask_t valid;                 /* Validity mask for offset:
                                      GSM_VALID_X, GSM_VALID_Y, GSM_VALID_Z */
    enum 
        {
        GS_OFFSET_ABSOLUTE,         /* offset is an absolute offset from map location */
        GS_OFFSET_UNCERTAINTY       /* offset is an uncertainty window around map location */
        } offset_type;
    /* all offsets are in the projection coordinate system */
    GSDP_t x;                       /* x offset/window associated with point */
    GSDP_t y;                       /* y offset/window associated with point */
    GSDP_t z;                       /* z offset/window associated with point */
    } GSXYZOffset_t;

typedef struct 
    {
    GSNodeID_t node_id;             /* Node id */
    GSXYZOffset_t offset;           /* offset from node's map location */
    } GSLocation_t;

typedef struct 
    {
    GSNodeID_t node_id;             /* Map location identifier */
    GSMask_t valid;                 /* Validity mask for station vector:
                                        GSM_VALID_CDP, GSM_VALID_SP */
    GSCDP_t cdp;                    /* common depth point number */
    union 
        {
        GSShotPoint_t shot_point;   /* Shot Point Number associated with point (usually 2d) */
        GSLineNumber_t line_number; /* seismic line number (Used for time slices
                                       and random sections) */
        } y;
    } GSSeismicDataPoint_t;

typedef struct 
    {
    GSNodeID_t node_id;             /* Map location identifier */
    GSShotPoint_t shot_point;       /* Shot Point Number associated with point (usually 2d) */
    GSXYZOffset_t offset;           /* Offset/uncertainty of seismic location */
    } GSSeismicShotPointLoc_t;

typedef struct 
    {
    GSString_t reshoot;             /* reshoot segment identifier - normally null
                                      (when used, usually single character) */
    GSVector_t seismic_shot_point_loc;
    } GSSeismicShotPointSegment_t;

/*    Shot/receiver/cdp information table
      ----------------------------------- */

typedef struct                      /* for shot/receiver/cdp */
    {
    GSNodeID_t node_id;             /* Map location identifier */
    GSMask_t valid;                 /* Validity mask for qualifiers */
    GSElevation_t datum;            /* elevation datum (used only if this line has a
                                       floating datum) */
    GSElevation_t wdepth;           /* depth of weathering layer */
    GSVelocity_t wvel;              /* velocity of weathering layer */
    GSStatic_t wstatic;             /* weathering static */
    GSStatic_t dstatic;             /* datum static */
    GSStatic_t astatic;             /* automatic static */
    } GSSeismicLocInfo_t;

typedef struct 
    {
    GSDP_t xmin;
    GSDP_t ymin;
    GSDP_t zmin;
    
    GSDP_t xmax;
    GSDP_t ymax;
    GSDP_t zmax;
    } GSExtents_t;

/************************************************************************************/
/*                                                                                  */
/*                   Projection & Spheroid Information Structures                   */
/*                                                                                  */
/************************************************************************************/

/*   Projection Information
      ----------------------
 
We will assume all location information contained within a data
structure is given in the same coordinate system.  To properly define the
coordinate system the following structure is used to specify the
projection.  The structures and projection codes are based on the public domain
projection package from the United States Geological Survey (USGS).
(see geoscience.doc for a list of valid parameters) */

/************************************************************************/

#define GS_NO_OF_PROJECTIONS (GSLongInt_t)21
#define GS_NO_OF_SPHEROIDS   (GSLongInt_t)20
#define GS_NO_OF_UNITS       (GSLongInt_t)5

typedef struct 
    {                               /* Projection Structure Type */
    GSDP_t parms[15];               /* Transformation Parameters */
    GSLongInt_t projection_type;    /* USGS(or equiv) Projection Type Code */
    GSLongInt_t projection_unit;    /* UOM for Projection. NOTE: NOT used in other
                                     uom character string structures... */
    GSLongInt_t zone_code;          /* UTM or US State Plane Zone */
    GSLongInt_t spheroid_code;      /* USGS (or equiv) Spheroid Code */
    GSString_t proj_name;           /* Projection Name (description) */
    } GSCartoProjection_t;

/************************************************************************************/
/*                                                                                  */
/*                     Surface Geometry Representations                             */
/*                                                                                  */
/************************************************************************************/

/*    xyz scatter Information
      -----------------------
 */

typedef struct 
    {
    GSSurfaceSetName_t surface_set_name;    /* Surface set name */
    GSString_t attribute;           /* name of the attribute being modelled */
    GSUnit_t z_unit;
    
    GSVector_t x;                   /* Vector of x-coordinate values 
                                     (4 or 8 byte floats) */
    GSVector_t y;                   /* Vector of y-coordinate values 
                                     (4 or 8 byte floats) */
    GSVector_t z;                   /* Vector of z-values (4 or 8 byte floats) */
    
    GSMask_t connect_valid;
    GSVector_t connect;             /* Connectivity vector.  If sequences
                                     of data points are intended to be
                                     connected together, then this vector
                                     will be filled.  Normally, this would
                                     take the form of one 'connect' value
                                     for each x,y,z value and would
                                     consist of sequential integer values.
                                     All points intended to be grouped
                                     together would have the same
                                     'connect' value. '0' would indicate a
                                     scatter point not connected to any
                                     other point.  This vector need not be
                                     filled for no connected data values.
                                     (4 byte integer) */
    } GSXYZData_t;

/*    Grid Information
      ----------------
 */
typedef struct 
    {
    /* Basic grid parameters:
    xmin, ymin, xmax, ymax, row-grid distance, col-grid distance
    Note: range values in order min-to-max.  Positive row increment
    for non-rotated grid assumed to increase in positive y-direction.
    Positive column increment for non- rotated grid assumed to increase in
    positive x-direction.  Varying the sign of the row,col increments is the
    mechanism for systems utilizing some corner of the grid other than the
    lower left corner as the grid origin. */
    
    GSSurfaceSetName_t surface_set_name;    /* Surface set name */
    GSString_t attribute;           /* name of the attribute being modelled */
    GSUnit_t z_unit;
    
    GSDistance_t row_distance;      /* distance between rows */
    GSDistance_t col_distance;      /* distance between columns */
    
    GSReal_t angle;                 /* Grid rotation angle measured from the
                                     horizontal.  Angles are in degrees
                                     and open positively in the counter
                                     clockwise direction. */
    GSLongInt_t nrows;              /* Number of rows in the grid. */
    GSLongInt_t ncols;              /* Number of columns in the grid. */
    GSBoolean_t fl_honored;         /* Faults honored during gridding flag.
                                     FALSE: Fault information not used.
                                     TRUE: Fault information was used. */
    GSVector_t fault_surface;       /* Vector of structures of surfaces
                                       having fault traces defined */
    GSVector_t zvals;               /* Grid values: Storage order is row 1
                                     to row 'nrows' of column 1 followed
                                     by the row values of columns 2
                                     through column 'ncols'
                                     element_format = GSV_REAL;
                                     element_size = either sizeof (GSReal_t)
                                     or sizeof (GSDP_t) */
    
    GSMask_t valid;                 /* Validity mask for existence of xvals
                                     and yvals that follow (GSM_VALID_X
                                     or GSM_VALID_Y) */
    /* For the following two vectors, element_format = GSV_REAL;
       element_size = either sizeof (GSReal_t) or sizeof (GSDP_t) */
    GSVector_t xvals;               /* x-values corresponding to z-values */
    GSVector_t yvals;               /* y-values corresponding to z-values */
    } GSGrid_t;

/*    Contour Information
      -------------------
 */

typedef struct 
    {
    GSSurfaceSetName_t surface_set_name;    /* Surface set name */
    GSString_t attribute;           /* name of the attribute being modelled */
    GSUnit_t z_unit;
    GSVector_t fault_surface;       /* Vector of structures of surfaces
                                       having fault traces defined that were used
                                       to generate this contoured surface set */
    GSLongInt_t inc_type;           /* Type contour incrementing used.
                                     0: User specified contour range 
                                    defined by low contour value, 
                                    high contour value and contour
                                    increment.
                                     n: n-contour values specified
                                    explicitly by value. */
    GSVector_t inc_levels;          /* Vector of user specified contour
                                     levels.  The number of levels does not
                                     necessarily match the actual z values
                                     See 'inc_type' above. (4 or 8 byte float) */
    
    GSVector_t z_vals;              /* Z-values for each contour segment
                                     stored.  The number of Z values matches
                                     the number of segments described
                                     in the endpts vector.  The number of Z values 
                                     does not necessarily match the
                                     number of levels described in inc_levels
                                     (4 or 8 byte float) */
    GSVector_t endpts;              /* Vector of zero-based indices in x,y-coordinate
                                     arrays where each contour segment
                                     terminates.  Each value stored in
                                     'endpts' is associated with the
                                     corresponding contour level stored
                                     in 'z_vals'.  (4 byte integer) */
    GSVector_t x;                   /* Vector of contour x-coordinate
                                     values. (4 or 8 byte floats) */
    GSVector_t y;                   /* Vector of contour y-coordinate
                                     values. (4 or 8 byte floats) */
    } GSContour_t;

/************************************************************************************/
/*                                                                                  */
/*            Seismic Geometry Specification and Location Structures                */
/*                                                                                  */
/************************************************************************************/

/*    3-D Survey Geometry Specification and Location
      ----------------------------------------------
 
The following structure contains the information necessary to specify a 3d
survey.  If the survey does not exist in the receiving system all of the
information must be provided.  The survey is assumed to be laid out as a
regular orthogonal grid of traces so that knowing the location of one trace,
the trace and line spacing, and the azimuth of the primary lines one can
compute the location of all of the traces. */

typedef struct 
    {
    /*    the following are survey geometry specifications */
    GSGrid_t grid;
    /* grid defines the geometry representation of the 3d survey,
    including the ground distance and the number of values in X and Y.
    Usually the X and Y vectors of the GSGrid_t are not used. */
    GSLineNumber_t lin1;            /* line # of origin inline line (rational) */
    GSLineNumber_t lininc;          /* line number incr (rational) */
    GSLongInt_t number_inlines;     /* number of inlines in survey */
    GSCDP_t cdp1;                   /* origin cdp on inline lines.(rational) */
    GSCDP_t cdpinc;                 /* cdp incr. on inline lines (rational) */
    GSLongInt_t number_cdps;        /* number of cdps in each inline */
    GSShotPoint_t sp1;              /* sp of survey origin (rational) */
    GSShotPoint_t spinc;            /* sp incr. of survey  (rational) */
    
    /*    the following are coordinates with which to locate the survey */
    /* Enter in a clockwise sense; DO NOT assume grid is orthonormal
 (the map_coord node identifiers should correspond to the node identifiers
 in the local_coord array) */
    GSSeismicDataPoint_t local_coord[4];
    GSMapLocation_t map_coord[4];
    } GSSeismicLocation3D_t;

/************************************************************************************/
/*                                                                                  */
/*            Seismic Survey Structures                                             */
/*                                                                                  */
/************************************************************************************/

/*    Seismic Data Structures
      -----------------------
 
Seismic data will be contained in the interchange structure as a seismic line
header structure and a vector of trace structures.  The trace structure
contains a trace header structure and a vector of sample values. */

/*    Processed Seismic Line Header
      ----------------------------- */
typedef struct 
    {
    enum 
        {
        GS_NO_MIGRATION = 0,
        GS_PRESTACK_MIGRATION = 1,
        GS_POSTSTACK_MIGRATION = 2
        } migration_type;
    
    enum 
        {
        GS_TRACE_ORDER_SHOT = 1,    /* shot ordered */
        GS_TRACE_ORDER_CDP = 2,     /* unstacked cdps */
        GS_TRACE_ORDER_STACK = 3,   /* stacked cdps */
        GS_TRACE_ORDER_SEQ = 4      /* trace sequential */
        } trace_order;              /* Trace ordering */
    
    GSBoolean_t offset_validity;    /* TRUE = offsets are valid */
    
    GSDistance_t trail_offset;      /* trailing trace offset */
    GSDistance_t lead_offset;       /* leading trace offset */
    GSDistance_t near_offset;       /* ABS near trace offset */
    GSDistance_t far_offset;        /* ABS far trace offset */
    
    GSReal_t sample_interval;       /* sampling rate */
    GSLongInt_t n_samples;          /* maximum number of samples per trace */
    
    GSLongInt_t n_channels;         /* number of channels per record  (1) */
    GSLongInt_t n_fold;             /* stack fold (no. of traces per cdp) */
    
    GSShotPoint_t min_shotpoint;    /* minimum shotpoint */
    GSShotPoint_t max_shotpoint;    /* maximum shotpoint */
    GSRational_t min_receiver;      /* minimum receiver location */
    GSRational_t max_receiver;      /* maximum receiver location */
    GSCDP_t min_cdp;                /* minimum cdp */
    GSCDP_t max_cdp;                /* maximum cdp */
    
    GSRational_t cdp_incr;          /* cdp number increment per trace (zero if invalid) */
    GSRational_t shotpoint_incr;    /* shotpoint increment per trace (zero if invalid) */
    
    } GSSeismicLineHdr_t;


/*    Velocity structures
      -------------------- */
typedef struct 
    {
    GSReal_t z;                     /* time or depth */
    GSReal_t value;                 /* velocity measurement at this time or depth */
    } GSVelocityPair_t;

typedef struct 
    {
    enum 
        {
        GS_STACKING_VELOCITY = 1,
        GS_AVERAGE_VELOCITY = 2,
        GS_PSEUDO_VELOCITY = 3,
        GS_INTERVAL_VELOCITY = 4
        } velocity_type;
    GSUnit_t z_unit;
    GSUnit_t value_unit;
    GSVector_t velocity_pair;       /* List of time/velocity or depth/velocity pairs */
    } GSSeismicVelocity_t;

/*    Trace (including header)
      ------------------------ */

typedef struct 
    {
    /**** trace header ****/
    enum 
        {
        GS_DEAD_TRACE = -1,
        GS_LIVE_TRACE = 1,
        GS_SWEEP_TRACE = 2,
        GS_NULL_TRACE = 3
        } trace_type;               /* activity of trace (live, dead, etc) */
    
    GSLongInt_t record_no;          /* sequential record number */
    GSLongInt_t record_trace_no;    /* record trace number */
    GSLongInt_t field_record_no;    /* field record number */
    GSLongInt_t field_record_trace_no;
    
    GSCDP_t cdp;                    /* common midpoint number (cmp) */
    GSLongInt_t trace_no;           /* trace number corresponding to this cdp */
    GSShotPoint_t shot_point;       /* shotpoint corresponding to this cdp */
    GSShotPoint_t receiver;         /* receiver corresponding to this cdp */
    GSLongInt_t fold;               /* stacking fold at this cdp */
    GSNodeID_t node_id;             /* reference to the cdp location */
    
    GSLongInt_t mute_length;        /* length of initial mute is samples */
    GSReal_t tfs;                   /* time of first sample in sample units */
    GSStatic_t bulk_static;         /* bulk static */
    GSStatic_t trim_static;         /* non-surface consistent automatic static */
    
    GSReal_t minimum_scalar;        /* scalar values used in scaling data to */
    GSReal_t maximum_scalar;        /* fraction values */
    
    GSVector_t seismic_velocity;    /* vector of seismic velocity functions */
    
    /**** trace samples ****/
    
    GSVector_t samples;             /* Vector of seismic trace samples
                                     (see vector descriptor for sample format) -
                                    (Note: no corresponding GSSamples_t exists) */
    } GSSeismicTrace_t;

/*    Line Description Structure
      --------------------------
                                                                                                                                                 
All surveys are organized as a series of lines and the survey structure
includes a vector of line structures of the following form.  Each line may have
several variants usually depending on any processes which have been applied to
the data to alter its presentation or to extract some quality of interest. 
Therefore the line structure contains location information and a vector of
classes.  There may be many types of data related to a line class.  Each type 
will have a structure (or vector of structures) in which that type of data 
is stored.  Included in the current proposal is a vector of interpreted 
surfaces and seismic trace data. */

typedef struct 
    {
    GSLineType_t line_type;         /* Seismic Line type */
    GSSeismicLineName_t line_name;  /* 2d or reconstruction cut line name */
    GSLongInt_t line_number;        /* Line number (required for GS_LINE_3DI, GS_LINE_XLN) */
    GSString_t line_desc;           /* Line description */
    GSVector_t map_location;        /* array of map locations referred to in this line */
    GSVector_t seismic_loc_info;    /* array of datae, weathering info and statics */
    GSVector_t seismic_shot_point_segment;  /* array  of GSSeismicShotPointSegment_t */
    GSVector_t seismic_receiver;    /* array  of GSSeismicShotPointSegment_t
                                       GS_LINE_2D, GS_LINE_RANDOM types only */
    GSVector_t seismic_class;       /* Vector of seismic line variants delineated
                                       according to class */
    } GSSeismicLine_t;

/*    GSSeismicClass_t structure                
      -------------------------- */

typedef struct 
    {
    GSString_t class_name;          /* User assigned class name (e.g. migrated, pre-stack) */
    GSString_t class_desc;          /* Class description */
    GSUnit_t z_unit;                /* unit of measure for time/depth */
    GSSeismicLineHdr_t seismic_line_hdr;    /* Structure containing seismic line header */
    GSVector_t seismic_trace;       /* Vector of GSSeismicTrace_t */
    GSVector_t seismic_line_intersection;   /* Vector of GSSeismicLineIntersection_t */
    GSVector_t processing_history;  /* Seismic trace file processing history */
    } GSSeismicClass_t;

/************************************************************************************/
/*                                                                                  */
/*                          SEISMIC SURFACE STRUCTURES                              */
/*                                                                                  */
/************************************************************************************/

/*    
It will be assumed that there are two basic types of surfaces, horizons and
faults (or fault cuts).  Along any line there may be line segments indicating
where the surface has been interpreted and there may be information indicating
where two surfaces contact each other.  Additionally, the segments may have
different data depending on the z value contained therein.  For example, the
user may have interpreted a horizon along a range of cdps and saved the time
values at which the horizon occurred.  He may have also saved the seismic trace
amplitude at that time.  Segments containing both time and containing amplitude
may be stored for a given surface. */

/*    Section Intersection
      --------------------
      Note: this object describes the intersection between one
            surface set and one segmented traverse section

*/

typedef struct 
    {
    GSSurfaceSetName_t surface_set_name;    /* Surface Set Name */
    GSSurfaceType_t surface_type;   /* Surface type:
                                       GS_SURF_TYPE_HOR or GS_SURF_TYPE_FLT */
    GSString_t surface_desc;        /* Surface description */
    GSString_t source;              /* Name of interpreter or source of data */
    GSDate_t modified_date;         /* date this surface was last modified */
    GSUnit_t x_unit;                /* Unit for x measurements along section */
    GSUnit_t z_unit;                /* Unit for z_value */
    GSVector_t x_value;             /* X distance of each point from the first
                                       point of the section along the section line
                                       (GSReal_t) */
    GSVector_t z_value;             /* depth value of each point (GSReal_t) */
    GSVector_t connect;             /* Connectivity vector; the same sense
                                       as used in GSXYZData_t
                                       (4 byte integer) */
    GSVector_t up_zone_number;      /* Zone sequential number (0,1, 2, ...) of
                                       the zone above each point.  The number
                                       is in the order of the appearance in
                                       zone_name field in GSGeolCrossSection_t
                                       (4 byte integer) */
    GSVector_t down_zone_number;    /* Zone sequential number of the zone
                                       below each point (see above) */
    } GSSectionIntersection_t;

/*  This structure contains information specifying points along the surface at
    which the user has indicated that it intersects another surface.  The structure
    includes the location of the intersection and information about the
    intersecting structure. */

typedef struct 
    {
    GSSectionIntersection_t section_intersection;
    GSSeismicLineName_t line_name;  /* seismic line name */
    
    /* The following are applicable only to horizon surfaces */
    GSSnapEvent_t snap_event;
    GSReal_t snap_window;           /* Duration of snapping window in time units */
    GSVector_t segment;             /* Vector of interpretation segments for line */
    GSVector_t contact;             /* Vector of contact points associated with this
                                     surface on this line */
    } GSSeismicLineIntersection_t;

typedef struct 
    {
    GSSeismicDataPoint_t contact_loc;   /* location of contact point */
    GSZValueCode_t z_value_code;    /* nature of Z value in contact_loc */
    enum 
        {
        GS_FAULT_CONTACT,           /* contact is at a fault */
        GS_UNCONFORM_CONTACT,       /* one surface deposited on another depositional surface
                                       after erosional events */
        GS_NONCONFORM_CONTACT,      /* one surface deposited on 'basement'
                                       after extensive erosional events */
        GS_ANGULAR_CONTACT          /* one surface deposited on another
                                       after erosional and deformational events */
        } contact_type;             /* nature of contact */
    GSSurfaceType_t surface_type_2; /* Surface type: 
                                      GS_SRF_TYPE_HOR, GS_SRF_TYPE_FLT,
                                      GS_SRF_TYPE_UNKNOWN */
    GSSurfaceSetName_t name_2;      /* second name associated with contact */
    } GSContact_t;

typedef struct 
    {
    GSLongInt_t seg_id;             /* Number identifying segment */
    GSZValueCode_t z_value_code;
    GSVector_t seismic_data_point;  /* Vector of points in interpretation segment */
    } GSSegment_t;

/************************************************************************************/
/*                                                                                  */
/*                          FAULT TRACE STRUCTURES                                  */
/*                                                                                  */
/************************************************************************************/

/*    
Fault traces are interpreted information defining the map view of the
intersection of faults with a particular surface.  The interpretation is
usually done on a map and cannot be organized on a line by line basis or, for
that matter, on a survey basis.  Fault trace interpretation, therefore, must 
be kept in a structure separate from the survey structure described above and 
transmitted separately.  The following structures will be used to contain and
transmit fault trace information.  The top structure contains information
necessary to define the coordinate system of the data contained in the
structure and a vector of surface structures for which fault trace information
is transmitted. If both time and depth values are to be associated with a fault
trace, then the same trace should be sent twice - once with the z_unit set to the TIME
system, once for DEPTH */

/*  Each surface may have intersections with many faults.  The following 
    structure names a vector of fault traces for a specified surface. */

typedef struct 
    {
    GSSurfaceSetName_t surface_set_name;    /* Name of surface for which traces are
                                               defined */
    GSUnit_t z_unit;                /* Unit of measure of z dimension (null if not used) */
    GSVector_t fault_trace;         /* Vector of structures defining fault traces */
    } GSFaultSurface_t;

/*  The following fault trace structure specifies the name of the intersecting fault
    and names the vector containing the points associated with the intersection. */

typedef struct 
    {
    GSSurfaceSetName_t fault_name;  /* Name of fault whose intersection with the surface
                                       this trace describes */
    GSLongInt_t ft_seg_id;          /* segment id for fault trace for a given surface */
    GSPolylineType_t open_closed;
    GSVector_t map_location;        /* Vector of structures defining fault trace points */
    } GSFaultTrace_t;

/************************************************************************************/
/*                                                                                  */
/*                          SURFACE  STRUCTURES                                     */
/*                                                                                  */
/************************************************************************************/

typedef struct 
    {
    enum 
        {
        GS_REP_NONE,
        GS_REP_GRID,
        GS_REP_CONTOUR,
        GS_REP_CONSTANT,
        GS_REP_XYZ
        } type;
    union 
        {
        GSGrid_t grid;
        GSXYZData_t xyz;            /* 'Scatter' data file */
        GSMeasurement_t constant;
        GSContour_t contour;
        } data;
    } GSSurfaceRepresentation_t;

typedef struct 
    {
    GSString_t attribute;           /* name of the attribute being modelled */
    GSVector_t surface_representation;  /* list of attribute representations */
    } GSSurfaceAttribute_t;

typedef struct 
    {
    GSExtents_t extent;             /* XYZ spanning extent of data set */
    GSSurfaceRepresentation_t time_representation;  /* set of coordinates describing
                                                     the geometry of the surface in time */
    GSSurfaceRepresentation_t depth_representation; /* set of coordinates describing
                                                     the geometry of the surface in depth */
    GSVector_t surface_attribute;   /* List of attributes for this surface
                                       which correspond to, or are measured at;
                                       the geometry specified in either time or depth */
    } GSSurfaceGeometry_t;

/********************************************************************
   This structure describe the intersection between a surface set and 
   another surface set. It is a structure that simply copies the
   GSFaultTraceSet_t structure. It should be more general and cover also
   the faults
 ********************************************************************/

typedef struct 
    {
    GSZValueCode_t z_value_code;
    GSVector_t xyz_point;           /* Vector of structures defining surface trace points */
    } GSSurfaceTrace_t;

typedef struct 
    {
    GSSurfaceSetName_t surface_set_name;    /* Name of intersecting surface set (horizon or fault) */
    GSVector_t surface_trace;       /* Vector of structures defining traces */
    } GSSurfaceSurfaceIntersection_t;

typedef struct                      /* new object pointed from GSSurfaceSet_t */
    {
    GSSurfaceSetName_t surface_set_name;    /* name of the surface set intersected */
    GSUnit_t depth_unit;            /* depth unit type for all depth representations */
    GSUnit_t time_unit;             /* time unit for all time representations */
    GSVector_t seismic_line_intersection;   /* Vector of section interpretation */
    GSVector_t section_intersection;    /* Vector of cross section intersection */
    GSVector_t well_marker;         /* Vector of GSWellMarker_t */
    GSVector_t seismic_well_tie;    /* Vector of GSSeismicWellTie_t */
    GSVector_t surface_surface_intersection;    /* vector of surface surface intersections */
    } GSSurfaceIntersection_t;

/************************************************************************************/
/*                                                                                  */
/*                               MAP STRUCTURES                                     */
/*                                                                                  */
/************************************************************************************/

/*    Attribute Information For Map Objects
      -------------------------------------

Each map object defined in a mapping database can have associated
non-graphic attribute information.  This is simply a list of name-value
pairs which are carried along with the map object. */

typedef struct 
    {
    GSString_t item_name;           /* name of attribute */
    GSMeasurement_t item_value;     /* value and unit of measure of attribute */
    } GSAttributeItem_t;

/*    Data Source For Map Data
      ------------------------

It is often useful to know where a certain set of map data came from
(e.g. Tobin, PI, etc.).  The map data source is simply a name that can 
be associated with a map object in the database (it is optional). */

/*    Data Category Of A Map Object
      -----------------------------

Each map object added to the database must be associated with a user supplied
category name (e.g. rivers, coast line, etc.).  The user should be careful
to avoid spelling variations (e.g. "RIVER" and "RIVERS" are all
treated as separate categories). */

/* The following structure describes an annotation map object */

typedef struct 
    {
    GSString_t category_name;       /* Name of the data category. A null value is
                                       NOT allowed. */
    enum 
        {
        GS_PRIMARY_ANNOTATION = 0,
        GS_ATTRIBUTE_ANNOTATION = 1
        } anno_type;                /* Primary or attribute annotation ??? */
    GSString_t anno;                /* Text */
    GSString_t font;                /* Annotation font */
    GSReal_t height_in_mm;          /* Nominal display height (in mm) */
    GSReal_t anchor_angle;          /* Angle for annotation display */
    GSMapLocation_t anchor_point;   /* Anchor location */
    GSVector_t attribute_item;      /* Optional list of attributes */
    } GSMapAnnotation_t;

/* The following structure describes a symbol map object */

typedef struct 
    {
    GSString_t category_name;       /* Name of the data category. A null value is
                                       NOT allowed. */
    GSPlotSymbol_t symbol;          /* Plot Symbol */
    GSReal_t height_in_mm;          /* Nominal display height (in mm) */
    GSMapLocation_t anchor_point;   /* Anchor location */
    GSReal_t anchor_angle;          /* Angle for annotation display */
    GSVector_t attribute_item;      /* Optional list of attributes */
    } GSMapSymbol_t;

/* The following structure describes a point map object */

typedef struct 
    {
    GSString_t category_name;       /* Name of the data category. A null value is
                                       NOT allowed. */
    GSMapLocation_t location;       /* Point location */
    GSVector_t attribute_item;      /* Optional list of attributes */
    } GSMapPoint_t;

/* The following structure describes a polyline map object */

typedef struct 
    {
    GSString_t category_name;       /* Name of the data category. A null value is
                                       NOT allowed. */
    GSBoolean_t flag;               /* True = add additional buffers of polyline data. 
                                     False = only one buffer of polyline data. */
    GSPolylineType_t open_closed;   /* Open polyline or polygon ? */
    GSVector_t map_location;        /* List of locations */
    GSVector_t attribute_item;      /* Optional list of attributes */
    } GSMapPolyline_t;

/* The following structure describes a map object */

typedef struct 
    {
    GSVector_t map_annotation;      /* NOTE: type = GSV_MAP_ANNOTATION */
    GSVector_t map_symbol;          /* NOTE: type = GSV_MAP_SYMBOL */
    GSVector_t map_point;           /* NOTE: type = GSV_MAP_POINT */
    GSVector_t map_polyline;        /* NOTE: type = GSV_MAP_POLYLINE */
    } GSMapObjects_t;

/************************************************************************************/
/*                                                                                  */
/*                          LEGAL DESCRIPTION STRUCTURE                             */
/*                                                                                  */
/************************************************************************************/

typedef struct 
    {
    enum 
        {
        GS_JEFFERSONIAN = 1,
        GS_GULF_COAST_OFFSHORE = 2,
        GS_TEXAS_ABSTRACT = 3,
        GS_OCS_OFFSHORE = 4
        } type;
    union 
        {
        struct 
            {                       /* structure describing Jeffersonian description of
                                       a location */
            GSLongInt_t meridian_code;  /* PRINCIPAL_MERIDIAN code number - (Note: we
                                         need to publish a list or cite a reference - jgg) */
            GSReal_t township;      /* township number */
            GSCompassPoint_t twpns; /* 'N' or 'S' of survey base line */
            GSReal_t range;         /* range number */
            GSCompassPoint_t rngns; /* 'E' or 'W' of survey principal meridian */
            GSReal_t section;       /* section number in township */
            GSString_t section_type;    /* type of 'section' (NULL = section, 'LOT', etc */
            GSString_t spot;        /* Point in section from which measurements are references */
            GSString_t state;       /* State or province abbreviation */
            GSString_t country;     /* Country abbreviation */
            GSString_t county;      /* County, district, parish name */
            GSString_t narrative;   /* Prose description of location */
            } jeffersonian;
        
        struct 
            {
            GSString_t abstract;    /* Abstract ID */
            GSString_t state;       /* State or province abbreviation */
            GSString_t country;     /* Country abbreviation */
            GSString_t county;      /* County name */
            } texas_abstract;
        
        struct 
            {
            GSString_t tract;       /* Tract name */
            struct 
                {
                GSLongInt_t number; /* Numeric part of block identifier */
                GSString_t alpha;   /* Optional character part of block 
                                       identifier */
                } block_id;
            } gulfcoast_offshore;
        struct 
            {
            enum 
                {
                GS_FEDERAL_WATERS,  /* Federal zone (non-state) */
                GS_STATE_WATERS     /* State zone */
                } state_fed;        /* Flag indicating whether point is under state or
                                       federal control */
            GSString_t offshore_block;  /* Offshore block number */
            GSString_t utm_grid_block;  /* Universal Transverse Mercator block
                                           identifier */
            GSLongInt_t ocs_number;
            } ocs_offshore;         /* Outer Continental Shelf description */
        
        } system;
    } GSLegal_t;

/* the following structure describes the location of a point in a legal entity
as an offset from some point in the entity */

typedef struct 
    {
    GSLegal_t legal;                /* legal description of parcel */
    GSDistance_t nsfootage;         /* 'footage' in north-south direction */
    GSString_t ns;                  /* reference line of north-south 'footage'
                                       ('FEL','FWL') */
    GSDistance_t ewfootage;         /* 'footage' in ease-west direction */
    GSString_t ew;                  /* reference line of east-west 'footage'
                                       ('FNL','FSL') */
    } GSLegalLoc_t;

/* the following structure describes the geometry of a legal ownership boundary */

typedef struct 
    {
    GSLegal_t legal;                /* legal description of parcel */
    GSVector_t node_id;             /* list of nodes which identify corners of polygon.
                                       Use this if a topologic model is being used
                                       to transmit the perimeters.  The nodes refer
                                       to the map_location vector sent with the
                                       GSLandNetList_t structure.  If there are any holes
                                       then you must use the map_polyline vector. */
    GSVector_t map_polyline;        /* Vector of GSMapPolyline_t (NOTE: all polylines
                                       should have the GSPolylineType_t be
                                       GS_CLOSED_POLYGON).  Use this vector if
                                       explicit polygons need to be sent. */
    } GSLandNet_t;

/************************************************************************************/
/*                                                                                  */
/*                             GENERAL WELL STRUCTURES                              */
/*                                                                                  */
/************************************************************************************/

typedef struct 
    {                               /* structure for defining well depths */
    GSMask_t valid;                 /* Indicates which fields contain valid information */
    GSReal_t md;                    /* measured depth */
    GSReal_t subdatum;              /* depth relative to local datum */
    GSReal_t tvd;                   /* true vertical depth */
    GSReal_t time;                  /* two-way travel time */
    GSReal_t dx;                    /* X deviation from top-hole position in
                                       projected coordinate system (longitude if
                                       geodetic) */
    GSReal_t dy;                    /* Y deviation from top-hole position in
                                       projected coordinate system (latitude if
                                       geodetic) */
    } GSDepth_t;

typedef struct 
    {                               /* structure for lithostrat codes (mandatory) */
    GSString_t code;                /* Formation code of the lithostratigraphic unit */
    GSString_t age;                 /* Client-specified age code of
                                     lithostratigraphic unit (optional) */
    } GSLithoStrat_t;

/************************************************************************************/
/*                                                                                  */
/*                            WELL HEADER STRUCTURE                                 */
/*                                                                                  */
/************************************************************************************/

typedef struct 
    {                               /* structure defining well header information */
    GSUWI_t uwi;                    /* Unique Well Identifier (mandatory) */
    GSPlotSymbol_t symbol;          /* Plot Symbol name */
    
    GSUnit_t depth_unit;            /* Unit of measure for all depths in this well */
    GSUnit_t time_unit;             /* Unit of measurement for all times in this well */
    
    struct 
        {
        GSBoolean_t flag;           /* TRUE if well is deviated */
        GSVector_t depth;           /* vector of GSDepth_t structures */
        } deviation;
    
    GSString_t well_name;           /* Full legal name of well lease */
    GSString_t well_number;         /* Well permit number within lease */
    GSString_t plot_name;           /* Shortened name of well lease for plotting */
    GSString_t short_name;          /* Shortened or informal name of well */
    
    GSString_t operator;            /* Name of well operator */
    GSString_t licensee;            /* Licensee of well lease */
    GSString_t agent;               /* Name of agent */
    
    /* Class and status information */
    GSString_t  class ;             /* Well classification (e.g. LAHEE class.) */
    GSString_t crstatus;            /* Current well status */
    GSString_t orstatus;            /* Original well status */
    GSString_t prstatus;            /* Previous well status */
    
    /* Location information */
    GSMapLocation_t tophole_xy;     /* structure defining coordinates of 
                                    top hole position */
    GSLegalLoc_t tophole;           /* structure describing legal status of the 
                                     tophole */
    GSMapLocation_t bottomhole_xy;  /* structure defining coordinates of 
                                    bottom hole position */
    GSLegalLoc_t bottomhole;        /* structure describing legal status of the  
                                     bottomhole */
    
    struct 
        {                           /* structure defining offshore specific wells */
        GSMeasurement_t water_depth;    /* Water depth */
        GSString_t platform_name;   /* Name of offshore drilling platform */
        } offshore;
    
    /* Total depth information */
    struct 
        {                           /* structure defining depths of driller, 
                                       logger, and plugback */
        GSDepth_t driller;          /* structure describing driller depths */
        GSDepth_t logger;           /* structure describing logger depths */
        GSDepth_t plugback;         /* structure describing plugback depths */
        GSLithoStrat_t formation;   /* structure describing formation at TD */
        GSTemperature_t temperature;    /* bottom hole temperature */
        GSMeasurement_t pressure;   /* bottom hole pressure */
        } td;
    
    /* Elevation information */
    GSElevationRef_t elevation;     /* Datum elevation for well */
    GSElevation_t ground_elevation; /* ground elevation */
    GSElevation_t kb_elevation;     /* kelly bushing elevation */
    GSElevation_t cf_elevation;     /* casing flange elevation */
    
    /* Checkshot information */
    struct 
        {
        GSElevationRef_t datum;     /* datum used for checkshot */
        GSVelocity_t vsd;           /* velocity surface to datum */
        GSVector_t depth;           /* measured depth */
        GSVector_t time;            /* two-way travel time */
        } checkshot;
    struct                          /* Drilling information */
        {
        GSString_t contractor;      /* name of drilling contractor */
        GSString_t rig_number;      /* drilling rig number or identifier */
        } drilling;
    
    /* Miscellaneous Information */
    GSString_t primary_source;      /* Name of source of well information */
    GSVector_t stratcolumn;         /* Vector of strat column name to use for this well */
    enum 
        {
        GS_IMPERIAL_UNIT = 1,
        GS_METRIC_UNIT = 2
        } original_unit;            /* Original unit system that data was 
                                    collected in */
    GSBoolean_t proprietary;        /* TRUE if this well contains proprietary 
                                     information */
    GSBoolean_t discovery_well;     /* TRUE if this is the discovery field for the field*/
    GSBoolean_t fault;              /* TRUE if this well has a faulted section */
    
    /* Confidentiality Information */
    struct 
        {
        GSBoolean_t flag;           /* confidentiality flag */
        GSString_t formcode;        /* confidentiality formation */
        GSDepth_t depth;            /* confidentiality depth */
        GSDate_t release_date;      /* confidential release date */
        } confidential;
    
    /* Dates */
    GSDate_t last_update;           /* date/time of last update */
    GSDate_t spud_date;             /* spud date */
    GSDate_t comp_date;             /* completion date */
    GSDate_t rigrel;                /* rig release date */
    GSDate_t onprod;                /* on production date */
    GSDate_t calc_onprod;           /* calculated on production date */
    GSDate_t oninject;              /* on injection date */
    GSDate_t status_date;           /* date last status was entered */
    GSDate_t fin_drill;             /* final drilling date */
    
    /* Headers (tree-tops) for other well data classes */
    GSVector_t log_run;             /* vector of GSLogRun_t */
    GSVector_t well_core;           /* Vector of core data (GSWellCore_t) */
    GSVector_t zone_value;          /* Vector of zone values (GSZoneValue_t) */
    GSVector_t well_marker;         /* Vector of GSWellMarker_t */
    GSVector_t well_production;     /* Vector of GSWellProduction_t
                                     (sorted descending by year) */
    GSVector_t well_tubulars;       /* Vector of tubular products placed in well */
    GSVector_t well_remarks;        /* Vector of general remarks */
    GSVector_t well_test_hdr;       /* Vector of GSWellTestHdr_t */
    GSVector_t seismic_well_tie;    /* vector of correlations with seismic data */
    } GSWellHdr_t;

/************************************************************************************/
/*                                                                                  */
/*                             WELL CORE STRUCTURE                                  */
/*                                                                                  */
/************************************************************************************/

typedef struct 
    {
    enum 
        {
        GS_WELL_CORE_NORMAL = 1,    /* Normal well core */
        GS_WELL_CORE_SIDEWALL = 2   /* Sidewall core */
        } core_type;
    GSDepth_t top;                  /* Top of cored interval */
    GSDepth_t base;                 /* base of cored interval (not used for sidewall core) */
    GSReal_t recovered;             /* Amount of core recovered, as a percentage (0-100) */
    GSString_t remarks;
    GSString_t show;                /* Type of petroleum show in core */
    } GSWellCore_t;

/************************************************************************************/
/*                                                                                  */
/*                     Remarks, Miscellaneous well information                      */
/*                                                                                  */
/************************************************************************************/

/* The following catch-all is intended to be used to describe some measurement
or activity observed in a well that is not adequately modelled elsewhere in these data
structures.  The intent is to allow another vendor to display this information somehow
without being concerned about the semantics of the information.  This might be used
to display arbitrary information in a cross-section panel, or in a report. */

typedef struct 
    {
    GSString_t type_name;           /* Type of data being described, or name of data set
                                       (see zone variable list for definition) */
    GSDepth_t depth;                /* Depth at this these observations were made
                                      (Zero implies these observations apply
                                      to the well as a whole) */
    GSVector_t string;              /* A vector of strings describing some event
                                     or measurement at this depth */
    } GSWellRemarks_t;

/************************************************************************************/
/*                                                                                  */
/*                             LOG RUN AND TRACE STRUCTURE                          */
/*                                                                                  */
/************************************************************************************/

typedef struct 
    {
    GSResistivity_t rm;             /* Mud resistivity */
    GSResistivity_t rmf;            /* Mud filtrate resistivity */
    GSResistivity_t rmc;            /* Mud cake resistivity */
    GSString_t source;              /* Source of resistivity observations */
    } GSMudResistivity_t;

typedef struct 
    {
    GSString_t name;                /* Name or mnemonic of sensor (GR, DT, RHOB, etc) */
    GSString_t source;              /* Source of the digital data associated with this sensor */
    GSLongInt_t version;            /* Version number of this trace - used during editing */
    GSString_t comments;            /* General remarks about the log trace */
    GSUnit_t z_unit;                /* Unit of depth (time) measurement */
    GSUnit_t trace_unit;            /* Unit of trace value */
    GSReal_t non_null_top;          /* Top of trace data interval (excluding nulls) */
    GSReal_t non_null_base;         /* Base of trace data interval (excluding nulls) */
    GSReal_t min;                   /* Minimum trace value */
    GSReal_t max;                   /* Maximum trace value */
    GSReal_t dinc;                  /* Digitizing increment (0.0 if random) */
    GSVector_t processing_history;  /* Vector of processing history records sorted by date,
                                     most recent listed first */
    GSVector_t depth;               /* Array of depth values (4 or 8 byte floating point values)
                                     Note: this is NOT a GSDepths_t structure) */
    GSVector_t value;               /* Corresponding array of values.  The number of depths
                                     and values should match (4 or 8 byte floating point values) */
    } GSLogTrace_t;

typedef struct 
    {
    /* A service is also loosely called a logging tool.
    Several services may be used in a single pass */
    GSString_t log_service;         /* Name of log service */
    GSString_t tool_id;             /* Tool identifier/serial number */
    GSLongInt_t sequence;           /* Sequence number of this tool in current tool string */
    GSVector_t log_trace;           /* List of sensors that belong to this service/tool */
    } GSLogService_t;

typedef struct 
    {
    /* A pass is a single Trip of the tool string.
    There is usually more than one pass per run */
    GSLongInt_t pass_number;        /* Logging pass number within current log run */
    GSDate_t pass_date;             /* Date this pass was started */
    GSMeasurement_t top;            /* Top of logged interval */
    GSMeasurement_t base;           /* Base of logged interval */
    GSVector_t log_service;         /* List of services being used during this pass */
    } GSLogPass_t;

typedef struct 
    {
    /* A log run is a visit by a logging company to a drilling site.
    It usually is associated with a single billing cycle
    Also called an 'activity' */
    GSLongInt_t run_number;         /* Log run number */
    GSString_t logging_company;     /* Name of company providing logging service */
    GSDate_t run_date;              /* Date this log run was started */
    GSString_t logging_unit_number; /* Identification of logging truck or unit */
    GSString_t logging_unit_loc;    /* Location of logging unit (home base) */
    GSString_t recorder;            /* Name of person acting as logging recorder */
    GSString_t witness;             /* Name of company witness to logging activity */
    GSElevationRef_t datum;         /* Elevation used as log run datum */
    struct 
        {
        GSString_t type;            /* type of mud */
        GSMeasurement_t salinity;   /* Mud salinity */
        GSMeasurement_t density;    /* Mud weight */
        GSMeasurement_t viscosity;  /* mud viscosity */
        GSMeasurement_t fluid_loss;
        GSReal_t pH;
        GSMudResistivity_t resistivity; /* Resistivity of mud */
        GSMudResistivity_t resistivity_bht; /* Resistivity of mud at bottom hole
                                             temperature */
        } mud_data;
    GSMeasurement_t time_circ_stopped;  /* Time since mud circulation was stopped */
    GSMeasurement_t time_logger_on_bottom;  /* Time the logging tool was at bottom of well */
    GSTemperature_t max_rec_temp;   /* Maximum bottom hole temperature recorded */
    GSVector_t log_pass;
    } GSLogRun_t;

/************************************************************************************/
/*                                                                                  */
/*                           ZONE DEFINITIONS                                       */
/*                                                                                  */
/************************************************************************************/

typedef GSString_t GSZoneName_t;
typedef GSString_t GSZoneVariable_t;

typedef struct 
    {
    GSZoneName_t zone_name;         /* Name of zone being defined */
    GSString_t top_definition;      /* Text describing how top of zone is defined */
    GSString_t base_definition;     /* Text describing how base of zone is defined */
    GSString_t remarks;             /* General remarks about zone */
    } GSZoneDefinition_t;

typedef struct 
    {
    GSZoneName_t zone_name;         /* Name of zone in which the variable is defined.
                                     If null, then the defined variable applies to all zones. */
    GSZoneVariable_t variable_name; /* Name of variable being defined */
    GSBoolean_t numeric;            /* TRUE if measurements are often numeric */
    GSString_t algorithm;           /* Description of methodology used to define the variable.
                                     This may be an equation or a reference
                                     to a known algorithm. */
    GSString_t remarks;             /* General remarks about zone variable */
    } GSZoneVariableDefinition_t;

typedef struct 
    {
    GSZoneName_t zone_name;         /* Name of the zone.  If null, then the defined
                                     variable applies to entire well or field. */
    GSZoneVariable_t variable_name; /* Name of variable being measured */
    GSDepth_t top;                  /* Depth to top of measured interval */
    GSDepth_t base;                 /* Depth to base of measured interval */
    GSMeasurement_t value;          /* Value of zone variable as a number */
    GSString_t string_value;        /* (optional) value of zone variable as a string
                                       (for such things as 'indurated', 'friable',
                                       'overpressured', etc) */
    } GSZoneValue_t;

/************************************************************************************/
/*                                                                                  */
/*                          PRODUCTION HISTORY STRUCTURE                            */
/*                                                                                  */
/************************************************************************************/
typedef struct 
    {
    enum 
        {
        GS_OIL = 1,
        GS_WATER = 2,
        GS_GAS = 3
        } fluid_type;               /* Type of fluid produced */
    GSLongInt_t year;               /* Year of record */
    GSZoneName_t zone_name;         /* Name of the zone. */
    GSReal_t cumulative_prior_years;    /* Sum of fluid produced during prior years */
    GSVector_t prod_month;          /* Vector of GSReal_t containing monthly production,
                                     one per month (1st is January, 2nd is February, etc)*/
    GSUnit_t unit;                  /* Unit of measure used to describe production volumes */
    } GSWellProduction_t;

/************************************************************************************/
/*                                                                                  */
/*                          TUBULAR PRODUCTS STRUCTURE                              */
/*                                                                                  */
/************************************************************************************/
typedef struct 
    {
    GSString_t tubing_type;         /* Type of tubing product */
    GSString_t tubing_size;         /* Size of tubing, as a printable string */
    GSDate_t install_date;          /* Date this tubular product was installed */
    GSDepth_t top;                  /* Top of tubular product */
    GSDepth_t base;                 /* base of tubular product */
    GSMeasurement_t bore;           /* Inside diameter of casing */
    GSMeasurement_t hole_size;      /* Size of hole in which tubular product was installed */
    struct 
        {
        GSDepth_t depth;            /* Depth at which casing shoe was installed */
        GSLithoStrat_t form;        /* Formation in which shoe was set */
        } shoe;
    GSReal_t strength;              /* Axial load required to yield pipe */
    GSString_t steel_spec;          /* Manufacturer's spec under which steel was made */
    GSString_t remarks;
    } GSWellTubulars_t;

/************************************************************************************/
/*                                                                                  */
/*                           WELL MARKER STRUCTURES                                 */
/*                                                                                  */
/************************************************************************************/

typedef enum 
    {
    GS_LITHO_TOP = 1,               /* Lithostratigraphic (formation) top */
    GS_CONTACT_TOP = 2,             /* Fluid surface contact (e.g. oil/water) */
    GS_FAULT_POINT = 3,             /* Piercing point of well through fault plane */
    GS_MARKER_TOP = 4,              /* Stratigraphic marker - subordinate to
                                       lithostratigraphic pick */
    GS_BIOSTRAT = 5,                /* Biostratigraphic boundary */
    GS_OTHER_TOP = 6
    } GSMarkerType_t;

typedef struct 
    {                               /* Formation top description */
    GSUWI_t uwi;                    /* Unique well identifier (mandatory) */
    GSLithoStrat_t name;            /* Name of lithostratigraphic (surface set) name (mandatory) */
    GSString_t source;              /* Source of interpretation */
    GSSurfaceSetName_t seismic_horizon; /* Name of seismic surface that this marker is
                                           correlated with */
    GSUnit_t z_unit;                /* unit of measure (used when part of a surface set) */
    GSDepth_t depth;                /* Coordinates of piercing point */
    GSMeasurement_t fault_gap;      /* For faults, the amount of missing section faulted
                                       out at this location */
    enum 
        {
        GS_NORMAL_SECTION = 0,      /* Paleo up indicators point up */
        GS_INVERTED_SECTION = 1     /* Paleo up indicators inverted */
        } up_direction;
    GSString_t comment;             /* comments describing nature of pick
                                     (ABSENT, ERODED, NOT PICKED, etc) */
    GSBoolean_t best_pick;          /* TRUE if this is best available information */
    GSString_t quality;             /* Quality code of pick */
    GSDate_t last_update;           /* date this interpretation made */
    } GSWellMarker_t;

/*    Well Tie Information  
      --------------------
 */

typedef struct                      /* This structure describes the relationship between
                                       a specific surface in a well and its correlation
                                       with a specify seismic line and shot point.
                                       Useful for tying geophysical/geological data in
                                       reservoir simulators */
    {
    GSLithoStrat_t marker;
    GSSurfaceSetName_t surface_set_name;    /* Name of correlative seismic surface */
    GSSeismicSurveyName_t survey_name;  /* (optional) seismic survey name */
    GSSeismicLineName_t line_name;  /* (optional) seismic line name */
    GSSeismicDataPoint_t seismic_loc;   /* location on seismic line */
    } GSSeismicWellTie_t;

/* A vector of the following entities describes the lithostratigraphic
codes that may be sent.  It acts as an assertion list and provides some
structural relationships between 'formations' */

typedef struct 
    {
    GSLithoStrat_t code_name;       /* formation and age codes (NOTE: Age code in this
                                       structure implies the Average of the formation.
                                       The exact age at a well is found in the
                                       GSWellMarker_t structure) */
    GSString_t source;              /* Name of company that defines/uses this code */
    GSSurfaceSetName_t full_name;   /* Full marker/formation (surface set) name */
    GSMarkerType_t marker_type;     /* Type of surface */
    GSLithoStrat_t parent;          /* if this unit is a member of a larger group, then
                                       this field contains the name of the next higher order */
    GSString_t remarks;
    } GSLithostratCodeDesc_t;

/* The following represents a stratigraphic column.  This is a list
of lithostratigraphic codes and their depositional ranking, from youngest
to oldest. This list usually describes a normal depositional sequence
independent of any well */

typedef struct 
    {
    GSString_t name;                /* Name of stratigraphic column */
    GSString_t citation;            /* Journal citation describing sequence */
    GSString_t remarks;             /* */
    GSVector_t lithostrat;          /* Vector of formation and age codes */
    } GSStratigraphicColumn_t;

/************************************************************************************/
/*                                                                                  */
/*                           WELL TEST STRUCTURES                                   */
/*                                                                                  */
/************************************************************************************/

typedef struct 
    {
    enum 
        {
        GS_WELL_DRILLSTEM_TEST,
        GS_WELL_PRODUCTION_TEST
        } test_type;
    /* this needs mucho work */
    } GSWellTestHdr_t;

/************************************************************************************/
/*                                                                                  */
/*                                  CROSS SECTIONS                                  */
/*                                                                                  */
/************************************************************************************/

/*  Geological Cross Section is a structure designed for describing a
    cross section with surfaces, zones, and wells projected.  This can
    be either one traverse section or segmented section consisting of
    more than one section panel.

    The vector of wells should contain the list of wells which may be
    presented with this section by projecting their data to the section.

    GSSectionIntersection_t is an intersection between one surface set
    with the cross section, the points on which are described by the
    pair of x and z values.  X values are measured as a distance from
    the start point of the section, that is, it is the X coordinate
    in the cross section display.
    
    The zones above and below each point on the section can be specified
    using up_zone_number and down_zone_number vector together with
    the vector of zone name which appears in GSGeolCrossSection_t. 
    
    These structures are also inherited by the seismic objects.  The local coordinate
    system that has to be imposed for seismic sections is done in the
    GSSeismicLineIntersection_t structure. */

/*    Generic Cross Section
      ---------------------
*/

typedef struct 
    {
    GSString_t section_name;        /* Name of the section if applicable */
    GSVector_t map_location;        /* Map location of the nodes of the
                                       traverse segmented section.  A vector
                                       of two values (start and stop point)
                                       in case of a single traverse section */
    GSVector_t section_intersection;    /* Vector of intersection with one surface
                                           set */
    GSVector_t zone_name;           /* Sorted vector of zone names found on section;
                                       1st entry is shallowest */
    } GSSection_t;

/*    Geological Cross Section
      ------------------------
*/

typedef struct 
    {
    GSSection_t section;            /* Geometric description of the section */
    GSVector_t uwi;                 /* Vector of wells to be projected onto
                                       this cross section */
    GSVector_t proj_line;           /* Section panel number on which each well 
                                       is to be projected (section panel no.
                                       as 1, 2, ..., ; 4 byte integer).
                                       0 means the closest section panel */
    } GSGeolCrossSection_t;

/************************************************************************************/
/*                                                                                  */
/*                    TOP STRUCTURES FOR EACH DATA TYPE                             */
/*                                                                                  */
/************************************************************************************/

/*    Seismic Survey Information
      --------------------------
 */
/*
All seismic related information is specified in a hierarchical structure.  The
top of the hierarchy is a structure which groups the information according to
surveys.  Surveys may be either 2d groups of line or 3d surveys.  In order to
facilitate memory management, 3d survey data will be organized according to
lines.  The following defines the survey structure:                  */

typedef struct 
    {
    GSSeismicSurveyName_t survey_name;  /* Name of survey */
    GSString_t survey_desc;         /* Survey description */
    enum                            /* Survey type */
        {
        GS_SURVEY_2D = 2,           /* 2d survey symbol */
        GS_SURVEY_3D = 3            /* 3d survey symbol */
        } survey_type;
    GSElevationRef_t z_datum;       /* Datum to use in association with elevations */
    GSCartoProjection_t proj;       /* Projection information */
    GSNullValue_t null_value;       /* null values for various data types */
    GSSeismicLocation3D_t loc3d;    /* 3d survey specification and
                                      location structure (not used for 2-D survey) */
    GSVector_t seismic_line;        /* vector of structures describing lines
                                       element_type = GSV_SEISMIC_LINE */
    } GSSeismicSurvey_t;

/*    Surface set Information
      -----------------------
 */
typedef struct 
    {
    GSSurfaceSetName_t surface_name;    /* Name of surface set */
    GSString_t description;         /* description of the surface */
    GSCartoProjection_t proj;       /* Projection information */
    GSNullValue_t null_value;       /* null values for various data types */
    GSSurfaceType_t surface_type;   /* Type of surface (Fault, horizon, geologic marker) */
    GSVector_t surface_geometry;    /* List of geometry information for surface */
    GSSurfaceIntersection_t intersection;   /* Intersection of surface set with other entities */
    } GSSurfaceSet_t;

/*    Field Information
      ----------------
 */

typedef struct 
    {
    GSString_t field_name;          /* name of (oil, gas) field */
    GSString_t field_type;          /* What type of field this is */
    GSUWI_t discovery_well;         /* Unique identifier of the discovery well */
    GSVector_t zone_value;          /* Vector of zone values for the field */
    GSVector_t map_polyline;        /* areal extent of field, as a series of
                                       closed polygons.  NOTE: type = GSV_MAP_POLYLINE */
    GSCartoProjection_t proj;       /* Projection information */
    GSNullValue_t null_value;       /* null values for various data types */
    GSVector_t well_hdr;            /* vector of structures describing wells */
    GSVector_t geol_cross_section;  /* Vector of geological cross section */
    } GSField_t;

/*    Map Information
      ---------------
 */

typedef struct 
    {
    GSString_t source_name;         /* Name of the data source. A null
                                       value is allowed (e.g. no source) */
    GSCartoProjection_t proj;       /* Projection information */
    GSNullValue_t null_value;       /* null values for various data types */
    GSString_t local_datum;         /* Datum reference for long., lat. */
    GSUnit_t z_unit;                /* Unit of elevation */
    GSExtents_t extent;             /* Area of interest of the map */
    GSVector_t map_objects;
    } GSMap_t;

/*    Fault Trace (in map view) Information
      -------------------------------------
 */

typedef struct 
    {
    GSElevation_t z_datum;          /* Datum to use in association with elevations */
    GSCartoProjection_t proj;       /* Projection information */
    GSNullValue_t null_value;       /* null values for various data types */
    GSVector_t fault_surface;       /* Vector of structures of surfaces
                                       having fault traces defined */
    } GSFaultTraceSet_t;

/*    List of formation codes and stratigraphic columns
      -------------------------------------------------
 */
typedef struct 
    {
    GSVector_t lithostrat_code_desc;    /* A list of stratigraphic codes */
    GSVector_t stratigraphic_column;    /* List of stratigraphic columns */
    GSNullValue_t null_value;       /* null values for various data types */
    } GSLithostratCodeList_t;

/*    List of zone definitions and variables
      --------------------------------------
 */
typedef struct 
    {
    GSVector_t zone_definition;     /* List of zone definition */
    GSVector_t zone_variable_definition;    /* List of zone variable definitions */
    GSNullValue_t null_value;       /* null values for various data types */
    } GSZoneList_t;

/*    Land Net Information
      ---------------
 */

typedef struct 
    {
    GSString_t source_name;         /* Name of the data source. A null
                                       value is allowed (e.g. no source) */
    GSCartoProjection_t proj;       /* Projection information */
    GSNullValue_t null_value;       /* null values for various data types */
    GSExtents_t extent;             /* Area of interest of the land net list */
    enum 
        {
        GS_POLYLINE_MODEL = 1,
        GS_TOPOLOGIC_MODEL = 2
        } model_type;               /* flag indicating whether a topologic
                                       or a polyline model is being used to
                                       represent the polygons of the land net */
    GSVector_t map_location;        /* Array of node coordinates.  When used,
                                       the land net polygons are defined as a
                                       list of nodes which refer to this list.
                                       If a topologic model is not used, this
                                       vector should be left null. */
    GSVector_t land_net;
    } GSLandNetList_t;

/************************************************************************************/
/*                                                                                  */
/*                    STATUS STRUCTURE                                              */
/*                                                                                  */
/************************************************************************************/

/*  A status structure for returning to the exporting application information
    about the success/failure of the various functions performed by the application server.
 */

typedef struct 
    {
    GSLongInt_t status_code;        /* error code */
    GSString_t object_key;          /* One or more object keys, separated by ^,
                                       identifying entity that produced status */
    GSString_t status_description;  /* Status description */
    } GSStatusReturn_t;

typedef GSVector_t GSStatusVector_t;

/************************************************************************************/
/*                                                                                  */
/*                    CONTEXT STRUCTURES                                            */
/*                                                                                  */
/************************************************************************************/

/*  There are two parts to application server context within which a client must operate,
    environmental in the form of a possible memory limitation, and data in the
    form of things such as project names, pass words, file names, etc.  The
    following structures will be used to reply to a request for context
    information : */

typedef struct 
    {
    GSLongInt_t max_memory;         /* Size of local memory buffer, in bytes */
    GSVector_t context_requirements;    /* data context requirements */
    } GSAppServerContext_t;

/*  This structure is associated with defining the information 
to be sent to to the application server to establish context. */

typedef struct 
    {
    enum 
        {
        GS_INTEGER_TYPE = 1,
        GS_CHARACTER_TYPE = 2,
        GS_FLOAT_TYPE = 3,
        GS_UNSIGNED_INTEGER = 4
        } type;                     /* Data type of context variable */
    GSLongInt_t max_length;         /* Maximum length of context variable (if string) */
    GSBoolean_t confidential;       /* Flag for whether to display user's input */
    GSString_t prompt;              /* Prompt string to use for requesting context variable */
    GSString_t cmdline_tag;             
    } GSContextRequirements_t;

/*  This vector is used to transmit the requested information back to
the exporting process.  There will be one string for each requirement specified
in the previous structure.  Even though an integer(perhaps unsigned) or float may be
required, it will be sent in ASCII representation. */

typedef GSVector_t GSContextInformation_t;  /* this is a vector of type GSString_t */

/*   Upon establishment of the context, a token will be returned to the client
     process */

typedef GSLongInt_t GSContextToken_t;   /*  tag for context established */

/************************************************************************************/
/*                                                                                  */
/*                    EXECUTIVE STRUCTURES                                          */
/*                                                                                  */
/************************************************************************************/

/*  An executive structure containing context destination information for
    cross check reference to the context establishment information
    structure, and a list which provides reference to all 
    supported data type structures which are to be transmitted.  If context
    has been previously established then the context information structure
    need not be included.  If context has not been previously established
    then the context information structure must be referenced first in the 
    list(if necessary).
*/

/*   This structure allows description of an operation upon which to perform on
     the accompanying data structure */

typedef enum 
    {
    /*    Instruction is unknown, check disposition_ext */
    GS_CMD_UNKNOWN = 0,             /* Address of structure is undefined */
    /*    Insert into the appropriate place(s) the contents of the structure
          (Reject if keys already exist) */
    GS_CMD_INSERT = 1,
    /*    Update the appropriate place(s) with the contents of the structure
          (Insert or update if necessary based on keys) */
    GS_CMD_UPDATE = 2,
    /*    Overwrite the appropriate place(s) using the keys of the structure
          (but do not insert if keys do not exist) */
    GS_CMD_OVERWRITE = 3,
    /*    Delete the appropriate place(s) using the keys of the structure */
    GS_CMD_REPLACE = 4,
    /*    Delete the appropriate place(s) using the keys of the structure
          if it exists, then perform insert) */
    GS_CMD_DELETE = 5,
    /*    Interaction is complete, terminate                */
    GS_STOP_SERVER = 1000,          /* Address of structure is NULL */
    /*    Break current context, retain comm handshake      */
    GS_CONTEXT_BREAK = 1001,        /* Address of structure is NULL */
    /*    Return context requirements                       */
    GS_SEND_CONTEXT = 1002,         /* Address of structure is NULL */
    /*    Process everything, send no return status         */
    GS_NO_RETURN = 1003,            /* Address of structure is NULL */
    /*    Command from GeoShare Server to open another port */
    GS_OPEN_PORT = 1004             /* Address of structure is NULL */
    } GSOperation_t;

/*  The following is a list of top-level structures ('objects') that GeoShare defines.
    The list is extendable past the enum set by using the extension portion of the union. */

typedef enum 
    {
    GS_STRUCT_UNKNOWN = 0,          /* structure unknown to GeoShare is passed,
                                       check type_ext for value */
    GS_STRUCT_APP_SERVER_SPECS = 1,
    GS_STRUCT_APP_SERVER_RQMTS = 2,
    GS_STRUCT_CONTEXT_RQMTS = 3,
    GS_STRUCT_CONTEXT_INFO = 4,
    GS_STRUCT_CONTEXT_TOKEN = 5,
    GS_STRUCT_STATUS_VECTOR = 6,
    GS_STRUCT_SEISMIC_SURVEY = 11,
    GS_STRUCT_SURFACE_SET = 12,
    GS_STRUCT_FIELD = 13,
    GS_STRUCT_MAP = 14,
    GS_STRUCT_FAULT_TRACE_SET = 15,
    GS_STRUCT_LITHOSTRAT_CODE_LIST = 16,
    GS_STRUCT_ZONE_LIST = 17,
    GS_STRUCT_LAND_NET_LIST = 18
    } GSDataStructType_t;

typedef struct 
    {
    GSLongInt_t geoscience;         /* geoscience version number */
    GSLongInt_t revision;           /* Revision number of structure */
    GSString_t vendor;              /* Vendor that provided latest revision */
    } GSVersion_t;

typedef struct 
    {
    GSOperation_t operator;
    GSLongInt_t operation_ext;
    GSDataStructType_t type;
    GSLongInt_t type_ext;
    GSVersion_t version;
    GSVoidptr_t structure_pointer;
    } GSStructure_t;

typedef struct 
    {
    GSContextToken_t context_token; /* tag for context established */
    GSVector_t structure;           /* vector of structures on which to act */
    } GSExecutive_t;

typedef GSLongInt_t GSConnection_t; /* communications channel identifier */

/************************************************************************************/
/*                                                                                  */
/*                    APPLICATION SERVER CAPABILITY STRUCTURES                      */
/*                                                                                  */
/************************************************************************************/

/*  A application server information structure is returned to the GeoShare Server
    upon request.  This structure contains the following information:
        a.  Status of application server service initialization
        b.  A unique name for the application server so a client can ask for it by name (if known).
        c.  A descriptive text string to show the user in a list of application servers
        d.  Exploration data structures supported
        e.  Data structure revision level range supported
 */

/*  Support for a given data structure is composed of three parts, an enumerated
    parameter which indicates that it is supported, a mask variable in which
    the application server indicates which components of the structure it can handle, and 
    a structure indicating the GeoShare version which it supports.  The
    following #define statements provide the component masks: */

/*  Surface Set Component Masks  */

#define GSM_SS_GRID            (1<<0)   /* grid structure is supported */
#define GSM_SS_SEISMIC         (1<<1)   /* seismic interpretation is supported */
#define GSM_SS_XYZ             (1<<2)   /* xyz scatter data are supported */
#define GSM_SS_CONSTANT        (1<<3)   /* constant data are supported */
#define GSM_WELL_MARKER        (1<<4)   /* Well Marker data are supported */
#define GSM_SS_CONTOUR         (1<<5)   /* Contour Information is supported */

/*  Seismic Data Support Masks */

#define GSM_SEISMIC_2D         (1<<0)   /* 2d seismic line input is supported */
#define GSM_SEISMIC_3D         (1<<1)   /* 3d Survey input is supported */
#define GSM_SEISMIC_LINE_HDR   (1<<2)   /* Seismic line header data are supported */
#define GSM_SEISMIC_TRACE      (1<<3)   /* Seismic trace data are supported */
#define GSM_SEISMIC_SURFACE    (1<<4)   /* Seismic surface data are supported */

/*  Well information Component Masks */

#define GSM_WELL_CHECKSHOT     (1<<0)   /* Checkshot information is supported */
#define GSM_WELL_PATH          (1<<1)   /* Path data are supported */
#define GSM_WELL_LOG_RUN       (1<<2)   /* Log run data are supported */
#define GSM_WELL_WELL_CORE     (1<<3)   /* Core data are supported */
#define GSM_WELL_ZONE_VALUE    (1<<4)   /* Zone value data are supported */
#define GSM_WELL_WELL_MARKER   (1<<5)   /* Well marker(tops) data are supported */
#define GSM_WELL_PRODUCTION    (1<<6)   /* Production history data are supported */
#define GSM_WELL_TUBULARS      (1<<7)   /* Tubular information are supported */
#define GSM_WELL_REMARKS       (1<<8)   /* Remark information are supported */
#define GSM_WELL_DSTS          (1<<9)   /* Drillstem tests are supported */
#define GSM_WELL_PROD_TESTS    (1<<10)  /* Production tests are supported */
#define GSM_SEISMIC_WELL_TIE   (1<<11)  /* Seismic well tie data are supported */

/*  Field information Component Masks */

#define GSM_FIELD_WELLS        (1<<0)   /* Field Well data are supported */
#define GSM_FIELD_BOUNDARY     (1<<1)   /* Field boundary is supported */
#define GSM_FIELD_ZONE_VALUE   (1<<2)   /* Field zone data are supported */

/*  Land Net Component Masks */

#define GSM_LAND_NET_JEFFERSONIAN (1<<0)   /* Jeffersonian data are supported */
#define GSM_LAND_NET_TEXAS_ABSTRACT (1<<1)   /* Texas abstracts are supported */
#define GSM_LAND_NET_ATS (1<<2)   /* Alberta Township Survey data are supported (Canada) */
        
#define GSM_LAND_NET_DLS (1<<3)   /* Dominion Land Survey data are supported (Canada) */

#define GSM_LAND_NET_NTS (1<<4)   /* NTS data are supported (Canada) */
#define GSM_LAND_NET_OCS (1<<5)   /* US Offshore data are supported */
#define GSM_LAND_NET_GULF_COAST (1<<6)   /* US Gulf shore data are supported */

/*  Server Application must provide one of these for each data structure it
    supports - also the type of operations supported */

typedef struct 
    {
    GSDataStructType_t data_struct_type;
    GSMask_t components_supported;
    GSVersion_t version;
    GSVector_t operation;           /* supported operations on these data
                                       (e.g. insert, update, overwrite, replace) */
    } GSDataSupported_t;

/*  This structure contains the information which will be given to the GeoShare
    server each time it starts an instance of a server application  */

typedef struct 
    {
    GSLongInt_t app_server_status;  /* Reserved for future use */
    GSString_t app_server_name;     /* Unique character identifier of application server
                                     (<=20 characters ) */
    GSString_t banner_string;       /* Your chance to advertise your product!
                                       (<=60 characters ) */
    GSVector_t data_supported;      /* List of types of data the server supports */
    } GSAppServerSpecs_t;

/*  A client application may request information from the GeoShare server about
    which application servers are available for the task the client wishes.  It
    may specify the request in terms of a application server name or in terms of data
    structures supported.  If more than one specification is provided, then
    application servers meeting any of the specifications will be included.  A vector of 
    the following structures will be passed to the GeoShare server as input to 
    making a list of application servers which will satisfy the criteria: */

typedef GSVector_t GSAppServer_t;

typedef struct 
    {
    enum 
        {
        GS_STRUCT_SUPPORTED = 1,
        GS_NAME = 2
        } spec_type;
    GSString_t app_server_name;
    GSDataSupported_t data;
    } GSRequirement_t;

/************************************************************************************/
/*                                                                                  */
/*                    END OF INCLUDE FILE GEOSCIENCE.H                              */
/*                                                                                  */
/************************************************************************************/
#endif
@


1.11
log
@new gillespie release
@
text
@d2071 1
@


1.10
log
@*** empty log message ***
@
text
@d2 1
a3 1
#define _GEOSCIENCE_H_DEFINED
d5 1
a5 1
|
d9 2
a10 2
|
|         This code is the product of GeoQuest Systems, Inc. and Finder
d14 1
a14 1
|
d19 2
a20 2
|              Current working title of system : GeoShare (generic)
|              Other names: EDICT (Geoquest Systems)
d24 2
a26 2
|   Notes:
|
d28 1
a28 1
|                  Original code.
d56 1
a56 1
|                      that the tentative executive(Pres, VP, etc.)
d58 1
a58 1
|                  Made adjustments to the executive level structures.
d60 1
a60 1
I                               O Osawa, IDS Schlumberger
d63 1
a63 1
|                               K Waagb?, GECO Schlumberger
d66 1
a66 1
|                  An experiment with seperating seismic surfaces from the seismic
d79 1
a79 1
|                  Rearrange SurfaceSetIntersection logic
d81 31
d115 5
a119 7


/********************************************************************/
/*                                                                  */
/*        Notes on usage of geoscience.h                                */
/*                                                                  */
/********************************************************************/
d121 4
a124 151
 /*
  * We have assumed an ANSI C model throughout this structure.
  * 
  * On naming conventions
  * 
  * All symbolic (enum) constants begin with GS_ .  All masks begin with GSM_,
  * and all vector data types begin with GSV_.  All symbolic constants are
  * upper case.
  * 
  * Data typedefs are named using mixed case beginning with GS and ending with
  * _t, as in GSSurfaceSetName_t.
  * 
  * GSVectors are arrays of objects.  The name of the vector is either the
  * lower-case name of a typedef with the leading GS and trailing _t stripped
  * off ans underscores appearing where a case change occurs (e.g. an array
  * of GSDepths_t becomes GSVector_t depths and GSSurfaceSet_t becomes
  * GSVector_t surface_set) or the name of a scalar value, in which case the
  * possible element types and sizes are listed in the comment of the
  * variable
  * 
  * On typedefs
  * 
  * Where a data domain is referred to in more than one structure, it is
  * generally given its own typedef.  This may obscure the reading of the
  * structure for the novice, but assists in implementing code which asserts
  * domain restrictions, as with object programming languages (e.g. C++), and
  * helps in the maintainance of the structure. It also assists in writing
  * code that can be rigorously checked by the compiler.
  * 
  * On surface sets
  * 
  * A surface set is a collection of surfaces usually associated with some
  * geological or geophysical 'event', such as a seismic horizon or a
  * geological formation or marker. This surface set is given a name.  In
  * common usage, this corresponds to a formation name (geological) or a
  * seismic horizon (geophysical).  Surfaces sets can be represented by
  * grids, contours, scatter (xyz) sets, well picks, seismic line cross-
  * sections.
  * 
  * It is possible to reach the GSSeismicSurface_t structure through two paths.
  * When the top-level structure (in Structure_t) is GSSurfaceSet_t, then
  * this top-level structure defines which surface is being modelled.  In
  * this case, it is an error to enter a different SurfaceSetName in the
  * GSSeismicSurface_t structure from the top-level SurfaceSetName.  When the
  * top-level structure is GSSeismicSurvey_t, then any number of
  * SurfaceSetNames are allowed in the GSSeismicSurface_t structure.  The two
  * questions being addressed are "Show all data representing this surface"
  * and "Show all data associated with this seismic survey".
  * 
  * Similarly, it is possible to reach GSWellMarker_t from either the
  * SurfacSet_t structure or the GSField_t structure.  As with seismic
  * horizons entered through the GSSurfaceSet_t structure, it is an error to
  * enter a different SurfaceSetName in the GSWellMarker_t structure from the
  * top-level SurfaceSetName.  When the top-level structure is GSField_t,
  * then any number of SurfaceSetNames are allowed in the GSWellMarker_t
  * structure.  The two questions being addressed are "Show all data
  * representing this surface" and "Show all data associated with this well".
  * 
  * On Shot Points, CDPs and Trace Numbers
  * 
  * There are at least three different coordinate systems used to describe
  * points along a seismic line.  The location of an energy source is
  * described as a shot point.  This point is given a (numeric) label, and
  * occasionally a reshot character.  There is no guarantee that the ordering
  * of shot points along a line are regular nor predictable. For each shot
  * there are many receivers.  Normally, these receivers correspond to the
  * location of shot points.
  * 
  * Depending  on how the seismic data are processed, one or more common depth
  * points are determined.  Often there are two CDPs per shot point, but this
  * can vary.  For straight lines, the location of some CDPs correspond to
  * shot point locations.  In the case of two CDPs per shot point, every
  * other CDP location would correspond to a shot point location.  There is
  * no convention for numbering these CDP locations, nor for relating them to
  * shot points.  In this file, a lookup/interpolation scheme is adopted.
  * 
  * When a set of traces are processed, they are sequentially numbered, usually
  * starting at one. These traces usually correspond one to one with a CDP.
  * There is usually a predictable relationship between trace number and CDP
  * number, but not necessarily between a trace number and a shot point.  Two
  * different trace files may not have the same relationship between trace
  * numbers and CDPs; this is especially true when different parts of a
  * seismic line are separately processed.
  * 
  * Since the location of a shot point is not dependent on a trace file, it is
  * modeled under the GSSeismicLine_t structure.  Also at this level are
  * recorded information which describes the near-surface characteristics and
  * datum information, i.e. any information which describes the earth at a
  * position without regard to seismic trace data processing.
  * 
  * Since seismic shot points are often regularly spaced and predictable, it is
  * not always necessary to explicitly store each shot point number and
  * location.  If intervening values can be calculated by simple linear
  * interpolation, then they do not have to be explicitly listed.  Any
  * structure which rerefers to a seismic station location can refer to the
  * GSSeismicLoc2d by an index number. This index may point directly to an
  * actual entry, or may refer to an entry which lies between two valid
  * entries.  In this way, points determined to lie between known locations
  * can be inferred, as when two surfaces intersect at a point other than a
  * shot point location.
  * 
  * On nulls
  * 
  * Each sender is responsible for setting a null value to be consistently used
  * for integers and floating point values.  The sender should always fill
  * unknown values with these constants when the data are not available.  The
  * receiver is obliged to always compare the data elements with the
  * receiver's null value to determine if the scalar contains a valid entry.
  * 
  * On strings
  * 
  * Character strings are represented as a vector with element_format =
  * GSV_CHAR, element_size = sizeof (CHAR) and number_elements = the number
  * of characters in the string NOT including any trailing null byte.  The
  * strings are NOT guaranteed to be null terminated.
  * 
  * On receiver specifications
  * 
  * The receiver is expected to state what data types it can support by using
  * the GSDataSupported_t structure component of the ReceiverSpecs_t
  * structure.  Additionally, the receiver specifies which of the detail
  * components of the top-level structure it can process.  This 'hint' can
  * then be used by the sender in preparing a data set for transmission.  For
  * instance, there is no need to perform a data selection on 3-D seismic
  * data if the receiver cannot support 3-D data.  It is still permitted to
  * send these data; the receiver should ignore any data it cannot process.
  * 
  * On status reporting
  * 
  * The receiver is responsible for providing two levels of status reporting:
  * problem or informational reporting to a user interface, and journalling
  * of results to a logging 'file'.  The former is used to inform the user of
  * a potential problem or exception condition that may require additional
  * interaction, and the latter is used to chronicle the successful
  * processing of information. It may be desirable to inform the user at a
  * specific terminal/workstation about a transfer status and to store
  * summary information in a central repository, such as the name of a file
  * that was used to store the information received.
  * 
  */

/********************************************************************/
/*                                                                  */
/*        Generally Used Typedefs                                       */
/*                                                                  */
/********************************************************************/

typedef long GSLongInt_t;    /* Long integer (usually 4 bytes) */
typedef float GSReal_t;	     /* Single precision floating point */
typedef double GSDP_t;	     /* Double precision floating point */
typedef unsigned long int GSUlong_t;	/* Unsigned long integer */
d127 2
a128 1
typedef long GSMask_t;	     /* Bit mask to identify item validity in structs*/
d130 2
a131 1
typedef struct {	     /* structure for a rational number */
d134 1
a134 1
}       GSRational_t;
d136 5
a140 6

/********************************************************************/
/*                                                                  */
/*        The Basic Building Block, the GSVector_t                      */
/*                                                                  */
/********************************************************************/
d142 2
a143 4
 /*
  * Basic to the interchange design is that of a vector structure which is
  * specified by the following declarations:
  */
d145 86
a230 71
typedef enum {
    GSV_UNKNOWN = 0,	     /* vector type is unknown, check extension */
 /* basic data types */
    GSV_INT = 10,	     /* vector type GSLongInt_t */
    GSV_REAL = 11,	     /* vector type GSReal_t */
    GSV_DP = 12,	     /* vector type GSDP_t */
    GSV_FRAC8 = 13,	     /* vector type 8 bit int fraction */
    GSV_FRAC16 = 14,	     /* vector type 16 bit int fraction */
    GSV_UNSIGNED_LONG = 15,  /* vector type GSUlong_t */
    GSV_BOOLEAN = 16,	     /* vector type GSBoolean_t */
    GSV_RATIONAL = 17,	     /* vector type GSRational_t */
    GSV_CHAR = 18,	     /* vector type char */
    GSV_COMPLEX = 19,	     /* vector type complex */
    GSV_STRING = 20,	     /* vector type GSString_t */
 /* executive structure vectors */
    GSV_RECEIVER_RQMTS = 100,/* vector type GSReceiverRqmts_t */
    GSV_DATA_SUPPORTED = 101,/* vector type GSDataSupported_t */
    GSV_GSSTRUCTURE = 102,   /* vector type GSStructure_t */
    GSV_RECEIVER_CONTEXT = 103,	/* vector type GSReceiverContext_t */
    GSV_STATUS_RETURN = 104, /* vector type GSStatusReturn_t */
 /* basic point structures */
    GSV_XYZ_POINT = 1000,    /* vector type GSXYZPoint_t */
    GSV_SEISMIC_DATA_POINT = 1001,	/* vector type GSSeismicDataPoint_t */
    GSV_MAP_LOCATION = 1002, /* vector type GSMapLocation_t */
    GSV_DEPTHS = 1003,	     /* vector type GSDepth_t */
    GSV_PROCESS_HISTORY = 1004,	/* vector type GSProcessHistory_t; */
 /* stratigraphic data structures */
    GSV_STRAT_COLUMN = 2000, /* vector type GSStratigraphicColumn_t */
    GSV_LITHOSTRAT_CODE_DESC = 2001,	/* vector type GSLithostratCodeDesc_t */
 /* zone structures */
    GSV_ZONE_VARIABLE_DEF = 3000,	/* vector type GSZoneVariableDefinition_t */
    GSV_ZONE_DEF = 3001,     /* vector type GSZoneDefinition_t */
    GSV_ZONE_VALUE = 3002,   /* vector type GSZoneValue_t */
 /* well structures */
    GSV_WELL_REMARKS = 4001, /* vector type GSWellRemarks_t */
    GSV_WELL_TUBULARS = 4002,/* vector type GSWellTubulars_t */
    GSV_WELL_PRODUCTION = 4003,	/* vector type GSWellProduction_t */
    GSV_WELL_MARKER = 4004,  /* vector type GSWellMarker_t */
    GSV_WELL_CORE = 4005,    /* vector type GSWellCore_t */
    GSV_WELL_ATTRIBUTE = 4006,	/* vector type GSWellAttribute_t */
    GSV_WELL_HDR = 4007,     /* vector type GSWellHdr_t */
    GSV_WELL_TEST_HDR = 4008,/* vector type GSWellTestHdr_t */
 /* well log structures */
    GSV_LOG_RUN = 5000,	     /* vector type GSLogRun_t */
    GSV_LOG_PASS = 5001,     /* vector type GSLogPass_t */
    GSV_LOG_SERVICE = 5002,  /* vector type GSLogService_t */
    GSV_LOG_TRACE = 5003,    /* vector type GSLogTrace_t */
 /* seismic data structures */
    GSV_SEISMIC_TRACE = 6000,/* vector type GSSeismicTrace_t */
    GSV_SEISMIC_CLASS = 6001,/* vector type GSSeismicClass_t */
    GSV_SEISMIC_LINE = 6002, /* vector type GSSeismicLine_t */
    GSV_SEISMIC_SURFACE = 6003,	/* vector type GSSeismicSurface_t */
    GSV_SEISMIC_TRANSDUCER = 6004,	/* vector type GSSeismicTransducer_t */
 /* map object structures */
    GSV_MAP_POLYLINE = 7000, /* vector type GSMapPolyline_t */
    GSV_MAP_POINT = 7001,    /* vector type GSMapPoint_t */
    GSV_MAP_SYMBOL = 7002,   /* vector type GSMapSymbol_t */
    GSV_MAP_ANNOTATION = 7003,	/* vector type GSMapAttribute_t */
    GSV_MAP_ATTRIBUTE = 7004,/* vector type GSMapAnnotation_t */
    GSV_MAP_OBJECTS = 7005,  /* vector type GSMapObjects_t */
    GSV_ATTRIBUTE_ITEM = 7006,	/* vector type GSAttributeItem_t */
 /* seismic interpretation surface structures */
    GSV_CONTACT = 8000,	     /* vector type GSContact_t */
    GSV_SEGMENT = 8001,	     /* vector type Segment_t */
 /* fault trace structures */
    GSV_FAULT_TRACE = 9000,  /* vector type FaultTrace_t */
    GSV_FAULT_SURFACE = 9001,/* vector type FaultSurface_t */
 /* surface executive structures */
    GSV_SURFACE_ATTRIBUTE = 10000,	/* vector type SurfaceAttribute_t */
    GSV_SURFACE_GEOMETRY = 10001	/* vector type SurfaceGeometry_t */
} GSVectorType_t;
d232 2
a233 1
typedef struct {
d239 1
a239 1
}       GSVector_t;
d241 2
a242 4
 /*
  * ALL strings will be stored as vectors,  the typedef GSString_t is defined
  * as a convenience and a vector type differentiator
  */
d246 9
a254 8
typedef GSString_t GSDate_t; /* Standard date format is YYYYMMDDHHMNNSS.SS
			      * YYYY from 0000 to 9999 (year) MM from 01 to
			      * 12 (month of year) DD from 01 to 31 (day of
			      * month) HH from 00 to 23 (hour of day) MN from
			      * 00 to 59 (minute of hour) SS.SS from 0 to
			      * 59.99(seconds in minute) Any component may be
			      * truncated (e.g.April 1987 is entered as
			      * 198704) */
d256 5
a260 5
/********************************************************************/
/*                                                                  */
/*        STRUCTURE VERSION STAMP                                   */
/*                                                                  */
/********************************************************************/
d262 8
a269 5
typedef struct {
    GSLongInt_t major_rev;   /* Major version number */
    GSLongInt_t minor_rev;   /* Minor version number of structure */
    GSString_t vendor;	     /* Vendor that provided latest revision */
}       GSVersion_t;
d271 5
a275 6

/********************************************************************/
/*                                                                  */
/*        Data Structure Typedefs                                       */
/*                                                                  */
/********************************************************************/
d277 3
a279 3
typedef GSLongInt_t GSNodeID_t;	/* node identifier */
typedef GSString_t GSPlotSymbol_t;	/* Graphics plot symbol name */
typedef GSString_t GSUWI_t;  /* Unique Well Identifier */
d281 3
a283 1
typedef GSString_t GSSurfaceSetName_t;	/* Name of a surface set */
d285 2
a286 2
/*
 *       Geophysical data types
d289 4
a292 4
typedef GSRational_t GSShotPoint_t;	/* Seismic shot point */
typedef GSRational_t GSCDP_t;/* Common depth point */
typedef GSRational_t GSLineNumber_t;	/* Seismic line number */
typedef GSReal_t GSStatic_t; /* Seismic static correction value */
d298 6
a303 5
typedef enum {
    GS_SRF_TYPE_UNKNOWN = 0, /* surface type unknown */
    GS_SRF_TYPE_HOR = 1,     /* surface type horizon */
    GS_SRF_TYPE_FLT = 2	     /* surface type fault */
} GSSurfaceType_t;
d305 8
a312 7
typedef enum {		     /* z value code */
    GS_Z_VALUE_UNDEFINED = 0,/* no z value is defined */
    GS_Z_VALUE_TIME = 1,     /* z value is time */
    GS_Z_VALUE_UNSNAPPED_TIME = 2,	/* z value is unsnapped time */
    GS_Z_VALUE_AMPLITUDE = 3,/* z value is amplitude */
    GS_Z_VALUE_DEPTH = 4     /* z value is depth */
} GSZValueCode_t;
d314 13
a326 12
typedef enum {
    GS_SNAP_P_NEAR = 1,	     /* nearest peak to center of window */
    GS_SNAP_P_MAX = 2,	     /* largest peak in window           */
    GS_SNAP_T_NEAR = 3,	     /* nearest trough to center of window */
    GS_SNAP_T_MAX = 4,	     /* largest trough in window         */
    GS_SNAP_ZPN = 5,	     /* zero crossing, positive to negative */
    GS_SNAP_ZNP = 6,	     /* zero crossing, negative to positive */
    GS_SNAP_NULL = 7,	     /* snap to input point */
    GS_SNAP_UNDEFINED = 8    /* undefined snap type */
} GSSnapEvent_t;
/*
 *      Seismic Line type
d329 7
a335 7
typedef enum {
    GS_LINE_2D = 30,	     /* line type 2d */
    GS_LINE_3DI = 31,	     /* line type 3d inline */
    GS_LINE_XLN = 32,	     /* line type 3d cross line */
    GS_LINE_TSL = 33,	     /* line type 3d time slice */
    GS_LINE_RANDOM = 34	     /* line type 3d random(reconstruction) cut */
} GSLineType_t;
d337 2
a338 2
/*
 *       Processing History structure
d340 2
a341 1
typedef struct {
d345 1
a345 1
}       GSProcessingHistory_t;
d348 1
a348 1
 *       amplitude statistics, used for seismic traces and lines
d351 5
a355 10
typedef struct {
    GSLongInt_t n_live;	     /* number of non-zero samples */
    GSReal_t max_amplitude;
    GSReal_t min_amplitude;
    GSReal_t max_magnitude;
    GSReal_t min_magnitude;
    GSReal_t rms_amplitude;
    GSReal_t mean_amplitude;
    GSReal_t mean_magnitude;
}       GSAmplitudeStats_t;
d358 1
a358 1
 *       variable for flagging whether a polyline is open or closed (a polygon)
d361 11
a371 4
typedef enum {
    GS_OPEN_POLYLINE = 0,
    GS_CLOSED_POLYGON = 1
} GSPolyLineType_t;
d373 5
a377 6

/********************************************************************/
/*                                                                  */
/*       MEASUREMENT TYPEDEFS                                       */
/*                                                                  */
/********************************************************************/
d379 1
a379 1
/*
d383 5
a387 4
typedef struct {
    GSString_t type;	     /* DISTANCE,TIME,VOLUME,WEIGHT,TEMPERATURE, etc */
    GSString_t unit;	     /* Unit (FEET, SECONDS) or expression (G/CC) */
}       GSUnit_t;
d389 6
a394 5
typedef struct {
    GSDP_t  value;	     /* value of measurement */
    GSUnit_t uom;	     /* unit of measure, including the measurement */
						 /* system and the actual unit */
}       GSMeasurement_t;
d396 10
a405 18
typedef GSMeasurement_t GSTemperature_t;	/* Special case of a measurement*/
											/* where uom.type = "TEMPERATURE"*/
typedef GSMeasurement_t GSResistivity_t;	/* Special case of a measurement*/
											/* where uom.type= "RESISTIVITY" */
typedef GSMeasurement_t GSTime_t;			/* Special case of a measurement*/
											/* where uom.type = "TIME" */
typedef GSMeasurement_t GSVelocity_t;		/* Special case of a measurement*/
											/* where uom.type = "VELOCITY" */
typedef GSMeasurement_t GSWeight_t;			/* Special case of a measurement*/
											/* where uom.type = "WEIGHT" */
typedef GSMeasurement_t GSDistance_t;		/* Special case of a measurement*/
											/* where uom.type = "DISTANCE" and*/
											/* implication that measurement is*/
											/* made in horizontal sense */
typedef GSMeasurement_t GSElevation_t;		/* Special case of a measurement*/
											/* where uom.type = "DISTANCE" and*/
											/* implication that measurement is*/
											/* made in vertical sense */
d407 6
a412 5
typedef struct {	     	/* structure describing reference elevation */
    GSElevation_t val;	    /* Elevation to use for subsea corrections */
    GSString_t ref;	     	/* Data type being used as elevation reference*/
			      			/* (KB, DF, GS, SL, etc) */
}       GSElevationRef_t;
d414 5
a418 6

/********************************************************************/
/*                                                                  */
/*       MASKS DEFINING VALIDITY OF ITEMS                           */
/*                                                                  */
/********************************************************************/
d421 9
a429 9
#define GSM_VALID_CDP          (1<<0)	/* cdp number is valid */
#define GSM_VALID_SP           (1<<1)	/* shot point number is valid */
#define GSM_VALID_X            (1<<2)	/* x location is valid */
#define GSM_VALID_Y            (1<<3)	/* y location is valid */
#define GSM_VALID_Z            (1<<4)	/* z location is valid */
#define GSM_VALID_LONGITUDE    (1<<5)	/* longitude is valid */
#define GSM_VALID_LATITUDE     (1<<6)	/* latitude is valid */
#define GSM_VALID_CONNECT      (1<<7)	/* connectivity vector in xyz scatter*/
										/* data */
d432 6
a437 9
#define GSM_VALID_MD           (1<<8)	/* measured depth is valid */
#define GSM_VALID_SUBDATUM     (1<<9)	/* subdatum depth is valid */
#define GSM_VALID_TVD          (1<<10)	/* true vertical depth is valid */
#define GSM_VALID_TIME         (1<<11)	/* time is valid */
#define GSM_VALID_DX           (1<<12)	/* deviation in x direction is valid */
#define GSM_VALID_DY           (1<<13)	/* deviation in y direction is valid */
/* Used in GSSeismicLoc2D_t */
#define GSM_VALID_CDP_PER_SP        (1<<0)		/* Nominal number of cdps per*/
											 	/* shot point */
d439 7
a445 27
#define GSM_VALID_CDP_1             (1<<1)	/* Initial cdp (index) number */
#define GSM_VALID_SHOT_POINT_1      (1<<2)	/* Initial shot point number */
#define GSM_VALID_CDP_INCR          (1<<3)	/* CDP numbering increment */
#define GSM_VALID_SHOT_POINT_INCR   (1<<4)	/* Shot point numbering increment */
#define GSM_VALID_MIN_SHOTPOINT     (1<<5)	/* minimum shotpoint */
#define GSM_VALID_MAX_SHOTPOINT     (1<<6)	/* maximum shotpoint */
#define GSM_VALID_MIN_RECEIVER      (1<<7)	/* minimum receiver location */
#define GSM_VALID_MAX_RECEIVER      (1<<8)	/* maximum receiver location */
#define GSM_VALID_MIN_CDP           (1<<9)	/* minimum cdp */
#define GSM_VALID_MAX_CDP           (1<<10)	/* maximum cdp */
/* Used in GSSeismicTraceHdr_t */
#define GSM_SHOT_W_STATIC_COMPUTED  (1<<0)	/* shot W statics computed */
#define GSM_SHOT_W_STATIC_APPLIED   (1<<1)	/* shot W statics applied */
#define GSM_RECE_W_STATIC_COMPUTED  (1<<2)	/* receiver W statics computed */
#define GSM_RECE_W_STATIC_APPLIED   (1<<3)	/* receiver W statics applied */
#define GSM_SHOT_D_STATIC_COMPUTED  (1<<4)	/* shot D static computed */
#define GSM_SHOT_D_STATIC_APPLIED   (1<<5)	/* shot D static applied */
#define GSM_RECE_D_STATIC_COMPUTED  (1<<6)	/* receiver D static computed */
#define GSM_RECE_D_STATIC_APPLIED   (1<<7)	/* receiver D static applied */
#define GSM_SHOT_A_STATIC_COMPUTED  (1<<8)	/* shot A static computed */
#define GSM_SHOT_A_STATIC_APPLIED   (1<<9)	/* shot A static applied */
#define GSM_RECE_A_STATIC_COMPUTED  (1<<10)	/* receiver A static computed */
#define GSM_RECE_A_STATIC_APPLIED   (1<<11)	/* receiver A static applied */
#define GSM_CDP_A_STATIC_COMPUTED   (1<<12)	/* cdp A static computed */
#define GSM_CDP_A_STATIC_APPLIED    (1<<13)	/* cdp A static applied */
#define GSM_BULK_STATIC_COMPUTED    (1<<14)	/* bulk static computed */
#define GSM_BULK_STATIC_APPLIED     (1<<15)	/* bulk static applied */
d447 5
a451 5
/****************************************************************/
/*                                                              */
/*       POINT STRUCTURES                                       */
/*                                                              */
/****************************************************************/
d453 7
a459 10
 /*
  * Other structures are basic to data interchange, that of a single point.
  * The following is the structure for a single point.  A mask will be
  * provided in association with each use of this structure (or vector of
  * this structure) indicating which components of the structure are valid.
  * For example, x and y may not be necessary to transfer interpretation.
  * Further the exact meaning of the elements of this structure will be
  * context dependent (i. e., the z element may contain a time value for
  * interpretation).
  */
d461 8
a468 7
typedef struct {
    GSMask_t valid;	     /* Validity mask for station vector:*/
						 /* GSM_VALID_X, GSM_VALID_Y, GSM_VALID_Z */
    GSDP_t  x;		     /* x coordinate value associated with point */
    GSDP_t  y;		     /* y coordinate value associated with point */
    GSDP_t  z;		     /* z coordinate value associated with point */
}       GSXYZPoint_t;
d470 10
a479 9
typedef struct {
    GSMask_t valid;	     		/* Validity mask for map point:*/
			      				/* GSM_VALID_LONGITUDE, GSM_VALID_LATITUDE */
    GSDP_t  longitude;	     	/* Longitude of map point, in decimal degrees */
    GSDP_t  latitude;	     	/* Latitude of map point, in decimal degrees */
    GSXYZPoint_t coord;	     	/* cartesian coordinates associated with map*/
			      				/* data point */
    GSNodeID_t node_id;	     	/* Node id */
}       GSMapLocation_t;
d481 14
a494 12
typedef struct {
    GSMask_t valid;	     		/* Validity mask for station vector:*/
								/* GSM_VALID_CDP, GSM_VALID_SP */
    GSCDP_t cdp;	     		/* common depth point number */
    union {
	GSShotPoint_t shot_point;	/* Shot Point Number associated with*/
								/* point (usually 2D) */
	GSLineNumber_t line_number;	/* seismic line number (Used for time*/
								/* slices and random sections) */
    }       y;
    GSMapLocation_t map_loc; /* location associated with cdp/shot point */
}       GSSeismicDataPoint_t;
d496 5
a500 3
 /*
  * Shot/receiver/cdp information table -----------------------------------
  */
d502 13
a514 10
typedef struct {	     /* for shot/receiver/cdp */
    GSSeismicDataPoint_t seismic_loc;	/* SP number, location & elevation */
    GSElevation_t datum;     /* elevation datum (used only if this line has a*/
			      			 /* floating datum) */
    GSElevation_t wdepth;    /* depth of weathering layer */
    GSVelocity_t wvel;	     /* velocity of weathering layer */
    GSStatic_t wstatic;	     /* weathering static */
    GSStatic_t dstatic;	     /* datum static */
    GSStatic_t astatic;	     /* automatic static */
}       GSSeismicTransducer_t;
d516 6
a521 4
typedef struct {
    GSDP_t  xmin;
    GSDP_t  ymin;
    GSDP_t  zmin;
d523 6
a528 4
    GSDP_t  xmax;
    GSDP_t  ymax;
    GSDP_t  zmax;
}       GSExtents_t;
d530 2
d533 29
a561 5
/********************************************************************/
/*                                                                  */
/*       Projection & Spheroid Information Structures               */
/*                                                                  */
/********************************************************************/
d563 9
a571 9
 /*
  * Projection Information ----------------------
  * 
  * We will assume all location information contained within a data structure is
  * given in the same coordinate system.  To properly define the coordinate
  * system the following two structures are used to specify the projection
  * which was used.  the structures are based on the USGS projection package.
  * and the projection codes are those used by USGS.
  */
d573 1
a573 1
 /****************************************************************
a574 5
   This file defines the proposed cartographic parameter structure for
   use with 'geoscience.h'.

 ****************************************************************/

d579 10
a588 2
 /*********************************************************************
  Definition of Transformation Parameter Fields by Projection Type Code
d590 5
a594 241
  Type 0
      No parameters are required for this reference system.

  Type 1
      1 = Semimajor axis of ellipsoid; if '0.0', the value for Clarke's 1966
          spheroid in meters will be assumed.
      2 = Eccentricity squared of ellipsoid.  If '0.0', a sphere is indicated.
          If > '1.0', field contains semiminor axis of ellipsoid.
      3 = Longitude of any point within the zone.
      4 = Latitude of any point within the UTM zone.

      Parms 3 & 4 will be used to determine UTM zone number when a zone
      number of '0' is specified.

  Type 2
      1 = Semimajor axis of ellipsoid; if '0.0', the value for Clarke's 1966
          spheroid in meters will be assumed.
      2 = Eccentricity squared of ellipsoid.  If '0.0', a sphere is indicated.
          If > '1.0', field contains semiminor axis of ellipsoid.

  Type 3,4
      1 = Semimajor axis of ellipsoid; if '0.0', the value for Clarke's 1966
          spheroid in meters will be assumed.
      2 = Eccentricity squared of ellipsoid.  If '0.0', a sphere is indicated.
          If > '1.0', field contains semiminor axis of ellipsoid.
      3 = Latitude of first standard parallel.
      4 = Latitude of second standard parallel.
      5 = Longitude of central meridian.
      6 = Latitude of projection's origin.
      7 = False easting.
      8 = False northing.

  Type 5,7
      1 = Semimajor axis of ellipsoid; if '0.0', the value for Clarke's 1966
          spheroid in meters will be assumed.
      2 = Eccentricity squared of ellipsoid.  If '0.0', a sphere is indicated.
          If > '1.0', field contains semiminor axis of ellipsoid.
      5 = Longitude of central meridian.
      6 = Latitude of projection's origin.
      7 = False easting.
      8 = False northing.

  Type 6
      1 = Semimajor axis of ellipsoid; if '0.0', the value for Clarke's 1966
          spheroid in meters will be assumed.
      2 = Eccentricity squared of ellipsoid.  If '0.0', a sphere is indicated.
          If > '1.0', field contains semiminor axis of ellipsoid.
      5 = Longitude directed straight down below pole of map.
      6 = Latitude of true scale.
      7 = False easting.
      8 = False northing.

  Type 8
      Case A - Single Standard Parallel
      1 = Semimajor axis of ellipsoid; if '0.0', the value for Clarke's 1966
          spheroid in meters will be assumed.
      2 = Eccentricity squared of ellipsoid.  If '0.0', a sphere is indicated.
          If > '1.0', field contains semiminor axis of ellipsoid.
      3 = Latitude of standard parallel.
      5 = Longitude of central meridian.
      6 = Latitude of projection's origin.
      7 = False easting.
      8 = False northing.
      9 = 0.0

      Case B - Two Standard Parallels
      1 = Semimajor axis of ellipsoid; if '0.0', the value for Clarke's 1966
          spheroid in meters will be assumed.
      2 = Eccentricity squared of ellipsoid.  If '0.0', a sphere is indicated.
          If > '1.0', field contains semiminor axis of ellipsoid.
      3 = Latitude of first standard parallel.
      4 = Latitude of second standard parallel.
      5 = Longitude of central meridian.
      6 = Latitude of projection's origin.
      7 = False easting.
      8 = False northing.
      9 = Any non-zero number.

  Type 9
      1 = Semimajor axis of ellipsoid; if '0.0', the value for Clarke's 1966
          spheroid in meters will be assumed.
      2 = Eccentricity squared of ellipsoid.  If '0.0', a sphere is indicated.
          If > '1.0', field contains semiminor axis of ellipsoid.
      3 = Scale factor at central meridian.
      5 = Longitude of central meridian.
      6 = Latitude of origin.
      7 = False easting.
      8 = False northing.

  Type 10
      1 = Radius of the sphere of reference.  If this field is '0.0', the value
          6370997.0 meters will be assumed.  This  the radius of a sphere with
          surface area equal to that of Clarke's 1866 ellipsoid.
      5 = Longitude of center of projection.
      6 = Latitude of center of projection.
      7 = False easting.
      8 = False northing.

  Type 11,12,13,14
      1 = Radius of the sphere of reference.  If this field is '0.0', the value
          6370997.0 meters will be assumed.
      5 = Longitude of center of projection.
      6 = Latitude of center of projection.
      7 = False easting.
      8 = False northing.

  Type 15
      1 = Radius of the sphere of reference.  If this field is '0.0', the value
          6370997.0 meters will be assumed.
      3 = Height of perspective point above sphere.
      5 = Longitude of center of projection.
      6 = Latitude of center of projection.
      7 = False easting.
      8 = False northing.

  Type 16,18,19
      1 = Radius of the sphere of reference.  If this field is '0.0', the value
          6370997.0 meters will be assumed.
      5 = Longitude of central meridian.
      7 = False easting.
      8 = False northing.

  Type 17
      1 = Radius of the sphere of reference.  If this field is '0.0', the value
          6370997.0 meters will be assumed.
      5 = Longitude of central meridian.
      6 = Latitude of true scale.
      7 = False easting.
      8 = False northing.

  Type 20
      Format A
      1 = Semimajor axis of ellipsoid; if '0.0', the value for Clarke's 1966
          spheroid in meters will be assumed.
      2 = Eccentricity squared of ellipsoid.  If '0.0', a sphere is indicated.
          If > '1.0', field contains semiminor axis of ellipsoid.
      3 = Scale factor at center of projection.
      6 = Latitude of origin of projection.
      7 = False easting.
      8 = False northing.
      9 = Longitude of first point defining central geodetic line of projection.
     10 = Latitude of first point defining central geodetic line of projection.
     11 = Longitude of second point defining central geodetic line of projection.
     12 = Latitude of second point defining central geodetic line of projection.
     13 = 0.0

      Format B
      1 = Semimajor axis of ellipsoid; if '0.0', the value for Clarke's 1966
          spheroid in meters will be assumed.
      2 = Eccentricity squared of ellipsoid.  If '0.0', a sphere is indicated.
          If > '1.0', field contains semiminor axis of ellipsoid.
      3 = Scale factor at center of projection.
      4 = Angle of azimuth east of north for central line of projection.
      5 = Longitude of point along central line of projection at which
          angle of azimuth is measured.
      6 = Latitude of origin of projection.
      7 = False easting.
      8 = False northing.
     13 = Any non-zero number.


  **********************************************************************
  Definitions of Known Projection Type Codes

      0  "Geographic"               11  "Lambert Azim. Equal Area"
      1  "Universal Transverse Mercator"
                                    12  "Azimuthal"
      2  "State Plane"              13  "Gnomonic"
      3  "Albers Conical Equal Area"14  "Orthographic"
      4  "Lambert Conformal Conic"  15  "General Vertical Near-Side Perspective"
      5  "Mercator"                 16  "Sinusoidal"
      6  "Polar Stereographic"      17  "Equi-Rectangular"
      7  "Polyconic"                18  "Miller Cylindrical"
      8  "Equidistant Conic"        19  "Van der Grinten"
      9  "Transverse Mercator"      20  "Oblique Mercator"
     10  "Stereographic"

  **********************************************************************
  Definitions of Known Projection Units

          1    "Feet"                4    Degrees of Arc
          2    "Meters"              5    Packed DMS
          3    "Seconds of Arc"

      DMS - packed degrees-minutes-seconds:
          +/-DDDMMSS.SSSSS

      where
          DDD is the degrees portion of the angle.
          MM is the minutes portion of the angle.
          SS.SSSSS is the seconds portion of the angle.

      The plus sign is optional.  Leading and trailing zeros are optional,
      but embedded zeros must be supplied.

  **********************************************************************
  Definitions of Zone Codes

      UTM - Standard zones 1-60.
      State Plane - USGS identification codes.
      Other - See notes with Projection Types.

  **********************************************************************
  Projection Name Field

      Normally, the projection names referenced above with the projection
      codes are included in this field.

  **********************************************************************
  Definitions of Known Spheroid Codes

          0    "Clarke 1866"        10    "Modified Everest"
          1    "Clarke 1880"        11    "Modified Airy"
          2    "Bessel 1841"        12    "Walbeck"
          3    "International 1967" 13    "Southeast Asia"
          4    "International 1909" 14    "Australian National"
          5    "WGS 72"             15    "Krassovsky"
          6    "Everest"            16    "Hough"
          7    "WGS 66"             17    "Mercury 1960"
          8    "GRS 1980"           18    "Modified Mercury 1968"
          9    "Airy"               19    "Sphere of Radius 6370997"

  *********************************************************************/

typedef struct {	     /* Projection Structure Type */
    GSDP_t  parms[15];	     /* Transformation Parameters */
    GSLongInt_t projection_type;	/* USGS(or equiv) Projection Type Code */
    GSLongInt_t projection_unit;	/* UOM for Projection. NOTE: NOT used*/
									/* in other uom character string*/
									/* structures... */
    GSLongInt_t zone_code;   /* UTM or US State Plane Zone */
    GSLongInt_t spheroid_code;	/* USGS (or equiv) Spheroid Code */
    GSString_t proj_name;    /* Projection Name (description) */
}       GSCartoProjection_t;


/********************************************************************/
/*                                                                  */
/*         Surface Geometry Representations                         */
/*                                                                  */
/********************************************************************/
d596 3
a598 3
 /*
  * xyz scatter Information -----------------------
  */
d600 4
a603 3
typedef struct {
    GSSurfaceSetName_t surface_set_name;	/* Surface set name */
    GSString_t attribute;    /* name of the attribute being modelled */
d605 7
a611 5

    GSVector_t x;	     /* Vector of x-coordinate values (4 or 8 byte floats)*/
    GSVector_t y;	     /* Vector of y-coordinate values (4 or 8 byte floats)*/
    GSVector_t z;	     /* Vector of z-values (4 or 8 byte floats) */

d613 15
a627 12
    GSVector_t connect;	     /* Connectivity vector.  If sequences of data
			      * points are intended to be connected together,
			      * then this vector will be filled.  Normally,
			      * this would take the form of one 'connect'
			      * value for each x,y,z value and would consist
			      * of sequential integer values. All points
			      * intended to be grouped together would have
			      * the same 'connect' value. '0' would indicate
			      * a scatter point not connected to any other
			      * point.  This vector need not be filled for no
			      * connected data values. (4 byte integer) */
}       GSXYZData_t;
d629 48
d678 3
a680 4
 /*
  * Grid Information ----------------
  */
typedef struct {
d682 4
a685 12
 /*
  * Basic grid parameters: xmin, ymin, xmax, ymax, row-grid distance,
  * col-grid distance Note: range values in order min-to-max.  Positive row
  * increment for non-rotated grid assumed to increase in positive
  * y-direction. Positive column increment for non- rotated grid assumed to
  * increase in positive x-direction.  Varying the sign of the row,col
  * increments is the mechanism for systems utilizing some corner of the grid
  * other than the lower left corner as the grid origin.
  */

    GSSurfaceSetName_t surface_set_name;	/* Surface set name */
    GSString_t attribute;    /* name of the attribute being modelled */
d687 33
a719 3

    GSDistance_t row_distance;	/* distance between rows */
    GSDistance_t col_distance;	/* distance between columns */
d721 5
a725 69
    GSReal_t angle;	     	/* Grid rotation angle measured from the*/
						  	/* horizontal.  Angles are in degrees and open*/
						  	/* positively in the counter clockwise*/
						  	/* direction. */
    GSLongInt_t nrows;	    /* Number of rows in the grid. */
    GSLongInt_t ncols;	    /* Number of columns in the grid. */
    GSBoolean_t fl_honored; /* Faults honored during gridding flag. FALSE:*/
			      			/* Fault information not used. TRUE: Fault*/
			      			/* information was used. */
    GSVector_t zvals;	    /* Grid values: Storage order is row 1 to row*/
			      			/* 'nrows' of column 1 followed by the row*/
			      			/* values of columns 2 through column 'ncols'*/
			      			/* element_format = GSV_REAL; element_size =*/
			      			/* either sizeof (GSReal_t) or sizeof (GSDP_t) */

    GSMask_t valid;	     	/* Validity mask for existence of xvals and*/
			      			/* yvals that follow (GSM_VALID_X or*/
			      			/* GSM_VALID_Y) */

 /*
  * For the following two vectors, element_format = GSV_REAL; element_size =
  * either sizeof (GSReal_t) or sizeof (GSDP_t)
  */
    GSVector_t xvals;	     /* x-values corresponding to z-values */
    GSVector_t yvals;	     /* y-values corresponding to z-values */
}       GSGrid_t;


 /*
  * Contour Information -------------------
  */

typedef struct {
    GSSurfaceSetName_t surface_set_name;	/* Surface set name */
    GSString_t attribute;    /* name of the attribute being modelled */
    GSUnit_t z_unit;

    GSLongInt_t inc_type;    	/* Type contour incrementing used. 0: User*/
			      				/* specified contour range defined by low*/
			      				/* contour value, high contour value & contour*/
			      				/* increment. n: n-contour values specified*/
			      				/* explicitly by value. */
    GSVector_t inc_levels;   	/* Vector of user specified contour lvls. The*/
			      				/* number of levels does not necessarily match*/
			      				/* the actual z values See 'inc_type' above. */
								/*(4 or 8 byte float) */

    GSVector_t z_vals;	     /* Z-values for each contour segment stored. The*/
			      			/* number of Z values matches the number of*/
			      			/* segments described in the endpts vector.  The*/
			      			/* number of Z values does not necessarily match*/
			      			/* the number of levels described in inc_levels*/
			      			/* (4 or 8 byte float) */
    GSVector_t endpts;	     /* Vector of zero-based indices in*/
			      			/* x,y-coordinate arrays where each contour*/
			      			/* segment terminates.  Each value stored in*/
			      			/* 'endpts' is associated with the corresponding*/
			      			/* contour level stored in 'z_vals'. */
							/* (4 byte * integer) */
    GSVector_t x;	   /* Vector of contour x-coord vals (4 or 8 byte floats) */
    GSVector_t y;	   /* Vector of contour y-coord vals (4 or 8 byte floats) */
}       GSContour_t;


/********************************************************************/
/*                                                                  */
/*     Seismic Geometry Specification and Location Structures       */
/*                                                                  */
/********************************************************************/
d727 9
a735 4
 /*
  * 2-D Survey Geometry Specification and Location
  * ----------------------------------------------
  */
d737 3
a739 42
typedef struct {
    enum {
	GS_REGULAR_CORRESP = 0,
	GS_SEMI_REGULAR_CORRESP = 1,
	GS_IRREGULAR_CORRESP = 2
    } cdp_sp_reg_flag;	     /* Flag indicates whether or not a regular*/
			      /* correspondence exists between cdp and sp */
    GSRational_t cdp_per_sp; /* Nominal number of cdps per shot point */
    GSDistance_t shotpoint_interval;	/* Distance between shot points */
    GSCDP_t cdp1;	     /* Initial cdp (index) number */
    GSShotPoint_t sp1;	     /* Initial shot point number */
    GSCDP_t cdpinc;	     /* CDP numbering increment */
    GSShotPoint_t spinc;     /* Shot point numbering increment */
    GSVector_t seismic_transducer;		/* Vector of station location*/
										/* structures This information*/
										/* describes the field data for the*/
										/* seismic line without regard to any*/
										/* seismic data processing. It is*/
										/* usually obtained from a 'UKOOA'*/
										/* file. The entries in this vector*/
										/* are ordered geographically, such*/
										/* that traversing the vector never*/
										/* causes a segment on the earth's*/
										/* surface to be passed over more*/
										/* than once (Not used for surface*/
										/* set - use Segment_t list) */
}       GSSeismicLoc2D_t;

 /*
  * 3-D Survey Geometry Specification and Location
  * ----------------------------------------------
  * 
  * The following structure contains the information necessary to specify a 3d
  * survey.  If the survey does not exist in the receiving system all of the
  * information must be provided.  The survey is assumed to be laid out as a
  * regular orthogonal grid of traces so that knowing the location of one
  * trace, the trace and line spacing, and the azimuth of the primary lines
  * one can compute the location of all of the traces.
  */

typedef struct {
 /* the following are survey geometry specifications */
d741 19
d761 5
a765 25
 /*
  * grid defines the geometry representation of the 3D survey, including the
  * ground distance and the number of values in X and Y. Usually the X and Y
  * vectors of the GSGrid_t are not used.
  */
    GSLineNumber_t lin1;     /* line # of origin inline line (rational) */
    GSLineNumber_t lininc;   /* line number incr (rational) */
    GSLongInt_t number_inlines;	/* number of inlines in survey */
    GSCDP_t cdp1;	     /* origin cdp on inline lines.(rational) */
    GSCDP_t cdpinc;	     /* cdp incr. on inline lines (rational) */
    GSLongInt_t number_cdps; /* number of cdps in each inline */
    GSShotPoint_t sp1;	     /* sp of survey origin (rational) */
    GSShotPoint_t spinc;     /* sp incr. of survey  (rational) */

 /* the following are coordinates with which to locate the survey */
 /* Enter in a clockwise sense; DO NOT assume grid is orthonormal */
    GSSeismicDataPoint_t loc[4];
}       GSSeismicLocation3D_t;


/********************************************************************/
/*                                                                  */
/*            Seismic Survey Structures                             */
/*                                                                  */
/********************************************************************/
d767 6
a772 8
 /*
  * Seismic Data Structures -----------------------
  * 
  * Seismic data will be contained in the interchange structure as a seismic
  * line header structure and a vector of trace structures.  The trace
  * structure contains a trace header structure and a vector of sample
  * values.
  */
d774 43
a816 5
 /*
  * Processed Seismic Line Header -----------------------------
  */
typedef struct {
    GSUnit_t si_unit;	     /* units for sampling interval */
a817 6
    enum {
	GS_TRACE_ORDER_SHOT = 1,	/* shot ordered */
	GS_TRACE_ORDER_CDP = 2,	/* unstacked cdps */
	GS_TRACE_ORDER_STACK = 3,	/* stacked cdps */
	GS_TRACE_ORDER_SEQ = 4	/* trace sequential */
    } trace_order;	     /* Trace ordering */
d819 7
a825 1
    GSUnit_t to_unit;	     /* trace offset units */
d827 9
a835 59
    GSBoolean_t offset_validity;	/* TRUE = offsets are valid */

    GSDistance_t trail_offset;	/* trailing trace offset */
    GSDistance_t lead_offset;/* leading trace offset */
    GSDistance_t near_offset;/* ABS near trace offset */
    GSDistance_t far_offset; /* ABS far trace offset */

    GSReal_t sample_interval;/* sampling rate */
    GSLongInt_t n_samples;   /* maximum number of samples per trace */
    GSLongInt_t n_live_traces;	/* number of live traces */

    GSLongInt_t n_channels;  /* number of channels per record  (1) */
    GSLongInt_t n_fold;	     /* stack fold (no. of traces per cdp) */

    GSDistance_t cdp_interval;	/* distance between cdps for this processed*/
								/* line (may be different than survey design)*/

    GSShotPoint_t min_shotpoint;	/* minimum shotpoint */
    GSShotPoint_t max_shotpoint;	/* maximum shotpoint */
    GSRational_t min_receiver;	/* minimum receiver location */
    GSRational_t max_receiver;	/* maximum receiver location */
    GSCDP_t min_cdp;	     /* minimum cdp */
    GSCDP_t max_cdp;	     /* maximum cdp */

    GSRational_t cdp_incr;   /* cdp number increment per trace (zero if invalid) */
    GSRational_t shotpoint_incr;	/* shotpoint increment per trace (zero if invalid) */

    GSVector_t shot_info_table;	/* type GSShotPoint_t which tie into the */
				/* GSSeismicLoc2d_t vector in the GSSeismicLine_t structure */
    GSVector_t receiver_info_table;	/* type GSShotPoint_t which tie into*/
					 /* the GSSeismicLoc2d_t vector in the*/
					 /* GSSeismicLine_t structure */

    GSAmplitudeStats_t line_amplitude;	/* line amplitude statistics */

    enum {
	GS_NO_MIGRATION = 0,
	GS_PRESTACK_MIGRATION = 1,
	GS_POSTSTACK_MIGRATION = 2
    } migration_type;

}       GSSeismicLineHdr_t;


 /*
  * Velocity structures --------------------
  */
typedef struct {
    GSReal_t z;		     /* time or depth */
    GSReal_t value;	     /* velocity measurement at this time or depth */
}       GSVelocityPair_t;

typedef struct {
    enum {
	GS_STACKING_VELOCITY = 1,
	GS_AVERAGE_VELOCITY = 2,
	GS_PSEUDO_VELOCITY = 3,
	GS_INTERVAL_VELOCITY = 4
    } velocity_type;
d838 2
a839 2
    GSVector_t velocity_pair;/* List of time/velocity or depth/velocity pairs */
}       GSSeismicVelocity_t;
d841 2
d844 14
a857 16
 /*
  * Trace (including header) ------------------------
  */

typedef struct {
 /**** trace header ****/
    enum {
	GS_DEAD_TRACE = -1,
	GS_LIVE_TRACE = 1,
	GS_SWEEP_TRACE = 2,
	GS_NULL_TRACE = 3
    } trace_type;	     /* activity of trace (live, dead, etc) */

    GSLongInt_t record_no;   /* sequential record number */
    GSLongInt_t record_trace_no;	/* record trace number */
    GSLongInt_t field_record_no;	/* field record number */
d859 24
d884 12
a895 4
    GSCDP_t cdp;	     /* common midpoint number (cmp) */
    GSLongInt_t cdp_trace_no;/* cdp trace number */
    GSShotPoint_t cdp_sp;    /* shotpoint corresponding to this cdp */
    GSLongInt_t cdp_fold;    /* stacking fold at this cdp */
d897 14
a910 4
    GSLongInt_t mute_length; /* length of initial mute is samples */
    GSReal_t tfs;	     /* time of first sample in sample units */
    GSStatic_t bulk_static;  /* bulk static */
    GSAmplitudeStats_t trace_amplitude;	/* trace amplitude statistics */
d912 2
a913 2
    GSReal_t minimum_scalar; /* scalar values used in scaling data to */
    GSReal_t maximum_scalar; /* fraction values */
d915 10
a924 2
    GSVector_t seismic_velocity;	/* vector of seismic velocity
					 * functions */
d926 5
a930 1
 /**** trace samples ****/
d932 10
a941 4
    GSVector_t samples;	     /* Vector of seismic trace samples (see vector
			      * descriptor for sample format) - (Note: no
			      * corresponding Samples_t exists) */
}       GSSeismicTrace_t;
d943 4
d948 1
a948 14
 /*
  * Line Description Structure --------------------------
  * 
  * All surveys are organized as a series of lines and the survey structure
  * includes a vector of line structures of the following form.  Each line
  * may have several variants usually depending on any processes which have
  * been applied to the data to alter its presentation or to extract some
  * quality of interest. Therefore the line structure contains location
  * information and a vector of classes.  There may be many types of data
  * related to a line class.  Each type will have a structure ( or vector of
  * structures ) in which that type of data is stored.  Included in the
  * current proposal is a vector of interpreted surfaces and seismic trace
  * data.
  */
d950 25
a974 10
typedef struct {
    GSLineType_t line_type;  /* Seismic Line type */
    GSString_t line_name;    /* 2d or reconstruction cut line name */
    GSLongInt_t line_number; /* Line number (required for GS_LINE_3DI,
			      * GS_LINE_TSL, GS_LINE_XLN) */
    GSString_t line_desc;    /* Line description */
    GSVector_t seismic_class;/* Vector of seismic line variants delineated
			      * according to class */
    GSSeismicLoc2D_t loc2d;  /* GS_LINE_2D, GS_LINE_RCN types only */
}       GSSeismicLine_t;
d976 4
a979 3
 /*
  * GSSeismic Class structure -----------------------
  */
d981 6
a986 48
typedef struct {
    GSString_t class_name;   /* User assigned class name */
    GSString_t class_desc;   /* Class description */
    GSSeismicLineHdr_t seismic_line_hdr;	/* Structure containing
						 * seismic line header */
    GSVector_t seismic_trace;/* Vector of GSSeismicTrace_t */
    GSVector_t seismic_surface;	/* Vector of GSSeismicSurface_t */
    GSVector_t processing_history;	/* Seismic trace file processing
					 * history */
}       GSSeismicClass_t;


/****************************************************************/
/*                                                              */
/*              SEISMIC SURFACE STRUCTURES                      */
/*                                                              */
/****************************************************************/

 /*
  * It will be assumed that there are two basic types of surfaces, horizons
  * and faults (or fault cuts).  Along any line there may be line segments
  * indicating where the surface has been interpreted and there may be
  * information indicating where two surfaces contact each other.
  * Additionally, the segments may have different data depending on the z
  * value contained therein.  For example, the user may have interpreted a
  * horizon along a range of cdps and saved the time values at which the
  * horizon occured.  He may have also saved the seismic trace amplitude at
  * that time.  Segments containing both time and containing amplitude may be
  * stored for a given surface.
  */

 /*
  * This structure contains information specifying points along the surface
  * at which the user has indicated that it intersects another surface.  The
  * structure includes the location of the intersection and information about
  * the intersecting structure.
  */

typedef struct {
    GSSurfaceType_t surface_type;	/* Surface type: GS_SRF_TYPE_HOR,
					 * GS_SRF_TYPE_FLT */
    GSSurfaceSetName_t surface_set_name;	/* Surface set name */
    GSUnit_t z_uom;	     /* Unit of measurement for z */
    GSString_t source;	     /* Name of interpreter or source of data */
    GSString_t surface_desc; /* Surface description */
    GSDate_t modified_date;  /* date this surface was last modified */

 /* The following are applicable only to horizon surfaces */
d988 5
a992 5
    GSReal_t snap_window;    /* Duration of snapping window in seconds */
    GSVector_t segment;	     /* Vector of interpretation segments for line */
    GSVector_t contact;	     /* Vector of contact points associated with this
			      * surface on this line */
}       GSSeismicSurface_t;
d994 19
a1012 7
typedef struct {
    GSSeismicDataPoint_t contact_loc;	/* location of contact point */
    GSSurfaceType_t surface_type_2;	/* Surface type: GS_SRF_TYPE_HOR,
					 * GS_SRF_TYPE_FLT,
					 * GS_SRF_TYPE_UNKNOWN */
    GSSurfaceSetName_t name_2;	/* second name associated with contact */
}       GSContact_t;
d1014 3
a1016 2
typedef struct {
    GSLongInt_t seg_id;	     /* Number identifying segment */
d1018 2
a1019 3
    GSVector_t seismic_data_point;	/* Vector of points in interpretation
					 * segment */
}       GSSegment_t;
d1021 5
a1025 6

/********************************************************************/
/*                                                                  */
/*              FAULT TRACE STRUCTURES                              */
/*                                                                  */
/********************************************************************/
d1027 13
a1039 12
 /*
  * Fault traces are interpreted information defining the map view of the
  * intersection of faults with a particular surface.  The interpretation is
  * usually done on a map and cannot be organized on a line by line basis or,
  * for that matter, on a survey basis.  Fault trace interpretation,
  * therefore, must be kept in a structure separate from the survey structure
  * described above and transmitted seperately.  The following structures
  * will be used to contain and transmit fault trace information.  The top
  * structure contains information necessary to define the coordinate system
  * of the data contained in the structure and a vector of surface structures
  * for which fault trace information is transmitted.
  */
d1041 2
a1042 4
 /*
  * Each surface may have intersections with many faults.  The following
  * structure names a vector of fault traces for a specified surface.
  */
d1044 7
a1050 5
typedef struct {
    GSSurfaceSetName_t surface_set_name;	/* Name of surface for which
						 * traces are defined */
    GSVector_t fault_trace;  /* Vector of structures defining fault traces */
}       GSFaultSurface_t;
d1052 2
a1053 5
 /*
  * The following fault trace vector specifies the name of the intersecting
  * fault and names the vector containing the points associated with the
  * intersection.
  */
d1055 8
a1062 11
typedef struct {
    GSSurfaceSetName_t fault_name;	/* Name of fault whose intersection
					 * with the surface this trace
					 * describes */
    GSLongInt_t ft_seg_id;   /* segment id for fault trace for a given
			      * surface */
    GSZValueCode_t z_value_code;
    GSPolyLineType_t open_closed;
    GSVector_t map_location; /* Vector of structures defining fault trace
			      * points */
}       GSFaultTrace_t;
d1064 5
a1068 6

/********************************************************************/
/*                                                                  */
/*              SURFACE  STRUCTURES                                 */
/*                                                                  */
/********************************************************************/
d1070 18
a1087 15
typedef struct {
    enum {
	GS_REP_NONE,
	GS_REP_GRID,
	GS_REP_CONTOUR,
	GS_REP_CONSTANT,
	GS_REP_XYZ
    }       type;
    union {
	GSGrid_t grid;
	GSXYZData_t xyz;     /* 'Scatter' data file */
	GSMeasurement_t constant;
	GSContour_t contour;
    }       data;
}       GSSurfaceRepresentation_t;
d1089 5
a1093 4
typedef struct {
    GSString_t attribute;    /* name of the attribute being modelled */
    GSVector_t surface_representation;	/* list of attribute representations */
}       GSSurfaceAttribute_t;
d1095 11
a1105 15
typedef struct {
    GSExtents_t extent;	     /* XYZ spanning extent of data set */
    GSSurfaceRepresentation_t time_representation;	/* set of coordinates
							 * describing the
							 * geometry of the
							 * surface in time */
    GSSurfaceRepresentation_t depth_representation;	/* set of coordinates
							 * describing the
							 * geometry of the
							 * surface in depth */
    GSVector_t surface_attribute;	/* List of attributes for this
					 * surface which correspond to, or
					 * are measured at, the geometry
					 * specified in either time or depth */
}       GSSurfaceGeometry_t;
d1107 2
a1108 25
 /********************************************************************
   This structure describe the intersection between a seismic line
   and a surface set. As such it provides information about both
   entities.It originates from the SeismicSurface structure whose name
   has been changed to be more meaningful
 ********************************************************************/

typedef struct {
    GSSurfaceSetName_t surface_set_name;	/* name of the surface set
						 * intersected */
    GSUnit_t z_uom;	     /* Unit of measurement for z */
    GSString_t source;	     /* Name of interpreter or source of data */
    GSString_t line_name;    /* Line identifier */
    GSString_t surface_desc; /* Surface description */
    GSDate_t modified_date;  /* date this surface was last modified */
 /* The following are applicable only to horizon surfaces */
    GSSnapEvent_t snap_event;/* Valid only for horizons */
    GSReal_t snap_window;    /* Duration of snapping window in seconds */
    GSVector_t segment;	     /* Vector of interpretation segments for line   */
    GSVector_t contact;	     /* Vector of contact points associated with the
			      * surface on this line */
}       GSLineIntersection_t;

 /********************************************************************
   This structure describe the intersection between a surface set and
d1110 1
a1110 1
   fault trace set structure. It should be more general and cover also
d1114 2
a1115 1
typedef struct {
d1117 2
a1118 3
    GSVector_t xyz_point;    /* Vector of structures defining surface trace
			      * points */
}       GSSurfaceTrace_t;
d1120 5
a1124 6
typedef struct {
    GSSurfaceSetName_t surface_set_name;	/* Name of intersecting
						 * surface set (horizon or
						 * fault) */
    GSVector_t surface_trace;/* Vector of structures defining traces */
}       GSSurfaceSurfaceIntersection_t;
d1126 11
a1136 9
typedef struct {	     /* new object pointed from GSSurfaceSet_t */
    GSSurfaceSetName_t surface_set_name;	/* name of the surface set
						 * intersected */
    GSVector_t line_intersection;	/* Vector of section interpretation */
    GSVector_t well_marker;  /* Vector of GSWellMarker */
    GSVector_t seismic_well_tie;	/* Vector of GSSeismicWellTie */
    GSVector_t surface_surface_intersection;	/* vector of surface surface
						 * intersections */
}       GSSurfaceIntersection_t;
d1138 5
d1144 2
a1145 5
/************************************************************************/
/*                                                                      */
/*                   MAP STRUCTURES                                     */
/*                                                                      */
/************************************************************************/
d1147 3
a1149 8
 /*
  * Attribute Information For Map Objects
  * -------------------------------------
  * 
  * Each map object defined in a mapping database can have associated
  * non-graphic attribute information.  This is simply a list of name-value
  * pairs which are carried along with the map object.
  */
d1151 5
a1155 4
typedef struct {
    GSString_t item_name;    /* name of attribute */
    GSMeasurement_t item_value;	/* value and unit of measure of attribute */
}       GSAttributeItem_t;
d1157 2
a1158 7
 /*
  * Data Source For Map Data ------------------------
  * 
  * It is often useful to know where a certain set of map data came from (e.g.
  * Tobin, PI, etc.).  The map data source is simply a name that can be
  * associated with a map object in the database (it is optional).
  */
d1160 3
a1162 8
 /*
  * Data Category Of A Map Object -----------------------------
  * 
  * Each map object added to the database must be associated with a user
  * supplied category name (e.g. rivers, coast line, etc.).  The user should
  * be careful to avoid spelling variations (e.g. "RIVER" and "RIVERS" are
  * all treated as separate categories).
  */
d1164 8
d1174 16
a1189 14
typedef struct {
    GSString_t category_name;/* Name of the data category. A null value is
			      * NOT allowed. */
    enum {
	GS_PRIMARY_ANNOTATION = 0,
	GS_ATTRIBUTE_ANNOTATION = 1
    } anno_type;	     /* Primary or attribute annotation ??? */
    GSString_t anno;	     /* Text */
    GSString_t font;	     /* Annotation font */
    GSReal_t height_in_mm;   /* Nominal display height (in mm) */
    GSReal_t anchor_angle;   /* Angle for annotation display */
    GSMapLocation_t anchor_point;	/* Anchor location */
    GSVector_t attribute_item;	/* Optional list of attributes */
}       GSMapAnnotation_t;
d1193 10
a1202 9
typedef struct {
    GSString_t category_name;/* Name of the data category. A null value is
			      * NOT allowed. */
    GSPlotSymbol_t symbol;   /* Plot Symbol */
    GSReal_t height_in_mm;   /* Nominal display height (in mm) */
    GSMapLocation_t anchor_point;	/* Anchor location */
    GSReal_t anchor_angle;   /* Angle for annotation display */
    GSVector_t attribute_item;	/* Optional list of attributes */
}       GSMapSymbol_t;
d1206 7
a1212 6
typedef struct {
    GSString_t category_name;/* Name of the data category. A null value is
			      * NOT allowed. */
    GSMapLocation_t location;/* Point location */
    GSVector_t attribute_item;	/* Optional list of attributes */
}       GSMapPoint_t;
d1216 10
a1225 10
typedef struct {
    GSString_t category_name;/* Name of the data category. A null value is
			      * NOT allowed. */
    GSBoolean_t flag;	     /* True = add additional buffers of polyline
			      * data. False = only one buffer of polyline
			      * data. */
    GSPolyLineType_t open_closed;	/* Open polyline or polygon ? */
    GSVector_t map_location; /* List of locations */
    GSVector_t attribute_item;	/* Optional list of attributes */
}       GSMapPolyline_t;
d1229 7
a1235 6
typedef struct {
    GSVector_t map_annotation;	/* NOTE: type = GSV_MAP_ANNOTATION */
    GSVector_t map_symbol;   /* NOTE: type = GSV_MAP_SYMBOL */
    GSVector_t map_point;    /* NOTE: type = GSV_MAP_POINT */
    GSVector_t map_polyline; /* NOTE: type = GSV_MAP_POLYLINE */
}       GSMapObjects_t;
d1237 5
d1243 63
a1305 5
/************************************************************************/
/*                                                                      */
/*              LEGAL DESCRIPTION STRUCTURE                             */
/*                                                                      */
/************************************************************************/
d1307 2
a1308 27
typedef struct {
    enum {
	GS_JEFFERSONIAN = 1,
	GS_GULF_COAST_OFFSHORE = 2,
	GS_TEXAS_ABSTRACT = 3,
	GS_OCS_OFFSHORE = 4
    } type;
    union {
	struct {	     /* structure describing Jeffersonian description
			      * of a location */
	    GSLongInt_t meridian_code;	/* PRINCIPAL_MERIDIAN code number -
					 * (Note: we need to publish a list
					 * or cite a reference - jgg) */
	    GSReal_t township;	/* township number */
	    char    twpns;   /* 'N' or 'S' of survey base line */
	    GSReal_t range;  /* range number */
	    char    rngew;   /* 'E' or 'W' of survey principal meridian */
	    GSReal_t section;/* section number in township */
	    GSString_t section_type;	/* type of 'section' (NULL = section,
					 * 'LOT', etc */
	    GSString_t spot; /* Point in section from which measurements are
			      * references */
	    GSString_t state;/* State or province abbreviation */
	    GSString_t country;	/* Country abbreviation */
	    GSString_t county;	/* County, district, parrish name */
	    GSString_t narrative;	/* Prose description of location */
	}       jeffersonian;
d1310 10
a1319 6
	struct {
	    GSString_t abstract;	/* Abstract ID */
	    GSString_t state;/* State or province abbreviation */
	    GSString_t country;	/* Country abbreviation */
	    GSString_t county;	/* County name */
	}       texas_abstract;
d1321 1
a1321 19
	struct {
	    GSString_t tract;/* Tract name */
	    struct {
		GSLongInt_t number;	/* Numeric part of block identifier */
		char    alpha;	/* Optional character part of block
				 * identifier */
	    }       block_id;
	}       gulfcoast_offshore;
	struct {
	    enum {
		GS_FEDERAL_WATERS,	/* Federal zone (non-state) */
		GS_STATE_WATERS	/* State zone */
	    }       state_fed;	/* Flag indicating whether point is under
				 * state or federal control */
	    GSString_t offshore_block;	/* Offshore block number */
	    GSString_t utm_grid_block;	/* Universal Transverse Mercator
					 * block identifier */
	    GSLongInt_t ocs_number;
	}       ocs_offshore;/* Outer Continental Shelf description */
d1323 14
a1336 8
    }       system;
    GSDistance_t nsfootage;  /* 'footage' in north-south direction */
    GSString_t ns;	     /* reference line of north-south 'footage'
			      * ('FEL','FWL') */
    GSDistance_t ewfootage;  /* 'footage' in ease-west direction */
    GSString_t ew;	     /* reference line of east-west 'footage'
			      * ('FNL','FSL') */
}       GSLegal_t;
d1338 5
d1344 14
a1357 5
/************************************************************************/
/*                                                                      */
/*                 GENERAL WELL STRUCTURES                              */
/*                                                                      */
/************************************************************************/
d1359 6
a1364 10
typedef struct {	     /* structure for defining well depths */
    GSMask_t valid;	     /* Indicates which fields contain valid
			      * information */
    GSReal_t md;	     /* measured depth */
    GSReal_t subdatum;	     /* depth relative to local datum */
    GSReal_t tvd;	     /* true vertical depth */
    GSReal_t time;	     /* two-way travel time */
    GSReal_t dx;	     /* X deviation from top-hole position */
    GSReal_t dy;	     /* Y deviation from top-hole position */
}       GSDepth_t;
d1366 5
a1370 5
typedef struct {	     /* structure for lithostrat codes (mandatory) */
    GSString_t Code;	     /* Formation code of the lithostratigraphic unit */
    GSString_t Age;	     /* Client-specified age code of
			      * lithostratigraphic unit (optional) */
}       GSLithoStrat_t;
d1372 123
d1496 5
a1500 5
/************************************************************************/
/*                                                                      */
/*                WELL HEADER STRUCTURE                                 */
/*                                                                      */
/************************************************************************/
d1502 10
a1511 137
typedef struct {	     /* structure defining well header information */
    GSVersion_t Version;     /* version number of this data structure */
    GSUWI_t uwi;	     /* Unique Well Identifier (mandatory) */
    GSPlotSymbol_t symbol;   /* Plot Symbol name */

    GSUnit_t z_unit;	     /* Unit of measure for all depths */

    struct {
	GSBoolean_t flag;    /* TRUE if well is deviated */
	GSVector_t depth;    /* vector of GSDepth_t structures */
    }       deviation;

    GSString_t well_name;    /* Full legal name of well lease */
    GSString_t well_number;  /* Well permit number within lease */
    GSString_t plot_name;    /* Shortened name of well lease for plotting */
    GSString_t short_name;   /* Shortened or informal name of well */

    GSString_t operator;     /* Name of well operator */
    GSString_t licensee;     /* Licensee of well lease */
    GSString_t agent;	     /* Name of agent */

 /* Class and status information */
    GSString_t class;	     /* Well classification (e.g. LAHEE class.) */
    GSString_t crstatus;     /* Current well status */
    GSString_t orstatus;     /* Original well status */
    GSString_t prstatus;     /* Previous well status */

 /* Location information */
    GSMapLocation_t tophole_xy;	/* structure defining coordinates of top hole
				 * position */
    GSLegal_t tophole;	     /* structure describing legal status of the
			      * tophole */
    GSMapLocation_t bottomhole_xy;	/* structure defining coordinates of
					 * bottom hole position */
    GSLegal_t bottomhole;    /* structure describing legal status of the
			      * bottomhole */

    struct {		     /* structure defining offshore specific wells */
	GSMeasurement_t water_depth;	/* Water depth */
	GSString_t platform_name;	/* Name of offshore drilling platform */
    }       offshore;

 /* Total depth information */
    struct {		     /* structure defining depths of driller, logger,
			      * and plugback */
	GSDepth_t driller;   /* structure describing driller depths */
	GSDepth_t logger;    /* structure describing logger depths */
	GSDepth_t plugback;  /* structure describing plugback depths */
	GSLithoStrat_t formation;	/* structure describing formation at
					 * TD */
	GSTemperature_t temperature;	/* bottom hole temperature */
	GSMeasurement_t pressure;	/* bottom hole pressure */
    }       td;

 /* Elevation information */
    GSElevationRef_t elevation;	/* Datum elevation for well */
    GSElevation_t Ground_Elevation;	/* ground elevation */
    GSElevation_t kb_elevation;	/* kelly bushing elevation */
    GSElevation_t cf_elevation;	/* casing flange elevation */

 /* Checkshot information */
    struct {
	GSElevationRef_t datum;	/* datum used for checkshot */
	GSVelocity_t vsd;    /* velocity surface to datum */
	GSUnit_t time_unit;  /* Unit of time in vector */
	GSVector_t depth;    /* measured depth */
	GSVector_t time;     /* two-way travel time */
    }       checkshot;
    struct {		     /* Drilling information */
	GSString_t contractor;	/* name of drilling contractor */
	GSString_t rig_number;	/* drilling rig number or identifier */
    }       drilling;

 /* Miscellaneous Information */
    GSString_t primary_source;	/* Name of source of well information */
    GSString_t stratcolumn;  /* name of strat column to use for this well */
    enum {
	GS_IMPERIAL_UNIT = 1,
	GS_METRIC_UNIT = 2
    } original_unit;	     /* Original unit system that data was collected
			      * in */
    GSBoolean_t proprietary; /* TRUE if this well contains proprietary
			      * informaiton */
    GSBoolean_t discovery_well;	/* TRUE if this is the discovery field for
				 * the field */
    GSBoolean_t fault;	     /* TRUE if this well has a faulted section */

 /* Confidentiality Information */
    struct {
	GSBoolean_t flag;    /* confidentiality flag */
	GSString_t formcode; /* confidentiality formation */
	GSDepth_t depth;     /* confidentiality depth */
	GSDate_t release_date;	/* confidential release date */
    }       confidential;

 /* Dates */
    GSDate_t Last_Update;    /* date/time of last update */
    GSDate_t Spud_Date;	     /* spud date */
    GSDate_t Comp_Date;	     /* completion date */
    GSDate_t rigrel;	     /* rig release date */
    GSDate_t onprod;	     /* on production date */
    GSDate_t calc_onprod;    /* calculated on production date */
    GSDate_t oninject;	     /* on injection date */
    GSDate_t status_date;    /* date last status was entered */
    GSDate_t fin_drill;	     /* final drilling date */

    GSBoolean_t updated;     /* TRUE if this well structure has been updated */

 /* Headers (tree-tops) for other well data classes */
    GSVector_t log_run;	     /* vector of GSLogRun_t */
    GSVector_t well_core;    /* Vector of core data (GSWellCore_t) */
    GSVector_t zone_value;   /* Vector of zone values (GSZoneValue_t) */
    GSVector_t well_marker;  /* Vector of GSWellMarker_t */
    GSVector_t well_production;	/* Vector of GSWellProduction_t (sorted
				 * descending by year) */
    GSVector_t well_tubulars;/* Vector of tubular products placed in well */
    GSVector_t well_remarks; /* Vector of general remarks */
    GSVector_t well_tests;   /* Vector of well tests */
}       GSWellHdr_t;


/************************************************************************/
/*                                                                      */
/*                 WELL CORE STRUCTURE                                  */
/*                                                                      */
/************************************************************************/

typedef struct {
    enum {
	GS_WELL_CORE_NORMAL = 1,	/* Normal well core */
	GS_WELL_CORE_SIDEWALL = 2	/* Sidewall core */
    } core_type;
    GSDepth_t top;	     /* Top of cored interval */
    GSDepth_t base;	     /* base of cored interval (not used for sidewall
			      * core) */
    GSReal_t recovered;	     /* Amount of core recovered, as a percentage
			      * (0-100) */
d1513 2
a1514 2
    GSString_t show;	     /* Type of petroleum show in core */
}       GSWellCore_t;
d1516 5
a1520 5
/************************************************************************/
/*                                                                      */
/*         Remarks, Miscellaneous well information                      */
/*                                                                      */
/************************************************************************/
d1522 5
a1526 8
 /*
  * The following catch-all is intended to be used to describe some
  * measurement or activity observed in a well that is not adequately
  * modelled elsewhere in these data structures.  The intent is to allow
  * another vendor to display this information somehow without being
  * concerned about the semantics of the information.  This might be used to
  * display arbitrary information in a cross-section panel, or in a report.
  */
d1528 10
a1537 9
typedef struct {
    GSString_t type_name;    /* Type of data being described, or name of data
			      * set */
    GSDepth_t depth;	     /* Depth at this these observations were made
			      * (Zero implies these observations apply to the
			      * well as a whole) */
    GSVector_t strings;	     /* A vector of strings describing some event or
			      * measurement at this depth */
}       GSWellRemarks_t;
d1539 5
d1545 7
a1551 5
/************************************************************************/
/*                                                                      */
/*                 LOG RUN AND TRACE STRUCTURE                          */
/*                                                                      */
/************************************************************************/
d1553 20
a1572 6
typedef struct {
    GSResistivity_t rm;	     /* Mud resistivity */
    GSResistivity_t rmf;     /* Mud filtrate resistivity */
    GSResistivity_t rmc;     /* Mud cake resistivity */
    GSString_t source;	     /* Source of resistivity observations */
}       GSMudResistivity_t;
d1574 9
a1582 25
typedef struct {
    GSString_t name;	     /* Name or mnemonic of sensor (GR, DT, RHOB,
			      * etc) */
    GSString_t source;	     /* Source of the digital data associated with
			      * this sensor */
    GSLongInt_t version;     /* Version number of this trace - used during
			      * editing */
    GSString_t comments;     /* General remarks about the log trace */
    GSUnit_t depth_uom;	     /* Unit of depth measurement */
    GSUnit_t trace_uom;	     /* Unit of trace value */
    GSReal_t non_null_top;   /* Top of trace data interval (excluding nulls) */
    GSReal_t non_null_base;  /* Base of trace data interval (excluding nulls) */
    GSReal_t min;	     /* Minimum trace value */
    GSReal_t max;	     /* Maximum trace value */
    GSReal_t dinc;	     /* Digitizing increment (0.0 if random) */
    GSVector_t processing_history;	/* Vector of processing history
					 * records sorted by date, most
					 * recent listed first */
    GSVector_t depth;	     /* Array of depth values (4 or 8 byte floating
			      * point values) Note: this is NOT a Depths_t
			      * structure) */
    GSVector_t value;	     /* Corresponding array of values.  The number of
			      * depths and values should match (4 or 8 byte
			      * floating point values) */
}       GSLogTrace_t;
d1584 10
a1593 1
typedef struct {
d1595 28
a1622 58
 /*
  * A service is also loosely called a logging tool. Several services may be
  * used in a single pass
  */
    GSString_t log_service;  /* Name of log service */
    GSString_t tool_id;	     /* Tool identifier/serial number */
    GSLongInt_t sequence;    /* Sequence number of this tool in current tool
			      * string */
    GSVector_t log_trace;    /* List of sensors that belong to this
			      * service/tool */
}       GSLogService_t;

typedef struct {

 /*
  * A pass is a single Trip of the tool string. There is usually more than
  * one pass per run
  */
    GSLongInt_t pass_number; /* Logging pass number within current log run */
    GSDate_t pass_date;	     /* Date this pass was started */
    GSMeasurement_t top;     /* Top of logged interval */
    GSMeasurement_t base;    /* Base of logged interval */
    GSVector_t log_service;  /* List of services being used during this pass */
}       GSLogPass_t;

typedef struct {

 /*
  * A log run is a visit by a logging company to a drilling site. It usually
  * is associated with a single billing cycle Also called an 'activity'
  */
    GSLongInt_t run_number;  /* Log run number */
    GSString_t logging_company;	/* Name of company providing logging service */
    GSDate_t run_date;	     /* Date this log run was started */
    GSString_t logging_unit_number;	/* Identification of logging truck or
					 * unit */
    GSString_t logging_unit_loc;	/* Location of logging unit (home
					 * base) */
    GSString_t recorder;     /* Name of person acting as logging recorder */
    GSString_t witness;	     /* Name of company witness to logging activity */
    GSElevationRef_t datum;  /* Elevation used as log run datum */
    struct {
	GSString_t type;     /* type of mud */
	GSMeasurement_t salinity;	/* Mud salinity */
	GSMeasurement_t density;	/* Mud weight */
	GSMeasurement_t viscosity;	/* mud viscosity */
	GSMeasurement_t fluid_loss;
	GSReal_t pH;
	GSMudResistivity_t resistivity;	/* Resistivity of mud */
	GSMudResistivity_t resistivity_bht;	/* Resistivity of mud at
						 * bottom hole temperature */
    }       mud_data;
    GSMeasurement_t time_circ_stopped;	/* Time since mud circulation was
					 * stopped */
    GSMeasurement_t time_logger_on_bottom;	/* Time the logging tool was
						 * at bottom of well */
    GSTemperature_t max_rec_temp;	/* Maximum bottom hole temperature
					 * recorded */
d1624 1
a1624 1
}       GSLogRun_t;
d1626 5
a1631 6
/************************************************************************/
/*                                                                      */
/*               ZONE DEFINITIONS                                       */
/*                                                                      */
/************************************************************************/

d1635 7
a1641 7
typedef struct {
    GSZoneName_t zone_name;  /* Name of zone being defined */
    GSString_t top_definition;	/* Text describing how top of zone is defined */
    GSString_t base_definition;	/* Text describing how base of zone is
				 * defined */
    GSString_t remarks;	     /* General remarks about zone */
}       GSZoneDefinition_t;
d1643 11
a1653 10
typedef struct {
    GSZoneName_t zone_name;  /* Name of zone in which the variable is
			      * defined. If null, then the defined variable
			      * applies to all zones. */
    GSZoneVariable_t variable_name;	/* Name of variable being defined */
    GSString_t algorithm;    /* Description of methodology used to define the
			      * variable. This may be an equation or a
			      * reference to a known algorithm. */
    GSString_t remarks;	     /* General remarks about zone variable */
}       GSZoneVariableDefinition_t;
d1655 12
a1666 9
typedef struct {
    GSZoneName_t zone_name;  /* Name of the zone.  If null, then the defined
			      * variable applies to entire well or field. */
    GSZoneVariable_t variable_name;	/* Name of variable being measured */
    GSDepth_t top;	     /* Depth to top of measured interval */
    GSDepth_t base;	     /* Depth to base of measured interval */
    GSString_t value;	     /* Value of zone variable */
    GSUnit_t unit;	     /* Unit of measurement */
}       GSZoneValue_t;
d1668 20
a1687 22

/********************************************************************/
/*                                                                  */
/*              PRODUCTION HISTORY STRUCTURE                        */
/*                                                                  */
/********************************************************************/
typedef struct {
    enum {
	GS_OIL = 1,
	GS_WATER = 2,
	GS_GAS = 3
    } fluid_type;	     /* Type of fluid produced */
    GSLongInt_t year;	     /* Year of record */
    GSZoneName_t zone_name;  /* Name of the zone. */
    GSReal_t cumulative_prior_years;	/* Sum of fluid produced during prior
					 * years */
    GSVector_t prod_month;   /* Vector of GSReal_t containing monthly
			      * production, one per month (1st is January,
			      * 2nd is February, etc) */
    GSUnit_t unit;	     /* Unit of measure used to describe production
			      * volumes */
}       GSWellProduction_t;
d1689 21
a1709 21
/********************************************************************/
/*                                                                  */
/*              TUBULAR PRODUCTS STRUCTURE                          */
/*                                                                  */
/********************************************************************/
typedef struct {
    GSString_t tubing_type;  /* Type of tubing product */
    GSString_t tubing_size;  /* Size of tubing, as a printable string */
    GSDate_t install_date;   /* Date this tubular product was installed */
    GSDepth_t top;	     /* Top of tubular product */
    GSDepth_t base;	     /* base of tubular product */
    GSMeasurement_t bore;    /* Inside diameter of casing */
    GSMeasurement_t hole_size;	/* Size of hole in which tubular product was
				 * installed */
    struct {
	GSDepth_t depth;     /* Depth at which casing shoe was installed */
	GSLithoStrat_t form; /* Formation in which shoe was set */
    }       shoe;
    GSReal_t strength;	     /* Axial load required to yield pipe */
    GSString_t steel_spec;   /* Manufacturer's spec under which steel was
			      * made */
d1711 1
a1711 1
}       GSWellTubulars_t;
d1713 5
a1717 6

/********************************************************************/
/*                                                                  */
/*               WELL MARKER STRUCTURES                             */
/*                                                                  */
/********************************************************************/
d1719 10
a1728 8
typedef enum {
    GS_LITHO_TOP = 1,	     /* Lithostratigraphic (formation) top */
    GS_CONTACT_TOP = 2,	     /* Fluid surface contact (e.g. oil/water) */
    GS_FAULT_POINT = 3,	     /* Piercing point of well through fault plane */
    GS_MARKER_TOP = 4,	     /* Stratigraphic marker - subordinate to
			      * lithostratigraphic pick */
    GS_OTHER_TOP = 5
} GSMarkerType_t;
d1730 22
a1751 22
typedef struct {	     /* Formation top description */
    GSUWI_t uwi;	     /* Unique well identifier (mandatory) */
    GSLithoStrat_t name;     /* Name of lithostratigraphic (surface set) name
			      * (mandatory) */
    GSString_t source;	     /* Source of interpretation */
    GSSurfaceSetName_t seismic_horizon;	/* Name of seismic surface that this
					 * marker is correlated with */
    GSUnit_t z_uom;	     /* unit of measure (used when part of a surface
			      * set) */
    GSDepth_t depth;	     /* Coordinates of piercing point */
    GSMeasurement_t fault_gap;	/* For faults, the amount of missing section
				 * faulted out at this location */
    enum {
	GS_NORMAL_SECTION = 0,	/* Paleo up indicators point up */
	GS_INVERTED_SECTION = 1	/* Paleo up indicators inverted */
    } up_direction;
    GSString_t Comment;	     /* comments describing nature of pick (ABSENT,
			      * ERODED, NOT PICKED, etc) */
    GSBoolean_t Best_Pick;   /* TRUE if this is best available information */
    char    Quality;	     /* Quality code of pick */
    GSDate_t Last_Update;    /* date this interpretation made */
}       GSWellMarker_t;
d1753 3
a1755 6
typedef struct {	     /* Used as part of a surface set ... */
    GSUWI_t uwi;	     /* Unique well identifier */
    GSMeasurement_t measurement;	/* Attribute value measured at this
					 * point */
    GSString_t source;	     /* Source of this interpretation/measurement */
}       GSWellAttribute_t;
d1757 12
a1768 5
 /*
  * A vector of the following entities describes the lithostratigraphic codes
  * that may be sent.  It acts as an assertion list and provides some
  * structural relationships between 'formations'
  */
d1770 15
a1784 12
typedef struct {
    GSLithoStrat_t code_name;/* formation and age codes (NOTE: Age code in
			      * this structure implies the Average of the
			      * formation. The exact age at a well is found
			      * in the GSWellMarker_t structure) */
    GSString_t source;	     /* Name of company that defines/uses this code */
    GSSurfaceSetName_t full_name;	/* Full marker/formation (surface
					 * set) name */
    GSMarkerType_t marker_type;	/* Type of surface */
    GSLithoStrat_t parent;   /* if this unit is a member of a larger group,
			      * then this field contains the name of the next
			      * higher order */
d1786 1
a1786 1
}       GSLithostratCodeDesc_t;
d1788 4
a1791 6
 /*
  * The following represents a stratigraphic column.  This is a list of
  * lithostratigraphic codes and their depositional ranking, from youngest to
  * oldest. This list usually describes a normal depositional sequence
  * independent of any well
  */
d1793 7
a1799 6
typedef struct {
    GSString_t name;	     /* Name of stratigraphic column */
    GSString_t citation;     /* Journal citation describing sequence */
    GSString_t remarks;	     /* */
    GSVector_t lithostrat;   /* Vector of formation and age codes */
}       GSStratigraphicColumn_t;
d1801 5
a1805 6

/********************************************************************/
/*                                                                  */
/*               WELL TEST STRUCTURES                               */
/*                                                                  */
/********************************************************************/
d1807 9
a1815 7
typedef struct {
    enum {
	GS_WELL_DRILLSTEM_TEST,
	GS_WELL_PRODUCTION_TEST
    }       test_type;
 /* this needs mucho work */
}       GSWellTestHdr_t;
d1817 5
a1821 6

/********************************************************************/
/*                                                                  */
/*        TOP STRUCTURES FOR EACH DATA TYPE                         */
/*                                                                  */
/********************************************************************/
d1823 4
a1826 3
 /*
  * Seismic Survey Information --------------------------
  */
d1828 2
a1829 8
 /*
  * All seismic related information is specified in a hierarcical structure.
  * The top of the hierarcy is a structure which groups the information
  * according to surveys.  Surveys may be either 2d groups of line or 3d
  * surveys.  In order to facilitate memory management, 3d survey data will
  * be organized according to lines.  The following defines the survey
  * structure:
  */
d1831 13
a1843 17
typedef struct {
    GSString_t survey_name;  /* Name of survey */
    GSString_t survey_desc;  /* Survey description */
    enum {		     /* Survey type */
	GS_SURVEY_2D = 2,    /* 2d survey symbol */
	GS_SURVEY_3D = 3     /* 3d survey symbol */
    } survey_type;
    GSElevation_t z_datum;   /* Datum to use in association with elevations */
    GSCartoProjection_t proj;/* Projection information */
    GSDP_t  dp_null;	     /* Null value for floating point numbers */
    GSLongInt_t int_null;    /* Null value for integers */
    GSSeismicLocation3D_t loc3d;	/* 3d survey specificaton and
					 * location structure (not used for
					 * 2-D survey) */
    GSVector_t seismic_line; /* vector of structures describing lines
			      * element_type = GSV_SEISMIC_LINE */
}       GSSeismicSurvey_t;
d1845 3
a1847 16
 /*
  * Surface set Information -----------------------
  */
typedef struct {
    GSSurfaceSetName_t surface_name;	/* Name of surface set */
    GSString_t description;  /* description of the surface */
    GSCartoProjection_t proj;/* Projection information */
    GSDP_t  dp_null;	     /* Null value for floating point numbers */
    GSLongInt_t int_null;    /* Null value for integers */
    GSSurfaceType_t surface_type;	/* Type of surface (Fault, horizon,
					 * geologic marker) */
    GSVector_t surface_geometry;	/* List of geometry information for
					 * surface */
    GSSurfaceIntersection_t intersection;	/* Intersection of surface
						 * set with other entities */
}       GSSurfaceSet_t;
d1849 12
a1860 3
 /*
  * Field Information ----------------
  */
d1862 3
a1864 12
typedef struct {
    GSString_t field_name;   /* name of (oil, gas) field */
    GSString_t field_type;   /* What type of field this is */
    GSUWI_t discovery_well;  /* Unique identifier of the discovery well */
    GSVector_t zone_value;   /* Vector of zone values for the field */
    GSVector_t map_polyline; /* areal extent of field, as a series of closed
			      * polygons.  NOTE: type = GSV_MAP_POLYLINE */
    GSCartoProjection_t proj;/* Projection information */
    GSDP_t  dp_null;	     /* Null value for floating point numbers */
    GSLongInt_t int_null;    /* Null value for integers */
    GSVector_t well_hdr;     /* vector of structures describing wells */
}       GSField_t;
d1866 10
a1875 3
 /*
  * Well Tie Information --------------------
  */
d1877 5
a1881 18
typedef struct {	     /* This structure describes the relationship
			      * between a specific surface in a well and its
			      * correlation with a specifiv seismic line and
			      * shot point. Useful for tying
			      * geophysical/geological data in reservoir
			      * simulators */
    GSUWI_t uwi;
    GSLithoStrat_t marker;
    GSSurfaceSetName_t surface_set_name;	/* Name of seismic surface
						 * this tie is correlated
						 * with */
    GSCartoProjection_t proj;/* Projection information */
    GSString_t survey_name;  /* (optional) */
    GSString_t line_name;    /* (optional) */
    GSDP_t  dp_null;	     /* Null value for floating point numbers */
    GSLongInt_t int_null;    /* Null value for integers */
    GSSeismicDataPoint_t seismic_loc;	/* location on seismic line */
}       GSSeismicWellTie_t;
d1883 9
a1891 3
 /*
  * Map Information ---------------
  */
d1893 63
a1955 9
typedef struct {
    GSString_t source_name;  /* Name of the data source. A null value is
			      * allowed (e.g. no source) */
    GSCartoProjection_t proj;/* Projection information */
    GSDP_t  dp_null;	     /* Null value for floating point numbers */
    GSLongInt_t int_null;    /* Null value for integers */
    GSString_t local_datum;  /* Datum reference for long., lat. */
    GSUnit_t z_unit;	     /* Unit of elevation */
    GSExtents_t extent;	     /* Area of interest of the map */
d1957 1
a1957 1
}       GSMap_t;
d1959 3
a1961 4
 /*
  * Fault Trace (in map view) Information
  * -------------------------------------
  */
d1963 8
a1970 8
typedef struct {
    GSElevation_t z_datum;   /* Datum to use in association with elevations */
    GSCartoProjection_t proj;/* Projection information */
    GSDP_t  dp_null;	     /* Null value for floating point numbers */
    GSLongInt_t int_null;    /* Null value for integers */
    GSVector_t fault_surface;/* Vector of structures of surfaces having fault
			      * traces defined */
}       GSFaultTraceSet_t;
d1972 9
a1980 10
 /*
  * List of formation codes and stratigraphic columns
  * -------------------------------------------------
  */
typedef struct {
    GSVector_t lithostrat_code_desc;	/* A list of stratigraphic codes */
    GSVector_t stratigraphic_column;	/* List of stratigraphic columns */
    GSDP_t  dp_null;	     /* Null value for floating point numbers */
    GSLongInt_t int_null;    /* Null value for integers */
}       GSLithostratCodeList_t;
d1982 9
a1990 11
 /*
  * List of zone definitions and variables
  * --------------------------------------
  */
typedef struct {
    GSVector_t zone_definition;	/* List of zone definition */
    GSVector_t zone_variable_definition;	/* List of zone variable
						 * definitions */
    GSDP_t  dp_null;	     /* Null value for floating point numbers */
    GSLongInt_t int_null;    /* Null value for integers */
}       GSZoneList_t;
d1992 3
d1996 27
a2022 5
/********************************************************************/
/*                                                                  */
/*        STATUS STRUCTURE                                          */
/*                                                                  */
/********************************************************************/
d2024 3
a2026 5
 /*
  * A status structure for returning to the exporting application information
  * about the success/failure of the various functions performed by the
  * receiver.
  */
d2028 7
a2034 6
typedef struct {
    GSLongInt_t status_code; /* error code */
    GSString_t object_key;   /* One or more object keys, separated by ^,
			      * identifying entity that produced status */
    GSString_t status_description;	/* Status description */
}       GSStatusReturn_t;
d2038 5
a2042 6

/********************************************************************/
/*                                                                  */
/*        CONTEXT STRUCTURES                                        */
/*                                                                  */
/********************************************************************/
d2044 5
a2048 7
 /*
  * There are two parts to receiver context within which a client must
  * operate, environmental in the form of a possible memory limitation, and
  * data in the form of things such as project names, pass words, file names,
  * etc.  The following structures will be used to reply to a request for
  * context information :
  */
d2050 5
a2054 4
typedef struct {
    GSLongInt_t max_memory;  /* Size of local memory buffer, in bytes */
    GSVector_t context_requirements;	/* data context requirements */
}       GSReceiverContext_t;
d2056 2
a2057 4
 /*
  * This structure is associated with defining the information to be sent to
  * to the receiver to establish context.
  */
d2059 13
a2071 14
typedef struct {
    enum {
	GS_INTEGER_TYPE = 1,
	GS_CHARACTER_TYPE = 2,
	GS_FLOAT_TYPE = 3,
	GS_UNSIGNED_INTEGER = 4
    } type;		     /* Data type of context variable */
    GSLongInt_t max_length;  /* Maximum length of context variable (if
			      * string) */
    GSBoolean_t confidential;/* Flag for whether to display user's input */
    GSString_t prompt;	     /* Prompt string to use for requesting context
			      * variable */
    GSString_t cmdline_tag;
}       GSContextRequirements_t;
d2073 4
a2076 7
 /*
  * This vector is used to transmit the requested information back to the
  * exporting process.  There will be one string for each requirement
  * specified in the previous structure.  Even though an integer(perhaps
  * unsigned) or float may be required, it will be sent in ascii
  * representation.
  */
d2078 1
a2078 2
typedef GSVector_t GSContextInformation_t;	/* this is a vector of type
						 * GSString_t */
d2080 2
a2081 4
 /*
  * Upon establishment of the context, a token will be returned to the client
  * process
  */
d2083 1
a2083 1
typedef GSLongInt_t GSContextToken_t;	/* tag for context established */
d2085 5
a2089 6

/********************************************************************/
/*                                                                  */
/*        EXECUTIVE STRUCTURES                                      */
/*                                                                  */
/********************************************************************/
d2091 9
a2099 9
 /*
  * An executive structure containing context destination information for
  * cross check reference to the context establishment information structure,
  * and a list which provides reference to all supported data type structures
  * which are to be transmitted.  If context has been previously established
  * then the context information structure need not be included.  If context
  * has not been previously established then the context information
  * structure must be referenced first in the list(if necessary).
  */
d2101 2
a2102 4
 /*
  * This structure allows description of an operation upon which to perform
  * on the accompanying data structure
  */
d2104 29
a2132 12
typedef enum {
 /* Instruction is unknown, check disposition_ext */
    GS_CMD_UNKNOWN = 0,	     /* Address of structure is undefined */
 /* Interaction is complete, terminate                */
    GS_STOP_SERVER = 1000,   /* Address of structure is NULL */
 /* Break current context, retain comm handshake      */
    GS_CONTEXT_BREAK = 1001, /* Address of structure is NULL */
 /* Return context requirements                       */
    GS_SEND_CONTEXT = 1002,  /* Address of structure is NULL */
 /* Process everything, send no return status         */
    GS_NO_RETURN = 1003	     /* Address of structure is NULL */
} GSDataDisposition_t;
d2134 2
a2135 5
 /*
  * The following is a list of top-level structures ('objects') that GeoLink
  * defines. The list is extendable past the enum set by using the extension
  * portion of the union.
  */
d2137 19
a2155 17
typedef enum {
  GS_STRUCT_UNKNOWN = 0,   /* structure unknown to GeoShare is passed,
			    * check type_ext for value */
  GS_STRUCT_RECEIVER_SPECS = 1,
  GS_STRUCT_RECEIVER_RQMTS = 2,
  GS_STRUCT_CONTEXT_RQMTS = 3,
  GS_STRUCT_CONTEXT_INFO = 4,
  GS_STRUCT_CONTEXT_TOKEN = 5,
  GS_STRUCT_STATUS_VECTOR = 6,
  GS_STRUCT_SEISMIC_SURVEY = 11,
  GS_STRUCT_SURFACE_SET = 12,
  GS_STRUCT_WELL_FIELD = 13,
  GS_STRUCT_WELL_TIE = 14,
  GS_STRUCT_MAP = 15,
  GS_STRUCT_FAULT_TRACE_SET = 16,
  GS_STRUCT_LITHOSTRAT_CODES = 17,
  GS_STRUCT_ZONES = 18,
d2157 6
a2162 9
  GS_STRUCT_AMPLITUDE_STATS,
  GS_STRUCT_ATTRIBUTE_ITEM,
  GS_STRUCT_CARTO_PROJECTION,
  GS_STRUCT_CONTACT,
  GS_STRUCT_CONTOUR,
  GS_STRUCT_DATA_DISPOSITION,
  GS_STRUCT_DATA_STRUCT_TYPE,
  GS_STRUCT_DATA_SUPPORTED,
  GS_STRUCT_DEPTH,
d2164 4
a2167 90
  GS_STRUCT_ELEVATION_REF,
  GS_STRUCT_EXECUTIVE,
  GS_STRUCT_EXTENTS,
  GS_STRUCT_FAULT_SURFACE,
  GS_STRUCT_FAULT_TRACE,
  GS_STRUCT_FIELD,
  GS_STRUCT_GRID,
  GS_STRUCT_LEGAL,
  GS_STRUCT_LINE_INTERSECTION,
  GS_STRUCT_LITHOSTRAT_CODE_DESC,
  GS_STRUCT_LITHO_STRAT,

  GS_STRUCT_LOG_PASS,
  GS_STRUCT_LOG_RUN,
  GS_STRUCT_LOG_SERVICE,
  GS_STRUCT_LOG_TRACE,

  GS_STRUCT_MAP_ANNOTATION,
  GS_STRUCT_MAP_LOCATION,
  GS_STRUCT_MAP_OBJECTS,
  GS_STRUCT_MAP_POINT,
  GS_STRUCT_MAP_POLYLINE,
  GS_STRUCT_MAP_SYMBOL,
  GS_STRUCT_MARKER_TYPE,

  GS_STRUCT_MEASUREMENT,
  GS_STRUCT_DISTANCE,    /* measurement with uom.type = "DISTANCE" */
  GS_STRUCT_ELEVATION,   /* measurement with uom.type = "DISTANCE" */
  GS_STRUCT_RESISTIVITY, /* measurement with uom.type = "RESISTIVITY" */
  GS_STRUCT_TEMPERATURE, /* measurement with uom.type = "TEMPERATURE" */
  GS_STRUCT_TIME,        /* measurement with uom.type = "TIME" */
  GS_STRUCT_VELOCITY,    /* measurement with uom.type = "VELOCITY" */
  GS_STRUCT_WEIGHT,      /* measurement with uom.type = "WEIGHT" */

  GS_STRUCT_MUD_RESISTIVITY,
  GS_STRUCT_PROCESSING_HISTORY,

  GS_STRUCT_RECEIVER_CONTEXT,
  GS_STRUCT_REQUIREMENT,

  GS_STRUCT_SEGMENT,
  GS_STRUCT_SEISMIC_CLASS,
  GS_STRUCT_SEISMIC_DATA_POINT,
  GS_STRUCT_SEISMIC_LINE,
  GS_STRUCT_SEISMIC_LINE_HDR,
  GS_STRUCT_SEISMIC_LOCATION_3D,
  GS_STRUCT_SEISMIC_LOC_2D,
  GS_STRUCT_SEISMIC_SURFACE,
  GS_STRUCT_SEISMIC_TRACE,
  GS_STRUCT_SEISMIC_TRANSDUCER,
  GS_STRUCT_SEISMIC_VELOCITY,

  GS_STRUCT_STATUS_RETURN,
  GS_STRUCT_STRATIGRAPHIC_COLUMN,
  GS_STRUCT_STRUCTURE,

  GS_STRUCT_SURFACE_ATTRIBUTE,
  GS_STRUCT_SURFACE_GEOMETRY,
  GS_STRUCT_SURFACE_INTERSECTION,
  GS_STRUCT_SURFACE_REPRESENTATION,
  GS_STRUCT_SURFACE_SURFACE_INTERSECTION,
  GS_STRUCT_SURFACE_TRACE,

  GS_STRUCT_UNIT,

  GS_STRUCT_VELOCITY_PAIR,
  GS_STRUCT_VERSION,

  GS_STRUCT_WELL_ATTRIBUTE,
  GS_STRUCT_WELL_CORE,
  GS_STRUCT_WELL_HDR,
  GS_STRUCT_WELL_MARKER,
  GS_STRUCT_WELL_PRODUCTION,
  GS_STRUCT_WELL_REMARKS,
  GS_STRUCT_WELL_TEST_HDR,
  GS_STRUCT_WELL_TUBULARS,

  GS_STRUCT_XYZ_DATA,
  GS_STRUCT_XYZ_POINT,

  GS_STRUCT_ZONE_DEFINITION,
  GS_STRUCT_ZONE_NAME,
  GS_STRUCT_ZONE_VALUE,
  GS_STRUCT_ZONE_VARIABLE,
  GS_STRUCT_ZONE_VARIABLE_DEFINITION
} GSDataStructType_t;

typedef struct {
    GSDataDisposition_t disposition;
    GSLongInt_t disposition_ext;
d2172 1
a2172 1
} GSStructure_t;
d2174 5
a2178 4
typedef struct {
    GSContextToken_t context_token;	/* tag for context established */
    GSVector_t gs_structure; /* vector of structures on which to act */
}       GSExecutive_t;
d2180 1
d2182 5
a2186 5
/********************************************************************/
/*                                                                  */
/*        RECEIVER CAPABILITY STRUCTURES                            */
/*                                                                  */
/********************************************************************/
d2188 8
a2195 8
 /*
  * A Receiver information structure is returned to the GeoShare Server upon
  * request.  This structure contains the following information: a.  Status
  * of Receiver service initialization b.  A unique name for the receiver so
  * a client can ask for it by name (if known). c.  A descriptive text string
  * to show the user in a list of receivers d.  Exploration data structures
  * supported e.  Data structure revision level range supported
  */
d2197 5
a2201 8
 /*
  * Support for a given data structure is composed of three parts, an
  * enumerated parameter which indicates that it is supported, a mask
  * variable in which the receiver indicates which components of the
  * structure it can handle, and a structure indicating the GeoShare version
  * which it supports.  The following #define statements provide the
  * component masks:
  */
d2205 6
a2210 7
#define GSM_SS_GRID            (1<<0)	/* grid structure is supported */
#define GSM_SS_SEISMIC         (1<<1)	/* seismic interpretation is
					 * supported */
#define GSM_SS_XYZ             (1<<2)	/* xyz scatter data are supported */
#define GSM_SS_CONSTANT        (1<<3)	/* constant data are supported */
#define GSM_WELL_MARKER        (1<<4)	/* Well Marker data are supported */
#define GSM_SS_CONTOUR         (1<<5)	/* Contour Information is supported */
d2214 5
a2218 6
#define GSM_SEISMIC_2D         (1<<0)	/* 2d seismic line input is supported */
#define GSM_SEISMIC_3D         (1<<1)	/* 3d Survey input is supported */
#define GSM_SEISMIC_LINE_HDR   (1<<2)	/* Seismic line header data are
					 * supported */
#define GSM_SEISMIC_TRACE      (1<<3)	/* Seismic trace data are supported */
#define GSM_SEISMIC_SURFACE    (1<<4)	/* Seismic surface data are supported */
d2222 12
a2233 9
#define GSM_WELL_CHECKSHOT     (1<<0)	/* Checkshot information is supported */
#define GSM_WELL_PATH          (1<<1)	/* Path data are supported */
#define GSM_WELL_LOG_RUN       (1<<2)	/* Log run data are supported */
#define GSM_WELL_WELL_CORE     (1<<3)	/* Core data are supported */
#define GSM_WELL_ZONE_VALUE    (1<<4)	/* Zone value data are supported */
#define GSM_WELL_WELL_MARKER   (1<<5)	/* Well marker(tops) data  supported */
#define GSM_WELL_PRODUCTION    (1<<6)	/* Production history data  supported */
#define GSM_WELL_TUBULARS      (1<<7)	/* Tubular information are supported */
#define GSM_WELL_REMARKS       (1<<8)	/* Remark information are supported */
d2237 21
a2257 4
#define GSM_FIELD_WELLS        (1<<0)	/* Field Well data are supported */
#define GSM_FIELD_BOUNDARY     (1<<1)	/* Field boundary is supported */
#define GSM_FIELD_ZONE_VALUE   (1<<2)	/* Field zone data are supported */
typedef struct {
d2261 3
a2263 1
}       GSDataSupported_t;
d2265 2
a2266 6
typedef struct {
    GSLongInt_t receiver_status;	/* Reserved for future use */
    GSString_t receiver_name;/* Unique char identifier of rcvr (<=20 chars) */
    GSString_t banner_string;/* Advertise your product! (<=60 characters ) */
    GSVector_t data_supported;	/* List of types of data the server supports */
}       GSReceiverSpecs_t;
d2268 9
a2276 10
 /*
  * A client application may request information from the GeoShare server
  * about which application servers are available for the task the client
  * wishes.  It may specify the request in terms of a receiver name or in
  * terms of data structures supported.  If more than one specification is
  * provided, then receivers meeting any of the specifications will be
  * included.  A vector of the following structures will be passed to the
  * GeoShare server as input to making a list of receivers which will satisfy
  * the criteria:
  */
d2278 7
a2284 1
typedef GSVector_t GSReceiverRqmts_t;
d2286 10
a2295 6
typedef struct {
    enum {
	GS_STRUCT_SUPPORTED = 1,
	GS_NAME = 2
    } spec_type;
    GSString_t receiver_name;
d2297 1
a2297 1
}       GSRequirement_t;
d2299 5
a2303 5
/********************************************************************/
/*                                                                  */
/*        END OF INCLUDE FILE GEOSCIENCE.H                          */
/*                                                                  */
/********************************************************************/
@


1.9
log
@*** empty log message ***
@
text
@@


1.8
log
@*** empty log message ***
@
text
@d86 5
a90 5
/************************************************************************************/
/*                                                                                  */
/*                    Notes on usage of geoscience.h                                */
/*                                                                                  */
/************************************************************************************/
d233 5
a237 5
/************************************************************************************/
/*                                                                                  */
/*                    Generally Used Typedefs                                       */
/*                                                                                  */
/************************************************************************************/
d245 1
a245 2
typedef long GSMask_t;	     /* Bit mask, used to identify item validity in
			      * structures */
d253 5
a257 5
/************************************************************************************/
/*                                                                                  */
/*                    The Basic Building Block, the GSVector_t                      */
/*                                                                                  */
/************************************************************************************/
d294 1
a294 2
    GSV_ZONE_VARIABLE_DEF = 3000,	/* vector type
					 * GSZoneVariableDefinition_t */
d360 5
a364 5
/************************************************************************************/
/*                                                                                  */
/*                    STRUCTURE VERSION STAMP                                       */
/*                                                                                  */
/************************************************************************************/
d373 5
a377 5
/************************************************************************************/
/*                                                                                  */
/*                    Data Structure Typedefs                                       */
/*                                                                                  */
/************************************************************************************/
d468 5
a472 5
/************************************************************************************/
/*                                                                                  */
/*                   MEASUREMENT TYPEDEFS                                           */
/*                                                                                  */
/************************************************************************************/
d479 1
a479 2
    GSString_t type;	     /* DISTANCE, TIME, VOLUME, WEIGHT, TEMPERATURE,
			      * etc */
d485 2
a486 2
    GSUnit_t uom;	     /* unit of measure, including the measurement
			      * system and the actual unit */
d489 18
a506 20
typedef GSMeasurement_t GSTemperature_t;	/* Special case of a
						 * measurement where uom.type
						 * = "TEMPERATURE" */
typedef GSMeasurement_t GSResistivity_t;	/* Special case of a
						 * measurement where uom.type
						 * = "RESISTIVITY" */
typedef GSMeasurement_t GSTime_t;	/* Special case of a measurement
					 * where uom.type = "TIME" */
typedef GSMeasurement_t GSVelocity_t;	/* Special case of a measurement
					 * where uom.type = "VELOCITY" */
typedef GSMeasurement_t GSWeight_t;	/* Special case of a measurement
					 * where uom.type = "WEIGHT" */
typedef GSMeasurement_t GSDistance_t;	/* Special case of a measurement
					 * where uom.type = "DISTANCE" and
					 * implication that measurement is
					 * made in horizontal sense */
typedef GSMeasurement_t GSElevation_t;	/* Special case of a measurement
					 * where uom.type = "DISTANCE" and
					 * implication that measurement is
					 * made in vertical sense */
d508 4
a511 4
typedef struct {	     /* structure describing reference elevation */
    GSElevation_t val;	     /* Elevation to use for subsea corrections */
    GSString_t ref;	     /* Data type being used as elevation reference
			      * (KB, DF, GS, SL, etc) */
d515 5
a519 5
/************************************************************************************/
/*                                                                                  */
/*                   MASKS DEFINING VALIDITY OF ITEMS                               */
/*                                                                                  */
/************************************************************************************/
d529 2
a530 2
#define GSM_VALID_CONNECT      (1<<7)	/* connectivity vector in xyz scatter
					 * data */
d540 2
a541 2
#define GSM_VALID_CDP_PER_SP        (1<<0)	/* Nominal number of cdps per
						 * shot point */
d546 1
a546 2
#define GSM_VALID_SHOT_POINT_INCR   (1<<4)	/* Shot point numbering
						 * increment */
d556 1
a556 2
#define GSM_RECE_W_STATIC_COMPUTED  (1<<2)	/* receiver W statics
						 * computed */
d571 5
a575 5
/************************************************************************************/
/*                                                                                  */
/*                   POINT STRUCTURES                                               */
/*                                                                                  */
/************************************************************************************/
d589 2
a590 2
    GSMask_t valid;	     /* Validity mask for station vector:
			      * GSM_VALID_X, GSM_VALID_Y, GSM_VALID_Z */
d597 7
a603 7
    GSMask_t valid;	     /* Validity mask for map point:
			      * GSM_VALID_LONGITUDE, GSM_VALID_LATITUDE */
    GSDP_t  longitude;	     /* Longitude of map point, in decimal degrees */
    GSDP_t  latitude;	     /* Latitude of map point, in decimal degrees */
    GSXYZPoint_t coord;	     /* cartesian coordinates associated with map
			      * data point */
    GSNodeID_t node_id;	     /* Node id */
d607 3
a609 3
    GSMask_t valid;	     /* Validity mask for station vector:
			      * GSM_VALID_CDP, GSM_VALID_SP */
    GSCDP_t cdp;	     /* common depth point number */
d611 4
a614 4
	GSShotPoint_t shot_point;	/* Shot Point Number associated with
					 * point (usually 2D) */
	GSLineNumber_t line_number;	/* seismic line number (Used for time
					 * slices and random sections) */
d625 2
a626 2
    GSElevation_t datum;     /* elevation datum (used only if this line has a
			      * floating datum) */
d645 5
a649 5
/************************************************************************************/
/*                                                                                  */
/*                   Projection & Spheroid Information Structures                   */
/*                                                                                  */
/************************************************************************************/
d661 1
a661 1
 /************************************************************************
d666 1
a666 1
 ************************************************************************/
d672 1
a672 1
 /*************************************************************************
d836 1
a836 1
  **************************************************************************
d852 1
a852 1
  **************************************************************************
d870 1
a870 1
  **************************************************************************
d877 1
a877 1
  **************************************************************************
d883 1
a883 1
  **************************************************************************
d897 1
a897 1
  *************************************************************************/
d901 4
a904 5
    GSLongInt_t projection_type;	/* USGS(or equiv) Projection Type
					 * Code */
    GSLongInt_t projection_unit;	/* UOM for Projection. NOTE: NOT used
					 * in other uom character string
					 * structures... */
d911 5
a915 5
/************************************************************************************/
/*                                                                                  */
/*                     Surface Geometry Representations                             */
/*                                                                                  */
/************************************************************************************/
d926 2
a927 4
    GSVector_t x;	     /* Vector of x-coordinate values (4 or 8 byte
			      * floats) */
    GSVector_t y;	     /* Vector of y-coordinate values (4 or 8 byte
			      * floats) */
d967 14
a980 14
    GSReal_t angle;	     /* Grid rotation angle measured from the
			      * horizontal.  Angles are in degrees and open
			      * positively in the counter clockwise
			      * direction. */
    GSLongInt_t nrows;	     /* Number of rows in the grid. */
    GSLongInt_t ncols;	     /* Number of columns in the grid. */
    GSBoolean_t fl_honored;  /* Faults honored during gridding flag. FALSE:
			      * Fault information not used. TRUE: Fault
			      * information was used. */
    GSVector_t zvals;	     /* Grid values: Storage order is row 1 to row
			      * 'nrows' of column 1 followed by the row
			      * values of columns 2 through column 'ncols'
			      * element_format = GSV_REAL; element_size =
			      * either sizeof (GSReal_t) or sizeof (GSDP_t) */
d982 3
a984 3
    GSMask_t valid;	     /* Validity mask for existence of xvals and
			      * yvals that follow (GSM_VALID_X or
			      * GSM_VALID_Y) */
d1004 9
a1012 9
    GSLongInt_t inc_type;    /* Type contour incrementing used. 0: User
			      * specified contour range defined by low
			      * contour value, high contour value and contour
			      * increment. n: n-contour values specified
			      * explicitly by value. */
    GSVector_t inc_levels;   /* Vector of user specified contour levels.  The
			      * number of levels does not necessarily match
			      * the actual z values See 'inc_type' above. (4
			      * or 8 byte float) */
d1014 14
a1027 16
    GSVector_t z_vals;	     /* Z-values for each contour segment stored. The
			      * number of Z values matches the number of
			      * segments described in the endpts vector.  The
			      * number of Z values does not necessarily match
			      * the number of levels described in inc_levels
			      * (4 or 8 byte float) */
    GSVector_t endpts;	     /* Vector of zero-based indices in
			      * x,y-coordinate arrays where each contour
			      * segment terminates.  Each value stored in
			      * 'endpts' is associated with the corresponding
			      * contour level stored in 'z_vals'.  (4 byte
			      * integer) */
    GSVector_t x;	     /* Vector of contour x-coordinate values. (4 or
			      * 8 byte floats) */
    GSVector_t y;	     /* Vector of contour y-coordinate values. (4 or
			      * 8 byte floats) */
d1031 5
a1035 5
/************************************************************************************/
/*                                                                                  */
/*            Seismic Geometry Specification and Location Structures                */
/*                                                                                  */
/************************************************************************************/
d1047 2
a1048 2
    } cdp_sp_reg_flag;	     /* Flag indicates whether or not a regular
			      * correspondence exists between cdp and sp */
d1055 13
a1067 13
    GSVector_t seismic_transducer;	/* Vector of station location
					 * structures This information
					 * describes the field data for the
					 * seismic line without regard to any
					 * seismic data processing. It is
					 * usually obtained from a 'UKOOA'
					 * file. The entries in this vector
					 * are ordered geographically, such
					 * that traversing the vector never
					 * causes a segment on the earth's
					 * surface to be passed over more
					 * than once (Not used for surface
					 * set - use Segment_t list) */
d1106 5
a1110 5
/************************************************************************************/
/*                                                                                  */
/*            Seismic Survey Structures                                             */
/*                                                                                  */
/************************************************************************************/
d1150 2
a1151 2
    GSDistance_t cdp_interval;	/* distance between cdps for this processed
				 * line (may be different than survey design) */
d1160 2
a1161 4
    GSRational_t cdp_incr;   /* cdp number increment per trace (zero if
			      * invalid) */
    GSRational_t shotpoint_incr;	/* shotpoint increment per trace
					 * (zero if invalid) */
d1163 5
a1167 6
    GSVector_t shot_info_table;	/* type GSShotPoint_t which tie into the
				 * GSSeismicLoc2d_t vector in the
				 * GSSeismicLine_t structure */
    GSVector_t receiver_info_table;	/* type GSShotPoint_t which tie into
					 * the GSSeismicLoc2d_t vector in the
					 * GSSeismicLine_t structure */
d1285 5
a1289 5
/************************************************************************************/
/*                                                                                  */
/*                          SEISMIC SURFACE STRUCTURES                              */
/*                                                                                  */
/************************************************************************************/
d1344 5
a1348 5
/************************************************************************************/
/*                                                                                  */
/*                          FAULT TRACE STRUCTURES                                  */
/*                                                                                  */
/************************************************************************************/
d1393 5
a1397 5
/************************************************************************************/
/*                                                                                  */
/*                          SURFACE  STRUCTURES                                     */
/*                                                                                  */
/************************************************************************************/
d1490 5
a1494 5
/************************************************************************************/
/*                                                                                  */
/*                               MAP STRUCTURES                                     */
/*                                                                                  */
/************************************************************************************/
d1588 5
a1592 5
/************************************************************************************/
/*                                                                                  */
/*                          LEGAL DESCRIPTION STRUCTURE                             */
/*                                                                                  */
/************************************************************************************/
d1659 5
a1663 5
/************************************************************************************/
/*                                                                                  */
/*                             GENERAL WELL STRUCTURES                              */
/*                                                                                  */
/************************************************************************************/
d1683 5
a1687 5
/************************************************************************************/
/*                                                                                  */
/*                            WELL HEADER STRUCTURE                                 */
/*                                                                                  */
/************************************************************************************/
d1810 5
a1814 5
/************************************************************************************/
/*                                                                                  */
/*                             WELL CORE STRUCTURE                                  */
/*                                                                                  */
/************************************************************************************/
d1830 5
a1834 5
/************************************************************************************/
/*                                                                                  */
/*                     Remarks, Miscellaneous well information                      */
/*                                                                                  */
/************************************************************************************/
d1856 5
a1860 5
/************************************************************************************/
/*                                                                                  */
/*                             LOG RUN AND TRACE STRUCTURE                          */
/*                                                                                  */
/************************************************************************************/
d1959 5
a1963 5
/************************************************************************************/
/*                                                                                  */
/*                           ZONE DEFINITIONS                                       */
/*                                                                                  */
/************************************************************************************/
d1998 5
a2002 5
/************************************************************************************/
/*                                                                                  */
/*                          PRODUCTION HISTORY STRUCTURE                            */
/*                                                                                  */
/************************************************************************************/
d2020 5
a2024 5
/************************************************************************************/
/*                                                                                  */
/*                          TUBULAR PRODUCTS STRUCTURE                              */
/*                                                                                  */
/************************************************************************************/
d2045 5
a2049 5
/************************************************************************************/
/*                                                                                  */
/*                           WELL MARKER STRUCTURES                                 */
/*                                                                                  */
/************************************************************************************/
d2126 5
a2130 5
/************************************************************************************/
/*                                                                                  */
/*                           WELL TEST STRUCTURES                                   */
/*                                                                                  */
/************************************************************************************/
d2141 5
a2145 5
/************************************************************************************/
/*                                                                                  */
/*                    TOP STRUCTURES FOR EACH DATA TYPE                             */
/*                                                                                  */
/************************************************************************************/
d2289 5
a2293 5
/************************************************************************************/
/*                                                                                  */
/*                    STATUS STRUCTURE                                              */
/*                                                                                  */
/************************************************************************************/
d2311 5
a2315 5
/************************************************************************************/
/*                                                                                  */
/*                    CONTEXT STRUCTURES                                            */
/*                                                                                  */
/************************************************************************************/
d2369 5
a2373 5
/************************************************************************************/
/*                                                                                  */
/*                    EXECUTIVE STRUCTURES                                          */
/*                                                                                  */
/************************************************************************************/
d2539 5
a2543 5
/************************************************************************************/
/*                                                                                  */
/*                    RECEIVER CAPABILITY STRUCTURES                                */
/*                                                                                  */
/************************************************************************************/
d2589 2
a2590 4
#define GSM_WELL_WELL_MARKER   (1<<5)	/* Well marker(tops) data are
					 * supported */
#define GSM_WELL_PRODUCTION    (1<<6)	/* Production history data are
					 * supported */
d2607 2
a2608 4
    GSString_t receiver_name;/* Unique character identifier of receiver (<=20
			      * characters ) */
    GSString_t banner_string;/* Your chance to advertise your product! (<=60
			      * characters ) */
d2634 5
a2638 5
/************************************************************************************/
/*                                                                                  */
/*                    END OF INCLUDE FILE GEOSCIENCE.H                              */
/*                                                                                  */
/************************************************************************************/
@


1.7
log
@*** empty log message ***
@
text
@d1500 1
a1500 1
    GSVector_t surface_surface_intersection	/* vector of surface surface
@


1.6
log
@*** empty log message ***
@
text
@d369 2
a370 2
    GSLongInt_t major;	     /* Major version number */
    GSLongInt_t revision;    /* Revision number of structure */
d2425 112
a2536 16
    GS_STRUCT_UNKNOWN = 0,   /* structure unknown to GeoShare is passed,
			      * check type_ext for value */
    GS_STRUCT_RECEIVER_SPECS = 1,
    GS_STRUCT_RECEIVER_RQMTS = 2,
    GS_STRUCT_CONTEXT_RQMTS = 3,
    GS_STRUCT_CONTEXT_INFO = 4,
    GS_STRUCT_CONTEXT_TOKEN = 5,
    GS_STRUCT_STATUS_VECTOR = 6,
    GS_STRUCT_SEISMIC_SURVEY = 11,
    GS_STRUCT_SURFACE_SET = 12,
    GS_STRUCT_WELL_FIELD = 13,
    GS_STRUCT_WELL_TIE = 14,
    GS_STRUCT_MAP = 15,
    GS_STRUCT_FAULT_TRACE_SET = 16,
    GS_STRUCT_LITHOSTRAT_CODES = 17,
    GS_STRUCT_ZONES = 18
@


1.5
log
@reformatted.
@
text
@d2362 1
@


1.4
log
@new one from john
@
text
@a0 1

d5 1
a5 1
| 
d9 2
a10 2
| 
|         This code is the product of GeoQuest Systems, Inc. and Finder 
d14 1
a14 1
| 
d19 1
a19 1
|              Current working title of system : GeoShare (generic) 
a23 2
| 
|   Notes:     
d25 2
d28 1
a28 1
|                  Original code.  
d56 1
a56 1
|                      that the tentative executive(Pres, VP, etc.) 
d58 1
a58 1
|                  Made adjustments to the executive level structures.    
d84 2
a85 1

a90 2
/*
We have assumed an ANSI C model throughout this structure.
d92 140
a231 107
On naming conventions

All symbolic (enum) constants begin with GS_ .  All masks begin with GSM_, and all
vector data types begin with GSV_.  All symbolic constants are upper case.

Data typedefs are named using mixed case beginning with GS and ending with _t, as in
GSSurfaceSetName_t.

GSVectors are arrays of objects.  The name of the vector is either the lower-case name
of a typedef with the leading GS and trailing _t stripped off ans underscores appearing
where a case change occurs (e.g. an array of GSDepths_t becomes GSVector_t depths and
GSSurfaceSet_t becomes GSVector_t surface_set) or the name of a scalar value, in which
case the possible element types and sizes are listed in the comment of the variable

On typedefs

Where a data domain is referred to in more than one structure, it is generally given its
own typedef.  This may obscure the reading of the structure for the novice, but assists
in implementing code which asserts domain restrictions, as with object programming
languages (e.g. C++), and helps in the maintainance of the structure. It also assists in
writing code that can be rigorously checked by the compiler.

On surface sets

A surface set is a collection of surfaces usually associated with some geological or
geophysical 'event', such as a seismic horizon or a geological formation or marker. This
surface set is given a name.  In common usage, this corresponds to a formation name
(geological) or a seismic horizon (geophysical).  Surfaces sets can be represented by
grids, contours, scatter (xyz) sets, well picks, seismic line cross- sections.

It is possible to reach the GSSeismicSurface_t structure through two paths.  When the
top-level structure (in Structure_t) is GSSurfaceSet_t, then this top-level structure
defines which surface is being modelled.  In this case, it is an error to enter a
different SurfaceSetName in the GSSeismicSurface_t structure from the top-level
SurfaceSetName.  When the top-level structure is GSSeismicSurvey_t, then any number of
SurfaceSetNames are allowed in the GSSeismicSurface_t structure.  The two questions
being addressed are "Show all data representing this surface" and "Show all data
associated with this seismic survey".

Similarly, it is possible to reach GSWellMarker_t from either the SurfacSet_t structure
or the GSField_t structure.  As with seismic horizons entered through the GSSurfaceSet_t
structure, it is an error to enter a different SurfaceSetName in the GSWellMarker_t
structure from the top-level SurfaceSetName.  When the top-level structure is GSField_t,
then any number of SurfaceSetNames are allowed in the GSWellMarker_t structure.  The two
questions being addressed are "Show all data representing this surface" and "Show all
data associated with this well".

On Shot Points, CDPs and Trace Numbers

There are at least three different coordinate systems used to describe points along
a seismic line.  The location of an energy source is described as a shot point.  This
point is given a (numeric) label, and occasionally a reshot character.  There is no
guarantee that the ordering of shot points along a line are regular nor predictable.
For each shot there are many receivers.  Normally, these receivers correspond to the
location of shot points.

Depending  on how the seismic data are processed, one or more common depth points are
determined.  Often there are two CDPs per shot point, but this can vary.  For straight
lines, the location of some CDPs correspond to shot point locations.  In the case of
two CDPs per shot point, every other CDP location would correspond to a shot point
location.  There is no convention for numbering these CDP locations, nor for relating them
to shot points.  In this file, a lookup/interpolation scheme is adopted.

When a set of traces are processed, they are sequentially numbered, usually starting at one.
These traces usually correspond one to one with a CDP.  There is usually a predictable
relationship between trace number and CDP number, but not necessarily between a trace
number and a shot point.  Two different trace files may not have the same relationship
between trace numbers and CDPs; this is especially true when different parts of a seismic line
are separately processed.

Since the location of a shot point is not dependent on a trace file, it is modeled
under the GSSeismicLine_t structure.  Also at this level are recorded information which
describes the near-surface characteristics and datum information, i.e. any information
which describes the earth at a position without regard to seismic trace data processing.

Since seismic shot points are often regularly spaced and predictable, it is not always necessary
to explicitly store each shot point number and location.  If intervening values can be calculated
by simple linear interpolation, then they do not have to be explicitly listed.  Any structure
which rerefers to a seismic station location can refer to the GSSeismicLoc2d by an index number.
This index may point directly to an actual entry, or may refer to an entry which lies between
two valid entries.  In this way, points determined to lie between known locations can be inferred,
as when two surfaces intersect at a point other than a shot point location.

On nulls

Each sender is responsible for setting a null value to be consistently used for integers
and floating point values.  The sender should always fill unknown values with these
constants when the data are not available.  The receiver is obliged to always compare
the data elements with the receiver's null value to determine if the scalar contains a
valid entry.

On strings

Character strings are represented as a vector with element_format = GSV_CHAR,
element_size = sizeof (CHAR) and number_elements = the number of characters in the
string NOT including any trailing null byte.  The strings are NOT guaranteed to be null
terminated.

On receiver specifications

The receiver is expected to state what data types it can support by using the
GSDataSupported_t structure component of the ReceiverSpecs_t structure.  Additionally,
the receiver specifies which of the detail components of the top-level structure it can
process.  This 'hint' can then be used by the sender in preparing a data set for
transmission.  For instance, there is no need to perform a data selection on 3-D seismic
data if the receiver cannot support 3-D data.  It is still permitted to send these data;
the receiver should ignore any data it cannot process.
d233 1
a233 13
On status reporting

The receiver is responsible for providing two levels of status reporting: problem or
informational reporting to a user interface, and journalling of results to a logging
'file'.  The former is used to inform the user of a potential problem or exception
condition that may require additional interaction, and the latter is used to chronicle
the successful processing of information. It may be desirable to inform the user at a
specific terminal/workstation about a transfer status and to store summary information
in a central repository, such as the name of a file that was used to store the
information received.

*/
/************************************************************************************/
d239 4
a242 4
typedef long GSLongInt_t;           /* Long integer (usually 4 bytes) */
typedef float GSReal_t;             /* Single precision floating point */
typedef double GSDP_t;              /* Double precision floating point */
typedef unsigned long int GSUlong_t;    /* Unsigned long integer */
d245 2
a246 1
typedef long GSMask_t;              /* Bit mask, used to identify item validity in structures */
d248 1
a248 2
typedef struct                      /* structure for a rational number */
    {
d251 1
a251 1
    } GSRational_t;
d253 2
a254 1
/************************************************************************************/
d260 4
a263 2
/* Basic to the interchange design is that of a vector structure which is
  specified by the following declarations: */
d265 72
a336 72
typedef enum 
    {
    GSV_UNKNOWN = 0,                /* vector type is unknown, check extension */
    /* basic data types */
    GSV_INT = 10,                   /* vector type GSLongInt_t */
    GSV_REAL = 11,                  /* vector type GSReal_t */
    GSV_DP = 12,                    /* vector type GSDP_t */
    GSV_FRAC8 = 13,                 /* vector type 8 bit int fraction */
    GSV_FRAC16 = 14,                /* vector type 16 bit int fraction */
    GSV_UNSIGNED_LONG = 15,         /* vector type GSUlong_t */
    GSV_BOOLEAN = 16,               /* vector type GSBoolean_t */
    GSV_RATIONAL = 17,              /* vector type GSRational_t */
    GSV_CHAR = 18,                  /* vector type char */
    GSV_COMPLEX = 19,               /* vector type complex */
    GSV_STRING = 20,                /* vector type GSString_t */
    /* executive structure vectors */
    GSV_RECEIVER_RQMTS = 100,       /* vector type GSReceiverRqmts_t */
    GSV_DATA_SUPPORTED = 101,       /* vector type GSDataSupported_t */
    GSV_GSSTRUCTURE = 102,          /* vector type GSStructure_t */
    GSV_RECEIVER_CONTEXT = 103,     /* vector type GSReceiverContext_t */
    GSV_STATUS_RETURN = 104,        /* vector type GSStatusReturn_t */
    /* basic point structures */
    GSV_XYZ_POINT = 1000,           /* vector type GSXYZPoint_t */
    GSV_SEISMIC_DATA_POINT = 1001,  /* vector type GSSeismicDataPoint_t */
    GSV_MAP_LOCATION = 1002,        /* vector type GSMapLocation_t */
    GSV_DEPTHS = 1003,              /* vector type GSDepth_t */
    GSV_PROCESS_HISTORY = 1004,     /* vector type GSProcessHistory_t; */
    /* stratigraphic data structures */
    GSV_STRAT_COLUMN = 2000,        /* vector type GSStratigraphicColumn_t */
    GSV_LITHOSTRAT_CODE_DESC = 2001,    /* vector type GSLithostratCodeDesc_t */
    /* zone structures */
    GSV_ZONE_VARIABLE_DEF = 3000,   /* vector type GSZoneVariableDefinition_t */
    GSV_ZONE_DEF = 3001,            /* vector type GSZoneDefinition_t */
    GSV_ZONE_VALUE = 3002,          /* vector type GSZoneValue_t */
    /* well structures */
    GSV_WELL_REMARKS = 4001,        /* vector type GSWellRemarks_t */
    GSV_WELL_TUBULARS = 4002,       /* vector type GSWellTubulars_t */
    GSV_WELL_PRODUCTION = 4003,     /* vector type GSWellProduction_t */
    GSV_WELL_MARKER = 4004,         /* vector type GSWellMarker_t */
    GSV_WELL_CORE = 4005,           /* vector type GSWellCore_t */
    GSV_WELL_ATTRIBUTE = 4006,      /* vector type GSWellAttribute_t */
    GSV_WELL_HDR = 4007,            /* vector type GSWellHdr_t */
    GSV_WELL_TEST_HDR = 4008,       /* vector type GSWellTestHdr_t */
    /* well log structures */
    GSV_LOG_RUN = 5000,             /* vector type GSLogRun_t */
    GSV_LOG_PASS = 5001,            /* vector type GSLogPass_t */
    GSV_LOG_SERVICE = 5002,         /* vector type GSLogService_t */
    GSV_LOG_TRACE = 5003,           /* vector type GSLogTrace_t */
    /* seismic data structures */
    GSV_SEISMIC_TRACE = 6000,       /* vector type GSSeismicTrace_t */
    GSV_SEISMIC_CLASS = 6001,       /* vector type GSSeismicClass_t */
    GSV_SEISMIC_LINE = 6002,        /* vector type GSSeismicLine_t */
    GSV_SEISMIC_SURFACE = 6003,     /* vector type GSSeismicSurface_t */
    GSV_SEISMIC_TRANSDUCER = 6004,  /* vector type GSSeismicTransducer_t */
    /* map object structures */
    GSV_MAP_POLYLINE = 7000,        /* vector type GSMapPolyline_t */
    GSV_MAP_POINT = 7001,           /* vector type GSMapPoint_t */
    GSV_MAP_SYMBOL = 7002,          /* vector type GSMapSymbol_t */
    GSV_MAP_ANNOTATION = 7003,      /* vector type GSMapAttribute_t */
    GSV_MAP_ATTRIBUTE = 7004,       /* vector type GSMapAnnotation_t */
    GSV_MAP_OBJECTS = 7005,         /* vector type GSMapObjects_t */
    GSV_ATTRIBUTE_ITEM = 7006,      /* vector type GSAttributeItem_t */
    /* seismic interpretation surface structures */
    GSV_CONTACT = 8000,             /* vector type GSContact_t */
    GSV_SEGMENT = 8001,             /* vector type Segment_t */
    /* fault trace structures */
    GSV_FAULT_TRACE = 9000,         /* vector type FaultTrace_t */
    GSV_FAULT_SURFACE = 9001,       /* vector type FaultSurface_t */
    /* surface executive structures */
    GSV_SURFACE_ATTRIBUTE = 10000,  /* vector type SurfaceAttribute_t */
    GSV_SURFACE_GEOMETRY = 10001    /* vector type SurfaceGeometry_t */
    } GSVectorType_t;
d338 1
a338 2
typedef struct 
    {
d344 1
a344 1
    } GSVector_t;
d346 4
a349 2
/*  ALL strings will be stored as vectors,  the typedef GSString_t is defined as a
    convenience and a vector type differentiator */
d353 10
a362 10
typedef GSString_t GSDate_t;        /* Standard date format is YYYYMMDDHHMNNSS.SS
                                       YYYY from 0000 to 9999 (year)
                                       MM from 01 to 12 (month of year)
                                       DD from 01 to 31 (day of month)
                                       HH from 00 to 23 (hour of day)
                                       MN from 00 to 59 (minute of hour)
                                       SS.SS from 0 to 59.99(seconds in minute)
                                       Any component may be truncated
                                       (e.g.April 1987 is entered as 198704) */
/************************************************************************************/
d368 5
a372 6
typedef struct 
    {
    GSLongInt_t major;              /* Major version number */
    GSLongInt_t revision;           /* Revision number of structure */
    GSString_t vendor;              /* Vendor that provided latest revision */
    } GSVersion_t;
d374 2
a375 1
/************************************************************************************/
d381 3
a383 3
typedef GSLongInt_t GSNodeID_t;     /* node identifier */
typedef GSString_t GSPlotSymbol_t;  /* Graphics plot symbol name */
typedef GSString_t GSUWI_t;         /* Unique Well Identifier */
d385 1
a385 1
typedef GSString_t GSSurfaceSetName_t;  /* Name of a surface set */
d387 2
a388 2
/* 
 *       Geophysical data types 
d391 4
a394 4
typedef GSRational_t GSShotPoint_t; /* Seismic shot point */
typedef GSRational_t GSCDP_t;       /* Common depth point */
typedef GSRational_t GSLineNumber_t;    /* Seismic line number */
typedef GSReal_t GSStatic_t;        /* Seismic static correction value */
d400 5
a404 6
typedef enum 
    {
    GS_SRF_TYPE_UNKNOWN = 0,        /* surface type unknown */
    GS_SRF_TYPE_HOR = 1,            /* surface type horizon */
    GS_SRF_TYPE_FLT = 2             /* surface type fault */
    } GSSurfaceType_t;
d406 7
a412 8
typedef enum                        /* z value code */
    {
    GS_Z_VALUE_UNDEFINED = 0,       /* no z value is defined */
    GS_Z_VALUE_TIME = 1,            /* z value is time */
    GS_Z_VALUE_UNSNAPPED_TIME = 2,  /* z value is unsnapped time */
    GS_Z_VALUE_AMPLITUDE = 3,       /* z value is amplitude */
    GS_Z_VALUE_DEPTH = 4            /* z value is depth */
    } GSZValueCode_t;
d414 12
a425 13
typedef enum 
	{
	GS_SNAP_P_NEAR = 1,         /* nearest peak to center of window */
	GS_SNAP_P_MAX = 2,          /* largest peak in window           */
	GS_SNAP_T_NEAR = 3,         /* nearest trough to center of window */
	GS_SNAP_T_MAX = 4,          /* largest trough in window         */
	GS_SNAP_ZPN = 5,            /* zero crossing, positive to negative*/
	GS_SNAP_ZNP = 6,            /* zero crossing, negative to positive*/
	GS_SNAP_NULL = 7,           /* snap to input point */
	GS_SNAP_UNDEFINED = 8       /* undefined snap type */
	} GSSnapEvent_t;
/* 
 *      Seismic Line type 
d428 7
a434 8
typedef enum 
    {
    GS_LINE_2D = 30,                /* line type 2d */
    GS_LINE_3DI = 31,               /* line type 3d inline */
    GS_LINE_XLN = 32,               /* line type 3d cross line */
    GS_LINE_TSL = 33,               /* line type 3d time slice */
    GS_LINE_RANDOM = 34             /* line type 3d random(reconstruction) cut */
    } GSLineType_t;
d436 2
a437 2
/*    
 *       Processing History structure           
d439 1
a439 2
typedef struct 
    {
d443 1
a443 1
    } GSProcessingHistory_t;
d449 2
a450 3
typedef struct 
    {
    GSLongInt_t n_live;             /* number of non-zero samples */
d458 1
a458 1
    } GSAmplitudeStats_t;
d464 1
a464 2
typedef enum 
    {
d467 1
a467 1
    } GSPolyLineType_t;
d469 2
a470 1
/************************************************************************************/
d476 1
a476 1
/* 
d480 5
a484 5
typedef struct 
    {
    GSString_t type;                /* DISTANCE, TIME, VOLUME, WEIGHT, TEMPERATURE, etc */
    GSString_t unit;                /* Unit (FEET, SECONDS) or expression (G/CC) */
    } GSUnit_t;
d486 5
a490 5
typedef struct 
    {
    GSDP_t value;                   /* value of measurement */
    GSUnit_t uom;                   /* unit of measure, including the measurement system and the actual unit */
    } GSMeasurement_t;
d492 20
a511 9
typedef GSMeasurement_t GSTemperature_t;    /* Special case of a measurement where uom.type = "TEMPERATURE" */
typedef GSMeasurement_t GSResistivity_t;    /* Special case of a measurement where uom.type = "RESISTIVITY" */
typedef GSMeasurement_t GSTime_t;   /* Special case of a measurement where uom.type = "TIME" */
typedef GSMeasurement_t GSVelocity_t;   /* Special case of a measurement where uom.type = "VELOCITY" */
typedef GSMeasurement_t GSWeight_t; /* Special case of a measurement where uom.type = "WEIGHT" */
typedef GSMeasurement_t GSDistance_t;   /* Special case of a measurement where uom.type = "DISTANCE"
                                         and implication that measurement is made in horizontal sense */
typedef GSMeasurement_t GSElevation_t;  /* Special case of a measurement where uom.type = "DISTANCE"
                                         and implication that measurement is made in vertical sense */
d513 5
a517 5
typedef struct 
    {                               /* structure describing reference elevation */
    GSElevation_t val;              /* Elevation to use for subsea corrections */
    GSString_t ref;                 /* Data type being used as elevation reference (KB, DF, GS, SL, etc) */
    } GSElevationRef_t;
d519 2
a520 1
/************************************************************************************/
d527 9
a535 8
#define GSM_VALID_CDP          (1<<0)   /* cdp number is valid */
#define GSM_VALID_SP           (1<<1)   /* shot point number is valid */
#define GSM_VALID_X            (1<<2)   /* x location is valid */
#define GSM_VALID_Y            (1<<3)   /* y location is valid */
#define GSM_VALID_Z            (1<<4)   /* z location is valid */
#define GSM_VALID_LONGITUDE    (1<<5)   /* longitude is valid */
#define GSM_VALID_LATITUDE     (1<<6)   /* latitude is valid */
#define GSM_VALID_CONNECT      (1<<7)   /* connectivity vector in xyz scatter data */
d538 6
a543 6
#define GSM_VALID_MD           (1<<8)   /* measured depth is valid */
#define GSM_VALID_SUBDATUM     (1<<9)   /* subdatum depth is valid */
#define GSM_VALID_TVD          (1<<10)  /* true vertical depth is valid */
#define GSM_VALID_TIME         (1<<11)  /* time is valid */
#define GSM_VALID_DX           (1<<12)  /* deviation in x direction is valid */
#define GSM_VALID_DY           (1<<13)  /* deviation in y direction is valid */
d545 14
a558 12
#define GSM_VALID_CDP_PER_SP        (1<<0)     /* Nominal number of cdps per shot point */
        
#define GSM_VALID_CDP_1             (1<<1)     /* Initial cdp (index) number */
#define GSM_VALID_SHOT_POINT_1      (1<<2)     /* Initial shot point number */ 
#define GSM_VALID_CDP_INCR          (1<<3)     /* CDP numbering increment */
#define GSM_VALID_SHOT_POINT_INCR   (1<<4)     /* Shot point numbering increment */
#define GSM_VALID_MIN_SHOTPOINT     (1<<5)     /* minimum shotpoint */
#define GSM_VALID_MAX_SHOTPOINT     (1<<6)     /* maximum shotpoint */
#define GSM_VALID_MIN_RECEIVER      (1<<7)     /* minimum receiver location */
#define GSM_VALID_MAX_RECEIVER      (1<<8)     /* maximum receiver location */
#define GSM_VALID_MIN_CDP           (1<<9)     /* minimum cdp */
#define GSM_VALID_MAX_CDP           (1<<10)    /* maximum cdp */
d560 19
a578 17
#define GSM_SHOT_W_STATIC_COMPUTED  (1<<0)  /* shot W statics computed */
#define GSM_SHOT_W_STATIC_APPLIED   (1<<1)  /* shot W statics applied */
#define GSM_RECE_W_STATIC_COMPUTED  (1<<2)  /* receiver W statics computed */
#define GSM_RECE_W_STATIC_APPLIED   (1<<3)  /* receiver W statics applied */
#define GSM_SHOT_D_STATIC_COMPUTED  (1<<4)  /* shot D static computed */
#define GSM_SHOT_D_STATIC_APPLIED   (1<<5)  /* shot D static applied */
#define GSM_RECE_D_STATIC_COMPUTED  (1<<6)  /* receiver D static computed */
#define GSM_RECE_D_STATIC_APPLIED   (1<<7)  /* receiver D static applied */
#define GSM_SHOT_A_STATIC_COMPUTED  (1<<8)  /* shot A static computed */
#define GSM_SHOT_A_STATIC_APPLIED   (1<<9)  /* shot A static applied */
#define GSM_RECE_A_STATIC_COMPUTED  (1<<10) /* receiver A static computed */
#define GSM_RECE_A_STATIC_APPLIED   (1<<11) /* receiver A static applied */
#define GSM_CDP_A_STATIC_COMPUTED   (1<<12) /* cdp A static computed */
#define GSM_CDP_A_STATIC_APPLIED    (1<<13) /* cdp A static applied */
#define GSM_BULK_STATIC_COMPUTED    (1<<14) /* bulk static computed */
#define GSM_BULK_STATIC_APPLIED     (1<<15) /* bulk static applied */
/************************************************************************************/
d584 10
a593 7
/*  Other structures are basic to data interchange, that of a single point. 
    The following is the structure for a single point.  A mask will be provided in
    association with each use of this structure (or vector of this structure)
    indicating which components of the structure are valid.  For example, x and y
    may not be necessary to transfer interpretation.  Further the exact meaning of
    the elements of this structure will be context dependent (i. e., the z element
    may contain a time value for interpretation). */
d595 7
a601 8
typedef struct 
    {
    GSMask_t valid;                 /* Validity mask for station vector:
                                      GSM_VALID_X, GSM_VALID_Y, GSM_VALID_Z */
    GSDP_t x;                       /* x coordinate value associated with point */
    GSDP_t y;                       /* y coordinate value associated with point */
    GSDP_t z;                       /* z coordinate value associated with point */
    } GSXYZPoint_t;
d603 9
a611 9
typedef struct 
    {
    GSMask_t valid;                 /* Validity mask for map point:
                                      GSM_VALID_LONGITUDE, GSM_VALID_LATITUDE */
    GSDP_t longitude;               /* Longitude of map point, in decimal degrees */
    GSDP_t latitude;                /* Latitude of map point, in decimal degrees */
    GSXYZPoint_t coord;             /* cartesian coordinates associated with map data point */
    GSNodeID_t node_id;             /* Node id */
    } GSMapLocation_t;
d613 12
a624 12
typedef struct 
    {
    GSMask_t valid;                 /* Validity mask for station vector:
                                        GSM_VALID_CDP, GSM_VALID_SP */
    GSCDP_t cdp;                    /* common depth point number */
    union 
        {
        GSShotPoint_t shot_point;   /* Shot Point Number associated with point (usually 2D) */
        GSLineNumber_t line_number; /* seismic line number (Used for time slices and random sections) */
        } y;
    GSMapLocation_t map_loc;        /* location associated with cdp/shot point */
    } GSSeismicDataPoint_t;
d626 3
a628 2
/*    Shot/receiver/cdp information table
      ----------------------------------- */
d630 10
a639 10
typedef struct                      /* for shot/receiver/cdp */
    {
    GSSeismicDataPoint_t seismic_loc;   /* SP number, location & elevation */
    GSElevation_t datum;            /* elevation datum (used only if this line has a floating datum) */
    GSElevation_t wdepth;           /* depth of weathering layer */
    GSVelocity_t wvel;              /* velocity of weathering layer */
    GSStatic_t wstatic;             /* weathering static */
    GSStatic_t dstatic;             /* datum static */
    GSStatic_t astatic;             /* automatic static */
    } GSSeismicTransducer_t;
d641 4
a644 10
typedef struct 
    {
    GSDP_t xmin;
    GSDP_t ymin;
    GSDP_t zmin;
    
    GSDP_t xmax;
    GSDP_t ymax;
    GSDP_t zmax;
    } GSExtents_t;
d646 7
a652 1
/************************************************************************************/
d658 9
a666 8
/*   Projection Information
      ----------------------
 
We will assume all location information contained within a data
structure is given in the same coordinate system.  To properly define the
coordinate system the following two structures are used to specify the
projection which was used.  the structures are based on the USGS projection
package. and the projection codes are those used by USGS. */
d668 1
a668 1
/************************************************************************
d673 1
a673 1
************************************************************************/
d679 2
a680 2
/*************************************************************************
Definition of Transformation Parameter Fields by Projection Type Code
d682 2
a683 19
Type 0
    No parameters are required for this reference system.
    
Type 1
    1 = Semimajor axis of ellipsoid; if '0.0', the value for Clarke's 1966
        spheroid in meters will be assumed.
    2 = Eccentricity squared of ellipsoid.  If '0.0', a sphere is indicated.
        If > '1.0', field contains semiminor axis of ellipsoid.
    3 = Longitude of any point within the zone.
    4 = Latitude of any point within the UTM zone.
    
    Parms 3 & 4 will be used to determine UTM zone number when a zone
    number of '0' is specified.
    
Type 2
    1 = Semimajor axis of ellipsoid; if '0.0', the value for Clarke's 1966
        spheroid in meters will be assumed.
    2 = Eccentricity squared of ellipsoid.  If '0.0', a sphere is indicated.
        If > '1.0', field contains semiminor axis of ellipsoid.
d685 7
a691 21
Type 3,4
    1 = Semimajor axis of ellipsoid; if '0.0', the value for Clarke's 1966
        spheroid in meters will be assumed.
    2 = Eccentricity squared of ellipsoid.  If '0.0', a sphere is indicated.
        If > '1.0', field contains semiminor axis of ellipsoid.
    3 = Latitude of first standard parallel.
    4 = Latitude of second standard parallel.
    5 = Longitude of central meridian.
    6 = Latitude of projection's origin.
    7 = False easting.
    8 = False northing.
    
Type 5,7
    1 = Semimajor axis of ellipsoid; if '0.0', the value for Clarke's 1966
        spheroid in meters will be assumed.
    2 = Eccentricity squared of ellipsoid.  If '0.0', a sphere is indicated.
        If > '1.0', field contains semiminor axis of ellipsoid.
    5 = Longitude of central meridian.
    6 = Latitude of projection's origin.
    7 = False easting.
    8 = False northing.
d693 2
a694 9
Type 6
    1 = Semimajor axis of ellipsoid; if '0.0', the value for Clarke's 1966
        spheroid in meters will be assumed.
    2 = Eccentricity squared of ellipsoid.  If '0.0', a sphere is indicated.
        If > '1.0', field contains semiminor axis of ellipsoid.
    5 = Longitude directed straight down below pole of map.
    6 = Latitude of true scale.
    7 = False easting.
    8 = False northing.
d696 5
a700 36
Type 8
    Case A - Single Standard Parallel
    1 = Semimajor axis of ellipsoid; if '0.0', the value for Clarke's 1966
        spheroid in meters will be assumed.
    2 = Eccentricity squared of ellipsoid.  If '0.0', a sphere is indicated.
        If > '1.0', field contains semiminor axis of ellipsoid.
    3 = Latitude of standard parallel.
    5 = Longitude of central meridian.
    6 = Latitude of projection's origin.
    7 = False easting.
    8 = False northing.
    9 = 0.0
    
    Case B - Two Standard Parallels
    1 = Semimajor axis of ellipsoid; if '0.0', the value for Clarke's 1966
        spheroid in meters will be assumed.
    2 = Eccentricity squared of ellipsoid.  If '0.0', a sphere is indicated.
        If > '1.0', field contains semiminor axis of ellipsoid.
    3 = Latitude of first standard parallel.
    4 = Latitude of second standard parallel.
    5 = Longitude of central meridian.
    6 = Latitude of projection's origin.
    7 = False easting.
    8 = False northing.
    9 = Any non-zero number.
    
Type 9
    1 = Semimajor axis of ellipsoid; if '0.0', the value for Clarke's 1966
        spheroid in meters will be assumed.
    2 = Eccentricity squared of ellipsoid.  If '0.0', a sphere is indicated.
        If > '1.0', field contains semiminor axis of ellipsoid.
    3 = Scale factor at central meridian.
    5 = Longitude of central meridian.
    6 = Latitude of origin.
    7 = False easting.
    8 = False northing.
d702 11
a712 16
Type 10
    1 = Radius of the sphere of reference.  If this field is '0.0', the value 
        6370997.0 meters will be assumed.  This  the radius of a sphere with
        surface area equal to that of Clarke's 1866 ellipsoid.
    5 = Longitude of center of projection.
    6 = Latitude of center of projection.
    7 = False easting.
    8 = False northing.
    
Type 11,12,13,14
    1 = Radius of the sphere of reference.  If this field is '0.0', the value 
        6370997.0 meters will be assumed.
    5 = Longitude of center of projection.
    6 = Latitude of center of projection.
    7 = False easting.
    8 = False northing.
d714 9
a722 8
Type 15
    1 = Radius of the sphere of reference.  If this field is '0.0', the value 
        6370997.0 meters will be assumed.
    3 = Height of perspective point above sphere.
    5 = Longitude of center of projection.
    6 = Latitude of center of projection.
    7 = False easting.
    8 = False northing.
d724 9
a732 6
Type 16,18,19
    1 = Radius of the sphere of reference.  If this field is '0.0', the value 
        6370997.0 meters will be assumed.
    5 = Longitude of central meridian.
    7 = False easting.
    8 = False northing.
d734 12
a745 7
Type 17
    1 = Radius of the sphere of reference.  If this field is '0.0', the value 
        6370997.0 meters will be assumed.
    5 = Longitude of central meridian.
    6 = Latitude of true scale.
    7 = False easting.
    8 = False northing.
d747 12
a758 29
Type 20
    Format A
    1 = Semimajor axis of ellipsoid; if '0.0', the value for Clarke's 1966
        spheroid in meters will be assumed.
    2 = Eccentricity squared of ellipsoid.  If '0.0', a sphere is indicated.
        If > '1.0', field contains semiminor axis of ellipsoid.
    3 = Scale factor at center of projection.
    6 = Latitude of origin of projection.
    7 = False easting.
    8 = False northing.
    9 = Longitude of first point defining central geodetic line of projection.
   10 = Latitude of first point defining central geodetic line of projection.
   11 = Longitude of second point defining central geodetic line of projection.
   12 = Latitude of second point defining central geodetic line of projection.
   13 = 0.0
   
    Format B
    1 = Semimajor axis of ellipsoid; if '0.0', the value for Clarke's 1966
        spheroid in meters will be assumed.
    2 = Eccentricity squared of ellipsoid.  If '0.0', a sphere is indicated.
        If > '1.0', field contains semiminor axis of ellipsoid.
    3 = Scale factor at center of projection.
    4 = Angle of azimuth east of north for central line of projection.
    5 = Longitude of point along central line of projection at which
        angle of azimuth is measured.
    6 = Latitude of origin of projection.
    7 = False easting.
    8 = False northing.
   13 = Any non-zero number.
d760 10
d771 8
a778 2
**************************************************************************
Definitions of Known Projection Type Codes
d780 7
a786 12
    0  "Geographic"               11  "Lambert Azim. Equal Area"
    1  "Universal Transverse Mercator"
                                  12  "Azimuthal"
    2  "State Plane"              13  "Gnomonic"
    3  "Albers Conical Equal Area"14  "Orthographic"
    4  "Lambert Conformal Conic"  15  "General Vertical Near-Side Perspective"
    5  "Mercator"                 16  "Sinusoidal"
    6  "Polar Stereographic"      17  "Equi-Rectangular"
    7  "Polyconic"                18  "Miller Cylindrical"
    8  "Equidistant Conic"        19  "Van der Grinten"
    9  "Transverse Mercator"      20  "Oblique Mercator"
   10  "Stereographic"
d788 8
a795 2
**************************************************************************
Definitions of Known Projection Units
d797 6
a802 14
        1    "Feet"                4    Degrees of Arc
        2    "Meters"              5    Packed DMS
        3    "Seconds of Arc"
        
    DMS - packed degrees-minutes-seconds:
        +/-DDDMMSS.SSSSS
        
    where
        DDD is the degrees portion of the angle.
        MM is the minutes portion of the angle.
        SS.SSSSS is the seconds portion of the angle.
        
    The plus sign is optional.  Leading and trailing zeros are optional,
    but embedded zeros must be supplied.
d804 7
a810 2
**************************************************************************
Definitions of Zone Codes
d812 15
a826 6
    UTM - Standard zones 1-60.
    State Plane - USGS identification codes.
    Other - See notes with Projection Types.
    
**************************************************************************
Projection Name Field
d828 13
a840 5
    Normally, the projection names referenced above with the projection
    codes are included in this field.
    
**************************************************************************
Definitions of Known Spheroid Codes
a841 10
        0    "Clarke 1866"        10    "Modified Everest"
        1    "Clarke 1880"        11    "Modified Airy"
        2    "Bessel 1841"        12    "Walbeck"
        3    "International 1967" 13    "Southeast Asia"
        4    "International 1909" 14    "Australian National"
        5    "WGS 72"             15    "Krassovsky"
        6    "Everest"            16    "Hough"
        7    "WGS 66"             17    "Mercury 1960"
        8    "GRS 1980"           18    "Modified Mercury 1968"
        9    "Airy"               19    "Sphere of Radius 6370997"
d843 2
a844 1
*************************************************************************/
d846 73
a918 11
typedef struct 
    {                               /* Projection Structure Type */
    GSDP_t parms[15];               /* Transformation Parameters */
    GSLongInt_t projection_type;    /* USGS(or equiv) Projection Type Code */
    GSLongInt_t projection_unit;    /* UOM for Projection. NOTE: NOT used in other
                                     uom character string structures... */
    GSLongInt_t zone_code;          /* UTM or US State Plane Zone */
    GSLongInt_t spheroid_code;      /* USGS (or equiv) Spheroid Code */
    GSString_t proj_name;           /* Projection Name (description) */
    } GSCartoProjection_t;

d925 3
a927 3
/*    xyz scatter Information
      -----------------------
 */
d929 3
a931 4
typedef struct 
    {
    GSSurfaceSetName_t surface_set_name;    /* Surface set name */
    GSString_t attribute;           /* name of the attribute being modelled */
d933 7
a939 7
    
    GSVector_t x;                   /* Vector of x-coordinate values 
                                     (4 or 8 byte floats) */
    GSVector_t y;                   /* Vector of y-coordinate values 
                                     (4 or 8 byte floats) */
    GSVector_t z;                   /* Vector of z-values (4 or 8 byte floats) */
    
d941 31
a971 32
    GSVector_t connect;             /* Connectivity vector.  If sequences
                                     of data points are intended to be
                                     connected together, then this vector
                                     will be filled.  Normally, this would
                                     take the form of one 'connect' value
                                     for each x,y,z value and would
                                     consist of sequential integer values.
                                     All points intended to be grouped
                                     together would have the same
                                     'connect' value. '0' would indicate a
                                     scatter point not connected to any
                                     other point.  This vector need not be
                                     filled for no connected data values.
                                     (4 byte integer) */
    } GSXYZData_t;

/*    Grid Information
      ----------------
 */
typedef struct 
    {
    /* Basic grid parameters:
    xmin, ymin, xmax, ymax, row-grid distance, col-grid distance
    Note: range values in order min-to-max.  Positive row increment
    for non-rotated grid assumed to increase in positive y-direction.
    Positive column increment for non- rotated grid assumed to increase in
    positive x-direction.  Varying the sign of the row,col increments is the
    mechanism for systems utilizing some corner of the grid other than the
    lower left corner as the grid origin. */
    
    GSSurfaceSetName_t surface_set_name;    /* Surface set name */
    GSString_t attribute;           /* name of the attribute being modelled */
a972 34
    
    GSDistance_t row_distance;      /* distance between rows */
    GSDistance_t col_distance;      /* distance between columns */
    
    GSReal_t angle;                 /* Grid rotation angle measured from the
                                     horizontal.  Angles are in degrees
                                     and open positively in the counter
                                     clockwise direction. */
    GSLongInt_t nrows;              /* Number of rows in the grid. */
    GSLongInt_t ncols;              /* Number of columns in the grid. */
    GSBoolean_t fl_honored;         /* Faults honored during gridding flag.
                                     FALSE: Fault information not used.
                                     TRUE: Fault information was used. */
    GSVector_t zvals;               /* Grid values: Storage order is row 1
                                     to row 'nrows' of column 1 followed
                                     by the row values of columns 2
                                     through column 'ncols'
                                     element_format = GSV_REAL;
                                     element_size = either sizeof (GSReal_t)
                                     or sizeof (GSDP_t) */
    
    GSMask_t valid;                 /* Validity mask for existence of xvals
                                     and yvals that follow (GSM_VALID_X
                                     or GSM_VALID_Y) */
    /* For the following two vectors,
       element_format = GSV_REAL;
       element_size = either sizeof (GSReal_t) or sizeof (GSDP_t) */
    GSVector_t xvals;               /* x-values corresponding to z-values */
    GSVector_t yvals;               /* y-values corresponding to z-values */
    } GSGrid_t;

/*    Contour Information
      -------------------
 */
d974 38
a1011 4
typedef struct 
    {
    GSSurfaceSetName_t surface_set_name;    /* Surface set name */
    GSString_t attribute;           /* name of the attribute being modelled */
d1013 30
a1042 32
    
    GSLongInt_t inc_type;           /* Type contour incrementing used.
                                     0: User specified contour range 
                                    defined by low contour value, 
                                    high contour value and contour
                                    increment.
                                     n: n-contour values specified
                                    explicitly by value. */
    GSVector_t inc_levels;          /* Vector of user specified contour
                                     levels.  The number of levels does not
                                     necessarily match the actual z values
                                     See 'inc_type' above. (4 or 8 byte float) */
    
    GSVector_t z_vals;              /* Z-values for each contour segment
                                     stored.  The number of Z values matches
                                     the number of segments described
                                     in the endpts vector.  The number of Z values 
                                     does not necessarily match the
                                     number of levels described in inc_levels
                                     (4 or 8 byte float) */
    GSVector_t endpts;              /* Vector of zero-based indices in x,y-coordinate
                                     arrays where each contour segment
                                     terminates.  Each value stored in
                                     'endpts' is associated with the
                                     corresponding contour level stored
                                     in 'z_vals'.  (4 byte integer) */
    GSVector_t x;                   /* Vector of contour x-coordinate
                                     values. (4 or 8 byte floats) */
    GSVector_t y;                   /* Vector of contour y-coordinate
                                     values. (4 or 8 byte floats) */
    } GSContour_t;

d1049 4
a1052 2
/*    2-D Survey Geometry Specification and Location
      ---------------------------------------------- */
d1054 27
a1080 24
typedef struct 
    {
    enum 
        {
        GS_REGULAR_CORRESP = 0,
        GS_SEMI_REGULAR_CORRESP = 1,
        GS_IRREGULAR_CORRESP = 2
        } cdp_sp_reg_flag;          /* Flag indicates whether or not a regular
                                         correspondence exists between cdp and sp */
    GSRational_t cdp_per_sp;        /* Nominal number of cdps per shot point */
    GSDistance_t shotpoint_interval;    /* Distance between shot points */
    GSCDP_t cdp1;                   /* Initial cdp (index) number */
    GSShotPoint_t sp1;              /* Initial shot point number */
    GSCDP_t cdpinc;                 /* CDP numbering increment */
    GSShotPoint_t spinc;            /* Shot point numbering increment */
    GSVector_t seismic_transducer;  /* Vector of station location structures
                                       This information describes the field data for the seismic
                                       line without regard to any seismic data processing.
                                       It is usually obtained from a 'UKOOA' file.
                                       The entries in this vector are ordered geographically,
                                       such that traversing the vector never causes a segment
                                       on the earth's surface to be passed over more than once
                                       (Not used for surface set - use Segment_t list) */
    } GSSeismicLoc2D_t;
d1082 11
a1092 9
/*    3-D Survey Geometry Specification and Location
      ----------------------------------------------
 
The following structure contains the information necessary to specify a 3d
survey.  If the survey does not exist in the receiving system all of the
information must be provided.  The survey is assumed to be laid out as a
regular orthogonal grid of traces so that knowing the location of one trace,
the trace and line spacing, and the azimuth of the primary lines one can
compute the location of all of the traces. */
d1094 2
a1095 3
typedef struct 
    {
    /*    the following are survey geometry specifications */
d1097 17
a1113 14
    /* grid defines the geometry representation of the 3D survey,
    including the ground distance and the number of values in X and Y.
    Usually the X and Y vectors of the GSGrid_t are not used. */
    GSLineNumber_t lin1;            /* line # of origin inline line (rational) */
    GSLineNumber_t lininc;          /* line number incr (rational) */
    GSLongInt_t number_inlines;     /* number of inlines in survey */
    GSCDP_t cdp1;                   /* origin cdp on inline lines.(rational) */
    GSCDP_t cdpinc;                 /* cdp incr. on inline lines (rational) */
    GSLongInt_t number_cdps;        /* number of cdps in each inline */
    GSShotPoint_t sp1;              /* sp of survey origin (rational) */
    GSShotPoint_t spinc;            /* sp incr. of survey  (rational) */
    
    /*    the following are coordinates with which to locate the survey */
    /* Enter in a clockwise sense; DO NOT assume grid is orthonormal */
d1115 1
a1115 1
    } GSSeismicLocation3D_t;
d1117 2
a1118 1
/************************************************************************************/
d1124 8
a1131 6
/*    Seismic Data Structures
      -----------------------
 
Seismic data will be contained in the interchange structure as a seismic line
header structure and a vector of trace structures.  The trace structure
contains a trace header structure and a vector of sample values. */
d1133 5
a1137 58
/*    Processed Seismic Line Header
      ----------------------------- */
typedef struct 
    {
    GSUnit_t si_unit;               /* units for sampling interval */
    
    enum 
        {
        GS_TRACE_ORDER_SHOT = 1,    /* shot ordered */
        GS_TRACE_ORDER_CDP = 2,     /* unstacked cdps */
        GS_TRACE_ORDER_STACK = 3,   /* stacked cdps */
        GS_TRACE_ORDER_SEQ = 4      /* trace sequential */
        } trace_order;              /* Trace ordering */
    
    GSUnit_t to_unit;               /* trace offset units */
    
    GSBoolean_t offset_validity;    /* TRUE = offsets are valid */
    
    GSDistance_t trail_offset;      /* trailing trace offset */
    GSDistance_t lead_offset;       /* leading trace offset */
    GSDistance_t near_offset;       /* ABS near trace offset */
    GSDistance_t far_offset;        /* ABS far trace offset */
    
    GSReal_t sample_interval;       /* sampling rate */
    GSLongInt_t n_samples;          /* maximum number of samples per trace */
    GSLongInt_t n_live_traces;      /* number of live traces */
    
    GSLongInt_t n_channels;         /* number of channels per record  (1) */
    GSLongInt_t n_fold;             /* stack fold (no. of traces per cdp) */
    
    GSDistance_t cdp_interval;      /* distance between cdps for this processed line
                                       (may be different than survey design) */
    
    GSShotPoint_t min_shotpoint;    /* minimum shotpoint */
    GSShotPoint_t max_shotpoint;    /* maximum shotpoint */
    GSRational_t min_receiver;      /* minimum receiver location */
    GSRational_t max_receiver;      /* maximum receiver location */
    GSCDP_t min_cdp;                /* minimum cdp */
    GSCDP_t max_cdp;                /* maximum cdp */
    
    GSRational_t cdp_incr;          /* cdp number increment per trace (zero if invalid) */
    GSRational_t shotpoint_incr;    /* shotpoint increment per trace (zero if invalid) */
    
    GSVector_t shot_info_table;     /* type GSShotPoint_t which tie into the GSSeismicLoc2d_t vector
                                       in the GSSeismicLine_t structure */
    GSVector_t receiver_info_table; /* type GSShotPoint_t which tie into the GSSeismicLoc2d_t vector
                                       in the GSSeismicLine_t structure */
    
    GSAmplitudeStats_t line_amplitude;  /* line amplitude statistics */
    
    enum 
        {
        GS_NO_MIGRATION = 0,
        GS_PRESTACK_MIGRATION = 1,
        GS_POSTSTACK_MIGRATION = 2
        } migration_type;
    
    } GSSeismicLineHdr_t;
d1139 6
a1144 7
/*    Velocity structures
                                          -------------------- */
typedef struct 
    {
    GSReal_t z;                     /* time or depth */
    GSReal_t value;                 /* velocity measurement at this time or depth */
    } GSVelocityPair_t;
d1146 64
a1209 9
typedef struct 
    {
    enum 
        {
        GS_STACKING_VELOCITY = 1,
        GS_AVERAGE_VELOCITY = 2,
        GS_PSEUDO_VELOCITY = 3,
        GS_INTERVAL_VELOCITY = 4
        } velocity_type;
d1212 2
a1213 2
    GSVector_t velocity_pair;       /* List of time/velocity or depth/velocity pairs */
    } GSSeismicVelocity_t;
a1214 2
/*    Trace (including header)
                                          ------------------------ */
d1216 16
a1231 14
typedef struct 
    {
    /**** trace header ****/
    enum 
        {
        GS_DEAD_TRACE = -1,
        GS_LIVE_TRACE = 1,
        GS_SWEEP_TRACE = 2,
        GS_NULL_TRACE = 3
        } trace_type;               /* activity of trace (live, dead, etc) */
    
    GSLongInt_t record_no;          /* sequential record number */
    GSLongInt_t record_trace_no;    /* record trace number */
    GSLongInt_t field_record_no;    /* field record number */
a1232 22
    
    GSCDP_t cdp;                    /* common midpoint number (cmp) */
    GSLongInt_t cdp_trace_no;       /* cdp trace number */
    GSShotPoint_t cdp_sp;           /* shotpoint corresponding to this cdp */
    GSLongInt_t cdp_fold;           /* stacking fold at this cdp */
    
    GSLongInt_t mute_length;        /* length of initial mute is samples */
    GSReal_t tfs;                   /* time of first sample in sample units */
    GSStatic_t bulk_static;         /* bulk static */
    GSAmplitudeStats_t trace_amplitude; /* trace amplitude statistics */
    
    GSReal_t minimum_scalar;        /* scalar values used in scaling data to */
    GSReal_t maximum_scalar;        /* fraction values */
    
    GSVector_t seismic_velocity;    /* vector of seismic velocity functions */
    
    /**** trace samples ****/
    
    GSVector_t samples;             /* Vector of seismic trace samples
                                     (see vector descriptor for sample format) -
                                    (Note: no corresponding Samples_t exists) */
    } GSSeismicTrace_t;
d1234 4
a1237 12
/*    Line Description Structure
       --------------------------
                                     
All surveys are organized as a series of lines and the survey structure
includes a vector of line structures of the following form.  Each line may have
several variants usually depending on any processes which have been applied to
the data to alter its presentation or to extract some quality of interest. 
Therefore the line structure contains location information and a vector of
classes.  There may be many types of data related to a line class.  Each type 
will have a structure ( or vector of structures ) in which that type of data 
is stored.  Included in the current proposal is a vector of interpreted 
surfaces and seismic trace data. */
d1239 4
a1242 11
typedef struct 
    {
    GSLineType_t line_type;         /* Seismic Line type */
    GSString_t line_name;           /* 2d or reconstruction cut line name */
    GSLongInt_t line_number;        /* Line number (required for GS_LINE_3DI,
                                       GS_LINE_TSL, GS_LINE_XLN) */
    GSString_t line_desc;           /* Line description */
    GSVector_t seismic_class;       /* Vector of seismic line variants delineated
                                       according to class */
    GSSeismicLoc2D_t loc2d;         /* GS_LINE_2D, GS_LINE_RCN types only */
    } GSSeismicLine_t;
d1244 2
a1245 2
/*    GSSeismic Class structure                
      ----------------------- */
d1247 2
a1248 9
typedef struct 
    {
    GSString_t class_name;          /* User assigned class name */
    GSString_t class_desc;          /* Class description */
    GSSeismicLineHdr_t seismic_line_hdr;    /* Structure containing seismic line header */
    GSVector_t seismic_trace;       /* Vector of GSSeismicTrace_t */
    GSVector_t seismic_surface;     /* Vector of GSSeismicSurface_t */
    GSVector_t processing_history;  /* Seismic trace file processing history */
    } GSSeismicClass_t;
d1250 51
a1300 1
/************************************************************************************/
d1306 12
a1317 10
/*    
It will be assumed that there are two basic types of surfaces, horizons and
faults (or fault cuts).  Along any line there may be line segments indicating
where the surface has been interpreted and there may be information indicating
where two surfaces contact each other.  Additionally, the segments may have
different data depending on the z value contained therein.  For example, the
user may have interpreted a horizon along a range of cdps and saved the time
values at which the horizon occured.  He may have also saved the seismic trace
amplitude at that time.  Segments containing both time and containing amplitude
may be stored for a given surface. */
d1319 6
a1324 4
/*  This structure contains information specifying points along the surface at
    which the user has indicated that it intersects another surface.  The structure
    includes the location of the intersection and information about the
    intersecting structure. */
d1326 10
a1335 11
typedef struct 
    {
    GSSurfaceType_t surface_type;   /* Surface type: 
                                       GS_SRF_TYPE_HOR, GS_SRF_TYPE_FLT */
    GSSurfaceSetName_t surface_set_name;    /* Surface set name */
    GSUnit_t z_uom;                 /* Unit of measurement for z */
    GSString_t source;              /* Name of interpreter or source of data */
    GSString_t surface_desc;        /* Surface description */
    GSDate_t modified_date;         /* date this surface was last modified */
    
    /* The following are applicable only to horizon surfaces */
d1337 5
a1341 5
    GSReal_t snap_window;           /* Duration of snapping window in seconds */
    GSVector_t segment;             /* Vector of interpretation segments for line */
    GSVector_t contact;             /* Vector of contact points associated with this
                                     surface on this line */
    } GSSeismicSurface_t;
d1343 7
a1349 8
typedef struct 
    {
    GSSeismicDataPoint_t contact_loc;   /* location of contact point */
    GSSurfaceType_t surface_type_2; /* Surface type: 
                                      GS_SRF_TYPE_HOR, GS_SRF_TYPE_FLT,
                                      GS_SRF_TYPE_UNKNOWN */
    GSSurfaceSetName_t name_2;      /* second name associated with contact */
    } GSContact_t;
d1351 2
a1352 3
typedef struct 
    {
    GSLongInt_t seg_id;             /* Number identifying segment */
d1354 3
a1356 2
    GSVector_t seismic_data_point;  /* Vector of points in interpretation segment */
    } GSSegment_t;
d1358 2
a1359 1
/************************************************************************************/
d1365 12
a1376 11
/*    
Fault traces are interpreted information defining the map view of the
intersection of faults with a particular surface.  The interpretation is
usually done on a map and cannot be organized on a line by line basis or, for
that matter, on a survey basis.  Fault trace interpretation, therefore, must 
be kept in a structure separate from the survey structure described above and 
transmitted seperately.  The following structures will be used to contain and
transmit fault trace information.  The top structure contains information
necessary to define the coordinate system of the data contained in the
structure and a vector of surface structures for which fault trace information
is transmitted. */
d1378 4
a1381 2
/*  Each surface may have intersections with many faults.  The following 
    structure names a vector of fault traces for a specified surface. */
d1383 5
a1387 6
typedef struct 
    {
    GSSurfaceSetName_t surface_set_name;    /* Name of surface for which traces are
                                               defined */
    GSVector_t fault_trace;         /* Vector of structures defining fault traces */
    } GSFaultSurface_t;
d1389 5
a1393 3
/*  The following fault trace vector specifies the name of the intersecting fault
    and names the vector containing the points associated with the 
    intersection. */
d1395 6
a1400 5
typedef struct 
    {
    GSSurfaceSetName_t fault_name;  /* Name of fault whose intersection with the surface
                                       this trace describes */
    GSLongInt_t ft_seg_id;          /* segment id for fault trace for a given surface */
d1403 5
a1407 3
    GSVector_t map_location;        /* Vector of structures defining fault trace points */
    } GSFaultTrace_t;

d1414 15
a1428 18
typedef struct 
    {
    enum 
        {
        GS_REP_NONE,
        GS_REP_GRID,
        GS_REP_CONTOUR,
        GS_REP_CONSTANT,
        GS_REP_XYZ
        } type;
    union 
        {
        GSGrid_t grid;
        GSXYZData_t xyz;            /* 'Scatter' data file */
        GSMeasurement_t constant;
        GSContour_t contour;
        } data;
    } GSSurfaceRepresentation_t;
d1430 4
a1433 5
typedef struct 
    {
    GSString_t attribute;           /* name of the attribute being modelled */
    GSVector_t surface_representation;  /* list of attribute representations */
    } GSSurfaceAttribute_t;
d1435 15
a1449 11
typedef struct 
    {
    GSExtents_t extent;             /* XYZ spanning extent of data set */
    GSSurfaceRepresentation_t time_representation;  /* set of coordinates describing
                                                     the geometry of the surface in time */
    GSSurfaceRepresentation_t depth_representation; /* set of coordinates describing
                                                     the geometry of the surface in depth */
    GSVector_t surface_attribute;   /* List of attributes for this surface
                                       which correspond to, or are measured at,
                                         the geometry specified in either time or depth */
    } GSSurfaceGeometry_t;
d1451 5
a1455 5
/********************************************************************
    This structure describe the intersection between a seismic line 
    and a surface set. As such it provides information about both
    entities.It originates from the SeismicSurface structure whose name 
    has been changed to be more meaningful
d1458 15
a1472 15
typedef struct
    {
    GSSurfaceSetName_t surface_set_name;    /* name of the surface set intersected */
    GSUnit_t z_uom;                 /* Unit of measurement for z */
    GSString_t source;              /* Name of interpreter or source of data*/
    GSString_t line_name;           /* Line identifier */
    GSString_t surface_desc;        /* Surface description */
    GSDate_t modified_date;         /* date this surface was last modified*/
    /* The following are applicable only to horizon surfaces */
    GSSnapEvent_t snap_event;       /* Valid only for horizons */
    GSReal_t snap_window;           /* Duration of snapping window in seconds */
    GSVector_t segment;             /* Vector of interpretation segments for line   */
    GSVector_t contact;             /* Vector of contact points associated
                                     with the surface on this line */
    } GSLineIntersection_t;
d1474 2
a1475 2
/********************************************************************
   This structure describe the intersection between a surface set and 
d1481 1
a1481 2
typedef struct 
    {
d1483 3
a1485 2
    GSVector_t xyz_point;           /* Vector of structures defining surface trace points */
    } GSSurfaceTrace_t;
d1487 6
a1492 5
typedef struct 
    {
    GSSurfaceSetName_t surface_set_name;    /* Name of intersecting surface set (horizon or fault) */
    GSVector_t surface_trace;       /* Vector of structures defining traces */
    } GSSurfaceSurfaceIntersection_t;
d1494 9
a1502 8
typedef struct                      /* new object pointed from GSSurfaceSet_t */
    {
    GSSurfaceSetName_t surface_set_name;    /* name of the surface set intersected */
    GSVector_t line_intersection;   /* Vector of section interpretation */
    GSVector_t well_marker;         /* Vector of GSWellMarker */
    GSVector_t seismic_well_tie;    /* Vector of GSSeismicWellTie */
    GSVector_t surface_surface_intersection /* vector of surface surface intersections */
    } GSSurfaceIntersection_t;
d1504 2
a1505 1
/************************************************************************************/
d1511 8
a1518 2
/*    Attribute Information For Map Objects
      -------------------------------------
d1520 4
a1523 3
Each map object defined in a mapping database can have associated
non-graphic attribute information.  This is simply a list of name-value
pairs which are carried along with the map object. */
d1525 7
a1531 5
typedef struct 
    {
    GSString_t item_name;           /* name of attribute */
    GSMeasurement_t item_value;     /* value and unit of measure of attribute */
    } GSAttributeItem_t;
d1533 8
a1540 2
/*    Data Source For Map Data
      ------------------------
a1541 12
It is often useful to know where a certain set of map data came from
(e.g. Tobin, PI, etc.).  The map data source is simply a name that can 
be associated with a map object in the database (it is optional). */

/*    Data Category Of A Map Object
      -----------------------------

Each map object added to the database must be associated with a user supplied
category name (e.g. rivers, coast line, etc.).  The user should be careful
to avoid spelling variations (e.g. "RIVER" and "RIVERS" are all
treated as separate categories). */

d1544 14
a1557 16
typedef struct 
    {
    GSString_t category_name;       /* Name of the data category. A null value is
                                       NOT allowed. */
    enum 
        {
        GS_PRIMARY_ANNOTATION = 0,
        GS_ATTRIBUTE_ANNOTATION = 1
        } anno_type;                /* Primary or attribute annotation ??? */
    GSString_t anno;                /* Text */
    GSString_t font;                /* Annotation font */
    GSReal_t height_in_mm;          /* Nominal display height (in mm) */
    GSReal_t anchor_angle;          /* Angle for annotation display */
    GSMapLocation_t anchor_point;   /* Anchor location */
    GSVector_t attribute_item;      /* Optional list of attributes */
    } GSMapAnnotation_t;
d1561 9
a1569 10
typedef struct 
    {
    GSString_t category_name;       /* Name of the data category. A null value is
                                       NOT allowed. */
    GSPlotSymbol_t symbol;          /* Plot Symbol */
    GSReal_t height_in_mm;          /* Nominal display height (in mm) */
    GSMapLocation_t anchor_point;   /* Anchor location */
    GSReal_t anchor_angle;          /* Angle for annotation display */
    GSVector_t attribute_item;      /* Optional list of attributes */
    } GSMapSymbol_t;
d1573 6
a1578 7
typedef struct 
    {
    GSString_t category_name;       /* Name of the data category. A null value is
                                       NOT allowed. */
    GSMapLocation_t location;       /* Point location */
    GSVector_t attribute_item;      /* Optional list of attributes */
    } GSMapPoint_t;
d1582 10
a1591 10
typedef struct 
    {
    GSString_t category_name;       /* Name of the data category. A null value is
                                       NOT allowed. */
    GSBoolean_t flag;               /* True = add additional buffers of polyline data. 
                                     False = only one buffer of polyline data. */
    GSPolyLineType_t open_closed;   /* Open polyline or polygon ? */
    GSVector_t map_location;        /* List of locations */
    GSVector_t attribute_item;      /* Optional list of attributes */
    } GSMapPolyline_t;
d1595 8
a1602 8
typedef struct 
    {
    GSVector_t map_annotation;      /* NOTE: type = GSV_MAP_ANNOTATION */
    GSVector_t map_symbol;          /* NOTE: type = GSV_MAP_SYMBOL */
    GSVector_t map_point;           /* NOTE: type = GSV_MAP_POINT */
    GSVector_t map_polyline;        /* NOTE: type = GSV_MAP_POLYLINE */
    } GSMapObjects_t;

d1609 65
a1673 69
typedef struct 
    {
    enum 
        {
        GS_JEFFERSONIAN = 1,
        GS_GULF_COAST_OFFSHORE = 2,
        GS_TEXAS_ABSTRACT = 3,
        GS_OCS_OFFSHORE = 4
        } type;
    union 
        {
        struct 
            {                       /* structure describing Jeffersonian description of
                                       a location */
            GSLongInt_t meridian_code;  /* PRINCIPAL_MERIDIAN code number - (Note: we
                                         need to publish a list or cite a reference - jgg) */
            GSReal_t township;      /* township number */
            char twpns;             /* 'N' or 'S' of survey base line */
            GSReal_t range;         /* range number */
            char rngew;             /* 'E' or 'W' of survey principal meridian */
            GSReal_t section;       /* section number in township */
            GSString_t section_type;    /* type of 'section' (NULL = section, 'LOT', etc */
            GSString_t spot;        /* Point in section from which measurements are references */
            GSString_t state;       /* State or province abbreviation */
            GSString_t country;     /* Country abbreviation */
            GSString_t county;      /* County, district, parrish name */
            GSString_t narrative;   /* Prose description of location */
            } jeffersonian;
        
        struct 
            {
            GSString_t abstract;    /* Abstract ID */
            GSString_t state;       /* State or province abbreviation */
            GSString_t country;     /* Country abbreviation */
            GSString_t county;      /* County name */
            } texas_abstract;
        
        struct 
            {
            GSString_t tract;       /* Tract name */
            struct 
                {
                GSLongInt_t number; /* Numeric part of block identifier */
                char alpha;         /* Optional character part of block identifier */
                } block_id;
            } gulfcoast_offshore;
        struct 
            {
            enum 
                {
                GS_FEDERAL_WATERS,  /* Federal zone (non-state) */
                GS_STATE_WATERS     /* State zone */
                } state_fed;        /* Flag indicating whether point is under state or
                                       federal control */
            GSString_t offshore_block;  /* Offshore block number */
            GSString_t utm_grid_block;  /* Universal Transverse Mercator block
                                           identifier */
            GSLongInt_t ocs_number;
            } ocs_offshore;         /* Outer Continental Shelf description */
        
        } system;
    GSDistance_t nsfootage;         /* 'footage' in north-south direction */
    GSString_t ns;                  /* reference line of north-south 'footage'
                                       ('FEL','FWL') */
    GSDistance_t ewfootage;         /* 'footage' in ease-west direction */
    GSString_t ew;                  /* reference line of east-west 'footage'
                                       ('FNL','FSL') */
    } GSLegal_t;

d1680 10
a1689 10
typedef struct 
    {                               /* structure for defining well depths */
    GSMask_t valid;                 /* Indicates which fields contain valid information */
    GSReal_t md;                    /* measured depth */
    GSReal_t subdatum;              /* depth relative to local datum */
    GSReal_t tvd;                   /* true vertical depth */
    GSReal_t time;                  /* two-way travel time */
    GSReal_t dx;                    /* X deviation from top-hole position */
    GSReal_t dy;                    /* Y deviation from top-hole position */
    } GSDepth_t;
d1691 5
a1695 6
typedef struct 
    {                               /* structure for lithostrat codes (mandatory) */
    GSString_t Code;                /* Formation code of the lithostratigraphic unit */
    GSString_t Age;                 /* Client-specified age code of
                                     lithostratigraphic unit (optional) */
    } GSLithoStrat_t;
d1697 2
a1698 1
/************************************************************************************/
d1704 4
a1707 125
typedef struct 
    {                               /* structure defining well header information */
    GSVersion_t Version;            /* version number of this data structure */
    GSUWI_t uwi;                    /* Unique Well Identifier (mandatory) */
    GSPlotSymbol_t symbol;          /* Plot Symbol name */
    
    GSUnit_t z_unit;                /* Unit of measure for all depths */
    
    struct 
        {
        GSBoolean_t flag;           /* TRUE if well is deviated */
        GSVector_t depth;           /* vector of GSDepth_t structures */
        } deviation;
    
    GSString_t well_name;           /* Full legal name of well lease */
    GSString_t well_number;         /* Well permit number within lease */
    GSString_t plot_name;           /* Shortened name of well lease for plotting */
    GSString_t short_name;          /* Shortened or informal name of well */
    
    GSString_t operator;            /* Name of well operator */
    GSString_t licensee;            /* Licensee of well lease */
    GSString_t agent;               /* Name of agent */
    
    /* Class and status information */
    GSString_t  class ;             /* Well classification (e.g. LAHEE class.) */
    GSString_t crstatus;            /* Current well status */
    GSString_t orstatus;            /* Original well status */
    GSString_t prstatus;            /* Previous well status */
    
    /* Location information */
    GSMapLocation_t tophole_xy;     /* structure defining coordinates of 
                                    top hole position */
    GSLegal_t tophole;              /* structure describing legal status of the 
                                     tophole */
    GSMapLocation_t bottomhole_xy;  /* structure defining coordinates of 
                                    bottom hole position */
    GSLegal_t bottomhole;           /* structure describing legal status of the  
                                     bottomhole */
    
    struct 
        {                           /* structure defining offshore specific wells */
        GSMeasurement_t water_depth;    /* Water depth */
        GSString_t platform_name;   /* Name of offshore drilling platform */
        } offshore;
    
    /* Total depth information */
    struct 
        {                           /* structure defining depths of driller, 
                                       logger, and plugback */
        GSDepth_t driller;          /* structure describing driller depths */
        GSDepth_t logger;           /* structure describing logger depths */
        GSDepth_t plugback;         /* structure describing plugback depths */
        GSLithoStrat_t formation;   /* structure describing formation at TD */
        GSTemperature_t temperature;    /* bottom hole temperature */
        GSMeasurement_t pressure;   /* bottom hole pressure */
        } td;
    
    /* Elevation information */
    GSElevationRef_t elevation;     /* Datum elevation for well */
    GSElevation_t Ground_Elevation; /* ground elevation */
    GSElevation_t kb_elevation;     /* kelly bushing elevation */
    GSElevation_t cf_elevation;     /* casing flange elevation */
    
    /* Checkshot information */
    struct 
        {
        GSElevationRef_t datum;     /* datum used for checkshot */
        GSVelocity_t vsd;           /* velocity surface to datum */
        GSUnit_t time_unit;         /* Unit of time in vector */
        GSVector_t depth;           /* measured depth */
        GSVector_t time;            /* two-way travel time */
        } checkshot;
    struct                          /* Drilling information */
        {
        GSString_t contractor;      /* name of drilling contractor */
        GSString_t rig_number;      /* drilling rig number or identifier */
        } drilling;
    
    /* Miscellaneous Information */
    GSString_t primary_source;      /* Name of source of well information */
    GSString_t stratcolumn;         /* name of strat column to use for this well */
    enum 
        {
        GS_IMPERIAL_UNIT = 1,
        GS_METRIC_UNIT = 2
        } original_unit;            /* Original unit system that data was 
                                    collected in */
    GSBoolean_t proprietary;        /* TRUE if this well contains proprietary 
                                     informaiton */
    GSBoolean_t discovery_well;     /* TRUE if this is the discovery field for the field*/
    GSBoolean_t fault;              /* TRUE if this well has a faulted section */
    
    /* Confidentiality Information */
    struct 
        {
        GSBoolean_t flag;           /* confidentiality flag */
        GSString_t formcode;        /* confidentiality formation */
        GSDepth_t depth;            /* confidentiality depth */
        GSDate_t release_date;      /* confidential release date */
        } confidential;
    
    /* Dates */
    GSDate_t Last_Update;           /* date/time of last update */
    GSDate_t Spud_Date;             /* spud date */
    GSDate_t Comp_Date;             /* completion date */
    GSDate_t rigrel;                /* rig release date */
    GSDate_t onprod;                /* on production date */
    GSDate_t calc_onprod;           /* calculated on production date */
    GSDate_t oninject;              /* on injection date */
    GSDate_t status_date;           /* date last status was entered */
    GSDate_t fin_drill;             /* final drilling date */
    
    GSBoolean_t updated;            /* TRUE if this well structure has been updated */
    
    /* Headers (tree-tops) for other well data classes */
    GSVector_t log_run;             /* vector of GSLogRun_t */
    GSVector_t well_core;           /* Vector of core data (GSWellCore_t) */
    GSVector_t zone_value;          /* Vector of zone values (GSZoneValue_t) */
    GSVector_t well_marker;         /* Vector of GSWellMarker_t */
    GSVector_t well_production;     /* Vector of GSWellProduction_t
                                     (sorted descending by year) */
    GSVector_t well_tubulars;       /* Vector of tubular products placed in well */
    GSVector_t well_remarks;        /* Vector of general remarks */
    GSVector_t well_tests;          /* Vector of well tests */
    } GSWellHdr_t;
d1709 117
a1825 1
/************************************************************************************/
d1831 10
a1840 10
typedef struct 
    {
    enum 
        {
        GS_WELL_CORE_NORMAL = 1,    /* Normal well core */
        GS_WELL_CORE_SIDEWALL = 2   /* Sidewall core */
        } core_type;
    GSDepth_t top;                  /* Top of cored interval */
    GSDepth_t base;                 /* base of cored interval (not used for sidewall core) */
    GSReal_t recovered;             /* Amount of core recovered, as a percentage (0-100) */
d1842 2
a1843 2
    GSString_t show;                /* Type of petroleum show in core */
    } GSWellCore_t;
d1851 8
a1858 5
/* The following catch-all is intended to be used to describe some measurement
or activity observed in a well that is not adequately modelled elsewhere in these data
structures.  The intent is to allow another vendor to display this information somehow
without being concerned about the semantics of the information.  This might be used
to display arbitrary information in a cross-section panel, or in a report. */
d1860 9
a1868 9
typedef struct 
    {
    GSString_t type_name;           /* Type of data being described, or name of data set */
    GSDepth_t depth;                /* Depth at this these observations were made
                                      (Zero implies these observations apply
                                      to the well as a whole) */
    GSVector_t strings;             /* A vector of strings describing some event
                                     or measurement at this depth */
    } GSWellRemarks_t;
d1870 2
a1871 1
/************************************************************************************/
d1877 6
a1882 7
typedef struct 
    {
    GSResistivity_t rm;             /* Mud resistivity */
    GSResistivity_t rmf;            /* Mud filtrate resistivity */
    GSResistivity_t rmc;            /* Mud cake resistivity */
    GSString_t source;              /* Source of resistivity observations */
    } GSMudResistivity_t;
d1884 25
a1908 20
typedef struct 
    {
    GSString_t name;                /* Name or mnemonic of sensor (GR, DT, RHOB, etc) */
    GSString_t source;              /* Source of the digital data associated with this sensor */
    GSLongInt_t version;            /* Version number of this trace - used during editing */
    GSString_t comments;            /* General remarks about the log trace */
    GSUnit_t depth_uom;             /* Unit of depth measurement */
    GSUnit_t trace_uom;             /* Unit of trace value */
    GSReal_t non_null_top;          /* Top of trace data interval (excluding nulls) */
    GSReal_t non_null_base;         /* Base of trace data interval (excluding nulls) */
    GSReal_t min;                   /* Minimum trace value */
    GSReal_t max;                   /* Maximum trace value */
    GSReal_t dinc;                  /* Digitizing increment (0.0 if random) */
    GSVector_t processing_history;  /* Vector of processing history records sorted by date,
                                     most recent listed first */
    GSVector_t depth;               /* Array of depth values (4 or 8 byte floating point values)
                                     Note: this is NOT a Depths_t structure) */
    GSVector_t value;               /* Corresponding array of values.  The number of depths
                                     and values should match (4 or 8 byte floating point values) */
    } GSLogTrace_t;
d1910 1
a1910 9
typedef struct 
    {
    /* A service is also loosely called a logging tool.
    Several services may be used in a single pass */
    GSString_t log_service;         /* Name of log service */
    GSString_t tool_id;             /* Tool identifier/serial number */
    GSLongInt_t sequence;           /* Sequence number of this tool in current tool string */
    GSVector_t log_trace;           /* List of sensors that belong to this service/tool */
    } GSLogService_t;
d1912 11
a1922 10
typedef struct 
    {
    /* A pass is a single Trip of the tool string.
    There is usually more than one pass per run */
    GSLongInt_t pass_number;        /* Logging pass number within current log run */
    GSDate_t pass_date;             /* Date this pass was started */
    GSMeasurement_t top;            /* Top of logged interval */
    GSMeasurement_t base;           /* Base of logged interval */
    GSVector_t log_service;         /* List of services being used during this pass */
    } GSLogPass_t;
d1924 46
a1969 28
typedef struct 
    {
    /* A log run is a visit by a logging company to a drilling site.
    It usually is associated with a single billing cycle
    Also called an 'activity' */
    GSLongInt_t run_number;         /* Log run number */
    GSString_t logging_company;     /* Name of company providing logging service */
    GSDate_t run_date;              /* Date this log run was started */
    GSString_t logging_unit_number; /* Identification of logging truck or unit */
    GSString_t logging_unit_loc;    /* Location of logging unit (home base) */
    GSString_t recorder;            /* Name of person acting as logging recorder */
    GSString_t witness;             /* Name of company witness to logging activity */
    GSElevationRef_t datum;         /* Elevation used as log run datum */
    struct 
        {
        GSString_t type;            /* type of mud */
        GSMeasurement_t salinity;   /* Mud salinity */
        GSMeasurement_t density;    /* Mud weight */
        GSMeasurement_t viscosity;  /* mud viscosity */
        GSMeasurement_t fluid_loss;
        GSReal_t pH;
        GSMudResistivity_t resistivity; /* Resistivity of mud */
        GSMudResistivity_t resistivity_bht; /* Resistivity of mud at bottom hole
                                             temperature */
        } mud_data;
    GSMeasurement_t time_circ_stopped;  /* Time since mud circulation was stopped */
    GSMeasurement_t time_logger_on_bottom;  /* Time the logging tool was at bottom of well */
    GSTemperature_t max_rec_temp;   /* Maximum bottom hole temperature recorded */
d1971 1
a1971 1
    } GSLogRun_t;
d1973 2
a1974 1
/************************************************************************************/
d1983 7
a1989 7
typedef struct 
    {
    GSZoneName_t zone_name;         /* Name of zone being defined */
    GSString_t top_definition;      /* Text describing how top of zone is defined */
    GSString_t base_definition;     /* Text describing how base of zone is defined */
    GSString_t remarks;             /* General remarks about zone */
    } GSZoneDefinition_t;
d1991 10
a2000 10
typedef struct 
    {
    GSZoneName_t zone_name;         /* Name of zone in which the variable is defined.
                                     If null, then the defined variable applies to all zones. */
    GSZoneVariable_t variable_name; /* Name of variable being defined */
    GSString_t algorithm;           /* Description of methodology used to define the variable.
                                     This may be an equation or a reference
                                     to a known algorithm. */
    GSString_t remarks;             /* General remarks about zone variable */
    } GSZoneVariableDefinition_t;
d2002 9
a2010 10
typedef struct 
    {
    GSZoneName_t zone_name;         /* Name of the zone.  If null, then the defined
                                     variable applies to entire well or field. */
    GSZoneVariable_t variable_name; /* Name of variable being measured */
    GSDepth_t top;                  /* Depth to top of measured interval */
    GSDepth_t base;                 /* Depth to base of measured interval */
    GSString_t value;               /* Value of zone variable */
    GSUnit_t unit;                  /* Unit of measurement */
    } GSZoneValue_t;
d2012 2
a2013 1
/************************************************************************************/
d2018 16
a2033 15
typedef struct 
    {
    enum 
        {
        GS_OIL = 1,
        GS_WATER = 2,
        GS_GAS = 3
        } fluid_type;               /* Type of fluid produced */
    GSLongInt_t year;               /* Year of record */
    GSZoneName_t zone_name;         /* Name of the zone. */
    GSReal_t cumulative_prior_years;    /* Sum of fluid produced during prior years */
    GSVector_t prod_month;          /* Vector of GSReal_t containing monthly production,
                                     one per month (1st is January, 2nd is February, etc)*/
    GSUnit_t unit;                  /* Unit of measure used to describe production volumes */
    } GSWellProduction_t;
d2040 16
a2055 16
typedef struct 
    {
    GSString_t tubing_type;         /* Type of tubing product */
    GSString_t tubing_size;         /* Size of tubing, as a printable string */
    GSDate_t install_date;          /* Date this tubular product was installed */
    GSDepth_t top;                  /* Top of tubular product */
    GSDepth_t base;                 /* base of tubular product */
    GSMeasurement_t bore;           /* Inside diameter of casing */
    GSMeasurement_t hole_size;      /* Size of hole in which tubular product was installed */
    struct 
        {
        GSDepth_t depth;            /* Depth at which casing shoe was installed */
        GSLithoStrat_t form;        /* Formation in which shoe was set */
        } shoe;
    GSReal_t strength;              /* Axial load required to yield pipe */
    GSString_t steel_spec;          /* Manufacturer's spec under which steel was made */
d2057 1
a2057 1
    } GSWellTubulars_t;
d2059 2
a2060 1
/************************************************************************************/
d2066 6
a2071 7
typedef enum 
    {
    GS_LITHO_TOP = 1,               /* Lithostratigraphic (formation) top */
    GS_CONTACT_TOP = 2,             /* Fluid surface contact (e.g. oil/water) */
    GS_FAULT_POINT = 3,             /* Piercing point of well through fault plane */
    GS_MARKER_TOP = 4,              /* Stratigraphic marker - subordinate to
                                       lithostratigraphic pick */
d2073 1
a2073 1
    } GSMarkerType_t;
d2075 22
a2096 22
typedef struct 
    {                               /* Formation top description */
    GSUWI_t uwi;                    /* Unique well identifier (mandatory) */
    GSLithoStrat_t name;            /* Name of lithostratigraphic (surface set) name (mandatory) */
    GSString_t source;              /* Source of interpretation */
    GSSurfaceSetName_t seismic_horizon; /* Name of seismic surface that this marker is
                                           correlated with */
    GSUnit_t z_uom;                 /* unit of measure (used when part of a surface set) */
    GSDepth_t depth;                /* Coordinates of piercing point */
    GSMeasurement_t fault_gap;      /* For faults, the amount of missing section faulted
                                       out at this location */
    enum 
        {
        GS_NORMAL_SECTION = 0,      /* Paleo up indicators point up */
        GS_INVERTED_SECTION = 1     /* Paleo up indicators inverted */
        } up_direction;
    GSString_t Comment;             /* comments describing nature of pick
                                     (ABSENT, ERODED, NOT PICKED, etc) */
    GSBoolean_t Best_Pick;          /* TRUE if this is best available information */
    char Quality;                   /* Quality code of pick */
    GSDate_t Last_Update;           /* date this interpretation made */
    } GSWellMarker_t;
d2098 6
a2103 6
typedef struct                      /* Used as part of a surface set ... */
    {
    GSUWI_t uwi;                    /* Unique well identifier */
    GSMeasurement_t measurement;    /* Attribute value measured at this point */
    GSString_t source;              /* Source of this interpretation/measurement */
    } GSWellAttribute_t;
d2105 5
a2109 3
/* A vector of the following entities describes the lithostratigraphic
codes that may be sent.  It acts as an assertion list and provides some
structural relationships between 'formations' */
d2111 12
a2122 11
typedef struct 
    {
    GSLithoStrat_t code_name;       /* formation and age codes (NOTE: Age code in this
                                       structure implies the Average of the formation.
                                       The exact age at a well is found in the
                                       GSWellMarker_t structure) */
    GSString_t source;              /* Name of company that defines/uses this code */
    GSSurfaceSetName_t full_name;   /* Full marker/formation (surface set) name */
    GSMarkerType_t marker_type;     /* Type of surface */
    GSLithoStrat_t parent;          /* if this unit is a member of a larger group, then
                                       this field contains the name of the next higher order */
d2124 1
a2124 1
    } GSLithostratCodeDesc_t;
d2126 6
a2131 4
/* The following represents a stratigraphic column.  This is a list
of lithostratigraphic codes and their depositional ranking, from youngest
to oldest. This list usually describes a normal depositional sequence
independent of any well */
d2133 6
a2138 7
typedef struct 
    {
    GSString_t name;                /* Name of stratigraphic column */
    GSString_t citation;            /* Journal citation describing sequence */
    GSString_t remarks;             /* */
    GSVector_t lithostrat;          /* Vector of formation and age codes */
    } GSStratigraphicColumn_t;
d2140 2
a2141 1
/************************************************************************************/
d2147 7
a2153 9
typedef struct 
    {
    enum 
        {
        GS_WELL_DRILLSTEM_TEST,
        GS_WELL_PRODUCTION_TEST
        } test_type;
    /* this needs mucho work */
    } GSWellTestHdr_t;
d2155 2
a2156 1
/************************************************************************************/
d2162 3
a2164 9
/*    Seismic Survey Information
      --------------------------
 */
/*
All seismic related information is specified in a hierarcical structure.  The
top of the hierarcy is a structure which groups the information according to
surveys.  Surveys may be either 2d groups of line or 3d surveys.  In order to
facilitate memory management, 3d survey data will be organized according to
lines.  The following defines the survey structure:                  */
d2166 8
a2173 18
typedef struct 
    {
    GSString_t survey_name;         /* Name of survey */
    GSString_t survey_desc;         /* Survey description */
    enum                            /* Survey type */
        {
        GS_SURVEY_2D = 2,           /* 2d survey symbol */
        GS_SURVEY_3D = 3            /* 3d survey symbol */
        } survey_type;
    GSElevation_t z_datum;          /* Datum to use in association with elevations */
    GSCartoProjection_t proj;       /* Projection information */
    GSDP_t dp_null;                 /* Null value for floating point numbers */
    GSLongInt_t int_null;           /* Null value for integers */
    GSSeismicLocation3D_t loc3d;    /* 3d survey specificaton and
                                      location structure (not used for 2-D survey) */
    GSVector_t seismic_line;        /* vector of structures describing lines
                                       element_type = GSV_SEISMIC_LINE */
    } GSSeismicSurvey_t;
d2175 17
a2191 14
/*    Surface set Information
      -----------------------
 */
typedef struct 
    {
    GSSurfaceSetName_t surface_name;    /* Name of surface set */
    GSString_t description;         /* description of the surface */
    GSCartoProjection_t proj;       /* Projection information */
    GSDP_t dp_null;                 /* Null value for floating point numbers */
    GSLongInt_t int_null;           /* Null value for integers */
    GSSurfaceType_t surface_type;   /* Type of surface (Fault, horizon, geologic marker) */
    GSVector_t surface_geometry;    /* List of geometry information for surface */
    GSSurfaceIntersection_t intersection;   /* Intersection of surface set with other entities */
    } GSSurfaceSet_t;
d2193 16
a2208 3
/*    Field Information
      ----------------
 */
d2210 3
a2212 13
typedef struct 
    {
    GSString_t field_name;          /* name of (oil, gas) field */
    GSString_t field_type;          /* What type of field this is */
    GSUWI_t discovery_well;         /* Unique identifier of the discovery well */
    GSVector_t zone_value;          /* Vector of zone values for the field */
    GSVector_t map_polyline;        /* areal extent of field, as a series of
                                       closed polygons.  NOTE: type = GSV_MAP_POLYLINE */
    GSCartoProjection_t proj;       /* Projection information */
    GSDP_t dp_null;                 /* Null value for floating point numbers */
    GSLongInt_t int_null;           /* Null value for integers */
    GSVector_t well_hdr;            /* vector of structures describing wells */
    } GSField_t;
d2214 12
a2225 3
/*    Well Tie Information  
      --------------------
 */
d2227 10
a2236 6
typedef struct                      /* This structure describes the relationship between
                                       a specific surface in a well and its correlation
                                       with a specifiv seismic line and shot point.
                                       Useful for tying geophysical/geological data in
                                       reservoir simulators */
    {
d2239 10
a2248 8
    GSSurfaceSetName_t surface_set_name;    /* Name of seismic surface this tie is correlated with */
    GSCartoProjection_t proj;       /* Projection information */
    GSString_t survey_name;         /* (optional) */
    GSString_t line_name;           /* (optional) */
    GSDP_t dp_null;                 /* Null value for floating point numbers */
    GSLongInt_t int_null;           /* Null value for integers */
    GSSeismicDataPoint_t seismic_loc;   /* location on seismic line */
    } GSSeismicWellTie_t;
d2250 3
a2252 3
/*    Map Information
      ---------------
 */
d2254 9
a2262 10
typedef struct 
    {
    GSString_t source_name;         /* Name of the data source. A null
                                       value is allowed (e.g. no source) */
    GSCartoProjection_t proj;       /* Projection information */
    GSDP_t dp_null;                 /* Null value for floating point numbers */
    GSLongInt_t int_null;           /* Null value for integers */
    GSString_t local_datum;         /* Datum reference for long., lat. */
    GSUnit_t z_unit;                /* Unit of elevation */
    GSExtents_t extent;             /* Area of interest of the map */
d2264 1
a2264 1
    } GSMap_t;
d2266 4
a2269 3
/*    Fault Trace (in map view) Information
      -------------------------------------
 */
d2271 8
a2278 9
typedef struct 
    {
    GSElevation_t z_datum;          /* Datum to use in association with elevations */
    GSCartoProjection_t proj;       /* Projection information */
    GSDP_t dp_null;                 /* Null value for floating point numbers */
    GSLongInt_t int_null;           /* Null value for integers */
    GSVector_t fault_surface;       /* Vector of structures of surfaces
                                       having fault traces defined */
    } GSFaultTraceSet_t;
d2280 10
a2289 10
/*    List of formation codes and stratigraphic columns
      -------------------------------------------------
 */
typedef struct 
    {
    GSVector_t lithostrat_code_desc;    /* A list of stratigraphic codes */
    GSVector_t stratigraphic_column;    /* List of stratigraphic columns */
    GSDP_t dp_null;                 /* Null value for floating point numbers */
    GSLongInt_t int_null;           /* Null value for integers */
    } GSLithostratCodeList_t;
d2291 11
a2301 10
/*    List of zone definitions and variables
      --------------------------------------
 */
typedef struct 
    {
    GSVector_t zone_definition;     /* List of zone definition */
    GSVector_t zone_variable_definition;    /* List of zone variable definitions */
    GSDP_t dp_null;                 /* Null value for floating point numbers */
    GSLongInt_t int_null;           /* Null value for integers */
    } GSZoneList_t;
d2303 2
a2304 1
/************************************************************************************/
d2310 5
a2314 3
/*  A status structure for returning to the exporting application information
    about the success/failure of the various functions performed by the receiver.
 */
d2316 6
a2321 7
typedef struct 
    {
    GSLongInt_t status_code;        /* error code */
    GSString_t object_key;          /* One or more object keys, separated by ^,
                                       identifying entity that produced status */
    GSString_t status_description;  /* Status description */
    } GSStatusReturn_t;
d2325 2
a2326 1
/************************************************************************************/
d2332 7
a2338 5
/*  There are two parts to receiver context within which a client must operate,
    environmental in the form of a possible memory limitation, and data in the
    form of things such as project names, pass words, file names, etc.  The
    following structures will be used to reply to a request for context
    information : */
d2340 4
a2343 5
typedef struct 
    {
    GSLongInt_t max_memory;         /* Size of local memory buffer, in bytes */
    GSVector_t context_requirements;    /* data context requirements */
    } GSReceiverContext_t;
d2345 4
a2348 2
/*  This structure is associated with defining the information 
to be sent to to the receiver to establish context. */
d2350 13
a2362 13
typedef struct 
    {
    enum 
        {
        GS_INTEGER_TYPE = 1,
        GS_CHARACTER_TYPE = 2,
        GS_FLOAT_TYPE = 3,
        GS_UNSIGNED_INTEGER = 4
        } type;                     /* Data type of context variable */
    GSLongInt_t max_length;         /* Maximum length of context variable (if string) */
    GSBoolean_t confidential;       /* Flag for whether to display user's input */
    GSString_t prompt;              /* Prompt string to use for requesting context variable */
    } GSContextRequirements_t;
d2364 7
a2370 4
/*  This vector is used to transmit the requested information back to
the exporting process.  There will be one string for each requirement specified
in the previous structure.  Even though an integer(perhaps unsigned) or float may be
required, it will be sent in ascii representation. */
d2372 2
a2373 1
typedef GSVector_t GSContextInformation_t;  /* this is a vector of type GSString_t */
d2375 4
a2378 2
/*   Upon establishment of the context, a token will be returned to the client
     process */
d2380 1
a2380 1
typedef GSLongInt_t GSContextToken_t;   /*  tag for context established */
d2382 2
a2383 1
/************************************************************************************/
d2389 9
a2397 9
/*  An executive structure containing context destination information for
    cross check reference to the context establishment information
    structure, and a list which provides reference to all 
    supported data type structures which are to be transmitted.  If context
    has been previously established then the context information structure
    need not be included.  If context has not been previously established
    then the context information structure must be referenced first in the 
    list(if necessary).
*/
d2399 4
a2402 2
/*   This structure allows description of an operation upon which to perform on
     the accompanying data structure */
d2404 12
a2415 13
typedef enum 
    {
    /*    Instruction is unknown, check disposition_ext */
    GS_CMD_UNKNOWN = 0,             /* Address of structure is undefined */
    /*    Interaction is complete, terminate                */
    GS_STOP_SERVER = 1000,          /* Address of structure is NULL */
    /*    Break current context, retain comm handshake      */
    GS_CONTEXT_BREAK = 1001,        /* Address of structure is NULL */
    /*    Return context requirements                       */
    GS_SEND_CONTEXT = 1002,         /* Address of structure is NULL */
    /*    Process everything, send no return status         */
    GS_NO_RETURN = 1003             /* Address of structure is NULL */
    } GSDataDisposition_t;
d2417 5
a2421 2
/*  The following is a list of top-level structures ('objects') that GeoLink defines.
    The list is extendable past the enum set by using the extension portion of the union. */
d2423 3
a2425 4
typedef enum 
    {
    GS_STRUCT_UNKNOWN = 0,          /* structure unknown to GeoShare is passed,
                                       check type_ext for value */
d2440 1
a2440 1
    } GSDataStructType_t;
d2442 1
a2442 2
typedef struct 
    {
d2449 1
a2449 1
    } GSStructure_t;
d2451 4
a2454 5
typedef struct 
    {
    GSContextToken_t context_token; /* tag for context established */
    GSVector_t gs_structure;        /* vector of structures on which to act */
    } GSExecutive_t;
d2456 2
a2457 1
/************************************************************************************/
d2463 8
a2470 8
/*  A Receiver information structure is returned to the GeoShare Server
    upon request.  This structure contains the following information:
        a.  Status of Receiver service initialization
        b.  A unique name for the receiver so a client can ask for it by name (if known).
        c.  A descriptive text string to show the user in a list of receivers
        d.  Exploration data structures supported
        e.  Data structure revision level range supported
 */
d2472 8
a2479 5
/*  Support for a given data structure is composed of three parts, an enumerated
    parameter which indicates that it is supported, a mask variable in which
    the receiver indicates which components of the structure it can handle, and 
    a structure indicating the GeoShare version which it supports.  The
    following #define statements provide the component masks: */
d2483 7
a2489 6
#define GSM_SS_GRID            (1<<0)   /* grid structure is supported */
#define GSM_SS_SEISMIC         (1<<1)   /* seismic interpretation is supported */
#define GSM_SS_XYZ             (1<<2)   /* xyz scatter data are supported */
#define GSM_SS_CONSTANT        (1<<3)   /* constant data are supported */
#define GSM_WELL_MARKER        (1<<4)   /* Well Marker data are supported */
#define GSM_SS_CONTOUR         (1<<5)   /* Contour Information is supported */
d2493 6
a2498 5
#define GSM_SEISMIC_2D         (1<<0)   /* 2d seismic line input is supported */
#define GSM_SEISMIC_3D         (1<<1)   /* 3d Survey input is supported */
#define GSM_SEISMIC_LINE_HDR   (1<<2)   /* Seismic line header data are supported */
#define GSM_SEISMIC_TRACE      (1<<3)   /* Seismic trace data are supported */
#define GSM_SEISMIC_SURFACE    (1<<4)   /* Seismic surface data are supported */
d2502 11
a2512 9
#define GSM_WELL_CHECKSHOT     (1<<0)   /* Checkshot information is supported */
#define GSM_WELL_PATH          (1<<1)   /* Path data are supported */
#define GSM_WELL_LOG_RUN       (1<<2)   /* Log run data are supported */
#define GSM_WELL_WELL_CORE     (1<<3)   /* Core data are supported */
#define GSM_WELL_ZONE_VALUE    (1<<4)   /* Zone value data are supported */
#define GSM_WELL_WELL_MARKER   (1<<5)   /* Well marker(tops) data are supported */
#define GSM_WELL_PRODUCTION    (1<<6)   /* Production history data are supported */
#define GSM_WELL_TUBULARS      (1<<7)   /* Tubular information are supported */
#define GSM_WELL_REMARKS       (1<<8)   /* Remark information are supported */
d2516 4
a2519 5
#define GSM_FIELD_WELLS        (1<<0)   /* Field Well data are supported */
#define GSM_FIELD_BOUNDARY     (1<<1)   /* Field boundary is supported */
#define GSM_FIELD_ZONE_VALUE   (1<<2)   /* Field zone data are supported */
typedef struct 
    {
d2523 1
a2523 1
    } GSDataSupported_t;
d2525 8
a2532 9
typedef struct 
    {
    GSLongInt_t receiver_status;    /* Reserved for future use */
    GSString_t receiver_name;       /* Unique character identifier of receiver
                                       (<=20 characters ) */
    GSString_t banner_string;       /* Your chance to advertise your product!
                                       (<=60 characters ) */
    GSVector_t data_supported;      /* List of types of data the server supports */
    } GSReceiverSpecs_t;
d2534 10
a2543 7
/*  A client application may request information from the GeoShare server about
    which application servers are available for the task the client wishes.  It
    may specify the request in terms of a receiver name or in terms of data
    structures supported.  If more than one specification is provided, then
    receivers meeting any of the specifications will be included.  A vector of 
    the following structures will be passed to the GeoShare server as input to 
    making a list of receivers which will satisfy the criteria: */
d2547 5
a2551 7
typedef struct 
    {
    enum 
        {
        GS_STRUCT_SUPPORTED = 1,
        GS_NAME = 2
        } spec_type;
d2554 1
a2554 1
    } GSRequirement_t;
@


1.3
log
@*** empty log message ***
@
text
@d1 1
d9 9
d64 1
a64 1
|                               K Waagb, GECO Schlumberger
d72 10
a82 9
|-------------------------------------------------------------------------------
|-------------------------------------------------------------------------------
| 
|         This code is the product of of
|         GeoQuest Systems, Inc. and Finder Graphics Systems, Inc
|         and is protected under U.S. Copyright laws.
|         This code may be reproduced in part or whole by any
|         technique or facsimile adoption as long as this notice is included.
| 
d141 36
d214 1
a214 1
/************************************************************************************/
d243 1
a243 1
typedef union 
d245 69
a313 72
    enum 
        {
        GSV_UNKNOWN = 0,             /* vector type is unknown */
        /* basic data types */
        GSV_INT = 10,                /* vector type GSLongInt_t */
        GSV_REAL = 11,               /* vector type GSReal_t */
        GSV_DP = 12,                 /* vector type GSDP_t */
        GSV_FRAC8 = 13,              /* vector type 8 bit int fraction */
        GSV_FRAC16 = 14,             /* vector type 16 bit int fraction */
        GSV_UNSIGNED_LONG = 15,      /* vector type GSUlong_t */
        GSV_BOOLEAN = 16,            /* vector type GSBoolean_t */
        GSV_RATIONAL = 17,           /* vector type GSRational_t */
        GSV_CHAR = 18,               /* vector type char */
        GSV_COMPLEX = 19,            /* vector type complex */
        GSV_STRING = 20,             /* vector type GSString_t */
        /* executive structure vectors */
        GSV_RECEIVER_RQMTS = 100,    /* vector type GSReceiverRqmts_t */
        GSV_DATA_SUPPORTED = 101,    /* vector type GSDataSupported_t */
        GSV_GSSTRUCTURE = 102,       /* vector type GSStructure_t */
        GSV_RECEIVER_CONTEXT = 103,  /* vector type GSReceiverContext_t */
        GSV_STATUS_RETURN = 104,     /* vector type GSStatusReturn_t */
        /* basic point structures */
        GSV_XYZ_POINT = 1000,        /* vector type GSXYZPoint_t */
        GSV_SEISMIC_DATA_POINT = 1001,/* vector type GSSeismicDataPoint_t */
        GSV_MAP_LOCATION = 1002,     /* vector type GSMapLocation_t */
        GSV_DEPTHS = 1003,           /* vector type GSDepth_t */
        GSV_PROCESS_HISTORY = 1004,  /* vector type GSProcessHistory_t; */
        /* stratigraphic data structures */
        GSV_STRAT_COLUMN = 2000,     /* vector type GSStratigraphicColumn_t */
        GSV_LITHOSTRAT_CODE_DESC = 2001,/* vector type GSLithostratCodeDesc_t */
        /* zone structures */
        GSV_ZONE_VARIABLE_DEF = 3000,/* vector type GSZoneVariableDefinition_t */
        GSV_ZONE_DEF = 3001,         /* vector type GSZoneDefinition_t */
        GSV_ZONE_VALUE = 3002,       /* vector type GSZoneValue_t */
        /* well structures */
        GSV_WELL_REMARKS = 4001,     /* vector type GSWellRemarks_t */
        GSV_WELL_TUBULARS = 4002,    /* vector type GSWellTubulars_t */
        GSV_WELL_PRODUCTION = 4003,  /* vector type GSWellProduction_t */
        GSV_WELL_MARKER = 4004,      /* vector type GSWellMarker_t */
        GSV_WELL_CORE = 4005,        /* vector type GSWellCore_t */
        GSV_WELL_ATTRIBUTE = 4006,   /* vector type GSWellAttribute_t */
        GSV_WELL_HDR = 4007,         /* vector type GSWellHdr_t */
        /* well log structures */
        GSV_LOG_RUN = 5000,          /* vector type GSLogRun_t */
        GSV_LOG_PASS = 5001,         /* vector type GSLogPass_t */
        GSV_LOG_SERVICE = 5002,      /* vector type GSLogService_t */
        GSV_LOG_TRACE = 5003,        /* vector type GSLogTrace_t */
        /* seismic data structures */
        GSV_SEIS_TRACE = 6000,       /* vector type GSSeismicTrace_t */
        GSV_SEISMIC_CLASS = 6001,    /* vector type GSSeismicClass_t */
        GSV_SEISMIC_LINE = 6002,     /* vector type GSSeismicLine_t */
        /* map object structures */
        GSV_MAP_POLYLINE = 7000,     /* vector type GSMapPolyline_t */
        GSV_MAP_POINT = 7001,        /* vector type GSMapPoint_t */
        GSV_MAP_SYMBOL = 7002,       /* vector type GSMapSymbol_t */
        GSV_MAP_ANNOTATION = 7003,   /* vector type GSMapAttribute_t */
        GSV_MAP_ATTRIBUTE = 7004,    /* vector type GSMapAnnotation_t */
        GSV_MAP_OBJECTS = 7005,      /* vector type GSMapObjects_t */
        GSV_ATTRIBUTE_ITEM = 7006,   /* vector type GSAttributeItem_t */
        /* seismic interpretation surface structures */
        GSV_CONTACT = 8000,         /* vector type GSContact_t */
        GSV_SEGMENT = 8001,          /* vector type Segment_t */
        GSV_INTERP_CLASS = 8002,     /* vector type InterpretedClass_t */
        GSV_INTERP_LINE = 8003,      /* vector type InterpretedLine_t */
        /* fault trace structures */
        GSV_FAULT_TRACE = 9000,      /* vector type FaultTrace_t */
        GSV_FAULT_SURFACE = 9001,    /* vector type FaultSurface_t */
        /* surface executive structures */
        GSV_SURFACE_ATTRIBUTE = 10000,/* vector type SurfaceAttribute_t */
        GSV_SUFACE_GEOMETRY = 10001 /* vector type SurfaceGeometry_t */
        } symbolic;
    GSLongInt_t extension;
d319 1
d331 1
d364 3
a366 1
/* Geophysical data types */
d381 1
a381 2
    GS_SRF_TYPE_FLT = 2,            /* surface type fault */
    GS_SRF_TYPE_MARKER = 3          /* surface type (geologic) marker */
d384 20
d417 3
a419 2
/*    Processing History structure           
      ---------------------------- */
d428 16
a451 3
/*
 *       masks defining validity of items in struct point
 */
a452 17
#define GSM_VALID_CDP          (1<<0)   /* cdp number is valid */
#define GSM_VALID_SP           (1<<1)   /* shot point number is valid */
#define GSM_VALID_X            (1<<2)   /* x location is valid */
#define GSM_VALID_Y            (1<<3)   /* y location is valid */
#define GSM_VALID_Z            (1<<4)   /* z location is valid */
#define GSM_VALID_LONGITUDE    (1<<5)   /* longitude is valid */
#define GSM_VALID_LATITUDE     (1<<6)   /* latitude is valid */
#define GSM_VALID_CONNECT      (1<<7)   /* connectivity vector in xyz scatter data */

/* Used in GSDepth_t structure */
#define GSM_VALID_MD           (1<<8)   /* measured depth is valid */
#define GSM_VALID_SUBDATUM     (1<<9)   /* subdatum depth is valid */
#define GSM_VALID_TVD          (1<<10)  /* true vertical depth is valid */
#define GSM_VALID_TIME         (1<<11)  /* time is valid */
#define GSM_VALID_DX           (1<<12)  /* deviation in x direction is valid */
#define GSM_VALID_DY           (1<<13)  /* deviation in y direction is valid */

d493 53
d573 1
a573 1
    GSXYZPoint_t point;             /* cartesian points associated with map data point */
d581 1
a581 1
    GSCDP_t cdp;                    /* CDP Number associated with point */
d587 1
a587 1
    GSMapLocation_t point;          /* location associated with cdp/shot point */
d590 14
d624 2
a625 2
We will assume all location information contained within the seismic data
sturcture is given in the same coordinate system.  To properly define the
d633 1
a633 1
   use with 'interface.h'.
d884 1
d891 1
a891 1
    GSSurfaceSetName_t surface_set_name;  /* Surface set name */
d972 1
a972 1
    GSSurfaceSetName_t surface_set_name;  /* Surface set name */
d1031 9
a1039 3
    GSVector_t seismic_data_point;  /* Vector of station location structures
                                     (Not used for surface set - use Segment_t list) */
    } GSSeismicLocation2D_t;
d1085 2
a1086 2
/*    Line Header                                 
      ----------- */
a1110 1
    GSUlong_t n_live_samps;         /* number of live samples */
d1115 2
a1116 3
    GSDistance_t shotpoint_interval;    /* distance bewteen shots (offset unit) */
    GSDistance_t receiver_interval; /* distance between receivers */
    GSDistance_t cdp_interval;      /* distance between cdps */
a1117 2
    GSSeismicLocation2D_t line_numbering;    /* specification of cdp/shotpoint numbering */
    
d1125 2
a1126 4
    GSBoolean_t cdps_valid;         /* TRUE = linear progression of cdps to lcs */
    GSRational_t cdp_incr;          /* cdp number increment per trace */
    GSBoolean_t shotpoint_valid;    /* TRUE = linear progression of sps to lcs */
    GSRational_t shotpoint_incr;    /* shotpoint increment per trace */
d1128 7
a1134 7
    GSReal_t max_amplitude;         /* volume statistics */
    GSReal_t min_amplitude;
    GSReal_t max_magnitude;
    GSReal_t min_magnitude;
    GSReal_t rms_amplitude;
    GSReal_t mean_amplitude;
    GSReal_t mean_magnitude;
d1141 1
d1144 7
a1150 2
/*    Trace Header                                 
      ------------ */
d1156 18
d1179 6
d1187 1
a1188 1
    GSShotPoint_t cdp_sp;           /* shotpoint corresponding to this cdp */
a1189 6
    GSElevation_t cdp_datum;        /* cdp datum */
    GSElevation_t cdp_wdepth;       /* depth of weathering layer at CDP location */
    GSVelocity_t cdp_wvel;          /* velocity of weathering layer at CDP location */
    GSMapLocation_t cdp_xyz;        /* cdp location & elevation */
    GSDistance_t distance;          /* signed trace distance from shot to receiver
                                     with respect to line direction */
a1191 39
    
    GSRational_t shot_location;     /* shotpoint location number */
    GSElevation_t shot_datum;       /* shotpoint elevation datum */
    GSElevation_t shot_wdepth;      /* depth of weathering layer at SP */
    GSVelocity_t shot_wvel;         /* velocity of weathering layer at SP */
    GSMapLocation_t shot_xyz;       /* shotpoint location & elevation */
    GSElevation_t shot_depth;       /* depth of shot */
    GSReal_t uphole_time;           /* shot uphole time in sampling interval unit */
    
    GSRational_t receiver_location; /* receiver location number */
    GSElevation_t receiver_datum;   /* receiver elevation datum */
    GSElevation_t receiver_wdepth;  /* depth of weathering layer at receiver location */
    GSVelocity_t receiver_wvel;     /* velocity of weathering layer at receiver location */
    GSMapLocation_t receiver_xyz;   /* receiver location & elevation */
    
    GSLongInt_t statics_flag;       /* statics application bit flag */
    /* 0 - shot W statics computed */
    /* 1 - shot W statics applied */
    /* 2 - receiver W statics computed */
    /* 3 - receiver W statics applied */
    /* 4 - shot D static computed */
    /* 5 - shot D static applied */
    /* 6 - receiver D static computed */
    /* 7 - receiver D static applied */
    /* 8 - shot A static computed */
    /* 9 - shot A static applied */
    /* 10- receiver A static computed */
    /* 11- receiver A static applied */
    /* 12- cdp A static computed */
    /* 13- cdp A static applied */
    /* 14- bulk static computed */
    /* 15- bulk static applied */
    GSStatic_t receiver_wstatic;    /* receiver weathering static */
    GSStatic_t receiver_dstatic;    /* receiver datum static */
    GSStatic_t receiver_astatic;    /* receiver automatic static */
    GSStatic_t shot_wstatic;        /* shot weathering static */
    GSStatic_t shot_dstatic;        /* shot datum static */
    GSStatic_t shot_astatic;        /* shot automatic static */
    GSStatic_t cdp_astatic;         /* cdp automatic static */
d1193 1
a1194 14
    GSLongInt_t record_no;          /* sequential record number */
    GSLongInt_t record_trace_no;    /* record trace number */
    GSLongInt_t field_record_no;    /* field record number */
    GSLongInt_t field_record_trace_no;
    
    GSLongInt_t n_live;             /* number of non-zero samples */
    GSReal_t max_amplitude;         /* maximum signed amplitude */
    GSReal_t min_amplitude;         /* minimum signed amplitude */
    GSReal_t max_magnitude;         /* maximum magnitude */
    GSReal_t min_magnitude;         /* minimum magnitude */
    GSReal_t mean_amplitude;        /* mean trace amplitude */
    GSReal_t mean_magnitude;        /* mean magnitude of trace */
    GSReal_t rms_amplitude;         /* rms amplitude of trace */
    
d1198 4
a1201 13
    GSLongInt_t user_1;             /* user trace header values */
    GSLongInt_t user_2;
    GSLongInt_t user_3;
    GSLongInt_t user_4;
    } GSSeismicTraceHdr_t;

/*    Trace                                  
      ----- */

typedef struct 
    {
    GSMapLocation_t trace_loc;      /* map location of trace */
    GSSeismicTraceHdr_t header;     /* Structure containing seismic trace header */
d1207 3
a1209 3
/*    Line Description Structure
      --------------------------
 
d1229 1
a1229 1
    GSSeismicLocation2D_t loc;      /* GS_LINE_2D, GS_LINE_RCN types only */
a1233 1
/************************************************************************************/
d1240 2
a1241 2
    GSVector_t seismic_trace;       /* Vector of seismic traces */
    GSVector_t seismic_surface;     /* Vector of seismic surfaces */
d1278 1
a1278 11
    enum 
        {
        GS_SNAP_P_NEAR = 1,         /* nearest peak to center of window */
        GS_SNAP_P_MAX = 2,          /* largest peak in window */
        GS_SNAP_T_NEAR = 3,         /* nearest trough to center of window */
        GS_SNAP_T_MAX = 4,          /* largest trough in window */
        GS_SNAP_ZPN = 5,            /* zero crossing, positive to negative */
        GS_SNAP_ZNP = 6,            /* zero crossing, negative to positive */
        GS_SNAP_NULL = 7,           /* snap to input point */
        GS_SNAP_UNDEFINED = 8       /* undefined snap type */
        } snap_event;
d1287 1
a1287 1
    GSSeismicDataPoint_t loc;       /* location of contact point */
d1291 1
a1291 1
    GSString_t name_2;              /* second name associated with contact */
d1297 1
a1297 8
    enum                            /* Type of z data in point vector */
        {
        GS_Z_TYPE_UNDEFINED = 0,
        GS_TIME_UNSNAPPED = 1,      /* Z time is original picks */
        GS_TIME_REFINED = 2,        /* Z time is snapped and smoothed */
        GS_AMPLITUDE = 3            /* Z is amplitude from class of 
                                       seismic data associated with surface */
        } z_type;
d1338 1
a1338 7
    enum                            /* z value code */
        {
        GS_Z_VALUE_UNDEFINED = 0,   /* no z value is defined */
        GS_Z_VALUE_TIME = 1,        /* z value is time */
        GS_Z_VALUE_UNSNAPPED_TIME = 2,  /* z value is unsnapped time */
        GS_Z_VALUE_DEPTH = 3        /* z value is depth */
        } z_value_code;
d1355 1
a1355 2
        GS_REP_SEISMIC,
        GS_REP_XYZ,
d1357 1
a1357 2
        GS_REP_CONTOUR,
        GS_REP_WELL_MARKER
a1361 1
        GSSeismicSurface_t seismic;
a1364 2
        GSVector_t well_marker;     /* Used for marker geometry */
        GSVector_t well_attribute;  /* Used for secondary attributes at marker location */
d1385 53
a1437 1
/************************************************************************************/
d1546 4
a1549 4
        GS_JEFFERSONIAN,
        GS_GULF_COAST_OFFSHORE,
        GS_TEXAS_ABSTRACT,
        GS_OCS_OFFSHORE
d1597 1
a1597 1
            GSString_t utm_grid_bloc;   /* Universal Transverse Mercator block
d1724 2
a1725 2
        GS_IMPERIAL_UNIT,
        GS_METRIC_UNIT
d1734 7
a1740 6
	struct {
		GSBoolean_t flag;           /* confidentiality flag */
		GSString_t formcode;        /* confidentiality formation */
		GSDepth_t depth;            /* confidentiality depth */
		GSDate_t release_date;      /* confidential release date */
		} confidential;
d1757 1
a1757 1
    GSVector_t well_core;           /* Vector of core data (WellCore_t) */
d1764 1
d1777 2
a1778 2
        GS_WELL_CORE_NORMAL,        /* Normal well core */
        GS_WELL_CORE_SIDEWALL       /* Sidewall core */
d1795 1
a1795 1
structures.  The intent id to allow another vendor to display this information somehow
d1798 1
d1868 2
a1869 1
    It usually is associated with a single billing cycle */
d1886 3
a1888 3
        GSMudResistivity_t resistivity;   /* Resistivity of mud */
        GSMudResistivity_t resistivity_bht;   /* Resistivity of mud at bottom hole
                                               temperature */
d1944 3
a1946 3
        GS_OIL,
        GS_WATER,
        GS_GAS
d1988 4
a1991 4
    GS_LITHO_TOP,                   /* Lithostratigraphic (formation) top */
    GS_CONTACT_TOP,                 /* Fluid surface contact (e.g. oil/water) */
    GS_FAULT_POINT,                 /* Piercing point of well through fault plane */
    GS_MARKER_TOP,                  /* Stratigraphic marker - subordinate to
d1993 1
a1993 1
    GS_OTHER_TOP
d2040 1
a2040 1
                                     this field contains the name of the next higher order */
d2059 16
d2102 1
a2102 1
    GSSeismicLocation3D_t loc;      /* 3d survey specificaton and
d2120 1
d2134 1
a2134 1
                                     closed polygons.  NOTE: type = GSV_MAP_POLYLINE */
d2153 1
a2153 1
    GSSurfaceSet_t seismic_surface;
d2159 1
a2159 1
    GSSeismicDataPoint_t loc;       /* location on seismic line */
d2169 1
a2169 1
                                     value is allowed (e.g. no source) */
d2190 1
a2190 1
                                     having fault traces defined */
d2200 2
d2211 2
d2233 1
a2233 4
typedef struct 
    {
    GSVector_t status_return;
    } GSStatusVector_t;
d2265 1
a2265 1
    GSLongInt_t max_length;         /* Maximum length of context variable *if string) */
d2270 1
a2270 1
/*  This structure is used to transmit the requested information back to
d2272 1
a2272 1
in the previous structure.  Even though an integer(perhaps unsigned) may be
d2275 1
a2275 4
typedef struct 
    {
    GSVector_t string_array;        /*  array of strings */
    } GSContextInformation_t;
d2280 1
a2280 1
typedef GSLongInt_t GSContextToken_t; /*  tag for context established */
d2301 1
a2301 1
typedef union 
d2303 10
a2312 12
    enum 
        {
        /*    Interaction is complete, terminate                */
        GS_STOP_SERVER = 1000,      /* Address of structure is NULL */
        /*    Break current context, retain comm handshake      */
        GS_CONTEXT_BREAK = 1001,    /* Address of structure is NULL */
        /*    Return context requirements                       */
        GS_SEND_CONTEXT = 1002,     /* Address of structure is NULL */
        /*    Process everything, send no return status         */
        GS_NO_RETURN = 1003         /* Address of structure is NULL */
        } symbolic;
    GSLongInt_t extension;
d2318 1
a2318 1
typedef union 
d2320 16
a2335 19
    enum 
        {
        GS_STRUCT_RECEIVER_SPECS = 1,
        GS_STRUCT_RECEIVER_RQMTS = 2,
        GS_STRUCT_CONTEXT_RQMTS = 3,
        GS_STRUCT_CONTEXT_INFO = 4,
        GS_STRUCT_CONTEXT_TOKEN = 5,
        GS_STRUCT_STATUS_RETURN = 6,
        GS_STRUCT_SEISMIC_SURVEY = 11,
        GS_STRUCT_SURFACE_SET = 12,
        GS_STRUCT_WELL_FIELD = 13,
        GS_STRUCT_WELL_TIE = 14,
        GS_STRUCT_MAP = 15,
        GS_STRUCT_FAULT_TRACE_SET = 16,
        GS_STRUCT_LITHOSTRAT_CODES = 17,
        GS_STRUCT_ZONES = 18,
        GS_STRUCT_RECEIVER_TERMINATE = 19
        } symbolic;
    GSLongInt_t extension;
d2341 1
d2343 1
a2408 1

d2422 1
a2422 1
                                       (<=80 characters ) */
d2429 4
a2432 3
    structures supported.  A vector of the following structures will be passed
    to the GeoShare server as input to making a list of receivers which will 
    satisfy the criteria: */
d2434 1
a2434 4
typedef struct 
    {
    GSVector_t requirement;
    } GSReceiverRqmts_t;
a2451 1

@


1.2
log
@*** empty log message ***
@
text
@@


1.1
log
@*** empty log message ***
@
text
@d2200 2
a2201 1
        GS_STRUCT_ZONES = 18
@


1.0
log
@Initial
@
text
@d239 1
a239 2
        GSV_WELL_MARKER = 4007,      /* vector type GSWellMarker_t */
        GSV_WELL_HDR = 4008,         /* vector type GSWellHdr_t */
@
